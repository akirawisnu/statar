% Generated by roxygen2 (4.0.2): do not edit by hand
\name{fill_na}
\alias{fill_na}
\title{fill NA based on non missing observations}
\usage{
fill_na(.data, ..., order_by, roll = TRUE, rollends = if (roll == "nearest")
  c(TRUE, TRUE) else if (roll >= 0) c(FALSE, TRUE) else c(TRUE, FALSE),
  inplace = FALSE)
}
\arguments{
\item{.data}{a data.table}

\item{...}{variables to fill in. Default to every variable except grouped and order_by}

\item{order_by}{a variable along with observations should be filled}

\item{roll}{When roll is a positive number, this limits how far values are carried forward. roll=TRUE is equivalent to roll=+Inf. When roll is a negative number, values are rolled backwards; i.e., next observation carried backwards (NOCB). Use -Inf for unlimited roll back. When roll is "nearest", the nearest value is joined to.}

\item{inplace}{Should the variable modified in place ? Default to FALSE.}

\item{rollend}{A logical vector length 2 (a single logical is recycled). When rolling forward (e.g. roll=TRUE) if a value is past the last observation within each group defined by the join columns, rollends[2]=TRUE will roll the last value forwards. rollends[1]=TRUE will roll the first value backwards if the value is before it. If rollends=FALSE the value of i must fall in a gap in x but not after the end or before the beginning of the data, for that group defined by all but the last join column. When roll is a finite number, that limit is also applied when rolling the end}
}
\description{
fill NA based on non missing observations
}
\examples{
DT <- data.table(
 id    = c(1, 1, 1, 1, 1, 2, 2),
 date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),
 value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)
)
DT \%>\% group_by(id) \%>\% fill_na(value, order_by = date)
DT \%>\% group_by(id) \%>\% fill_na(value, order_by = date, inplace = TRUE)
}

