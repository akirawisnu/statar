#' Gives summary statistics (Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude in s You can use same specifications as in select. If missing, defaults to all non-grouping variables.#
#' @param inplace Change data.table in place or not#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 =  sample(5, N, TRUE),                          #
#'   v2 =  sample(1e6, N, TRUE),                       #
#'   v3 =  sample(round(runif(100, max = 100), 4), N, TRUE) #
#' )#
#' DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#' @export#
colorder <- function(.data, ..., inplace = FALSE) {#
  colorder_(.data, vars = lazyeval::lazy_dots(...) , inplace = inplace)#
}#
#' @export#
colorder_ <- function(.data, vars, inplace = FALSE ) {#
  if (length(vars) == 0) {#
     vars <- lazyeval::lazy_dots(everything())#
   }#
  vars <- select_vars_(tbl_vars(.data), vars)#
  if (!inplace) .data <- copy(.data)#
  setcolorder(.data,c(vars,setdiff(names(.data),vars)))#
  .data#
}
DT  %>% colorder(starts_with("v"), inplace = TRUE)
DT
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT  %>% colorder(starts_with("v"), inplace = TRUE)
DT
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
library(dplyr)#
library(statar)#
#
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
      id = 1:N,#
      v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
      v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
      v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
    )#
#
### quantile category (=Stata xtile)#
DT %>% group_by(v1) %>% mutate(xtile(v2, nq = 3))#
DT %>% group_by(v1) %>% mutate(xtile(v2, cutpoints = c(1e5,5e5) ))
DT %>% group_by(id) %>% mutate(lag(value, order_by = time)) # Balanced dataset#
DT %>% group_by(id) %>% mutate(lag(value, along_with = time)) # Unbalanced dataset
DT %>% group_by(id) %>% mutate(lag(value, order_by = time)) # Balanced dataset
DT %>% group_by(id) %>% mutate(lag(v2, order_by = time)) # Balanced dataset
DT %>% group_by(id) %>% mutate(lag(v2, along_with = time)) # Unbalanced dataset
DT %>% group_by(id) %>% mutate(lag(v2, order_by = v1))
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))
library(data.table)#
#
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
### col_order (= Stata order)#
DT  %>% col_order(starts_with("v"))#
DT  %>% col_order(starts_with("v"), inplace = TRUE)#
#
### sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))#
#
### expand (= Stata tsfill)#
DT <- data.table(#
 id = c(1, 1, 1, 1, 1, 2, 2),#
 date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
 value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% group_by(id) %>% expand(date)#
DT %>% expand(date)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
?spread
?gather
library(tidyr)
?gather
stocks <- data.frame(#
  time = as.Date('2009-01-01') + 0:9,#
  X = rnorm(10, 0, 1),#
  Y = rnorm(10, 0, 2),#
  Z = rnorm(10, 0, 4)#
)
stocks
socks %>% gather(type, price)
library(dplyr)
socks %>% gather(type, price)
stocks %>% gather(type, price)
DT_long <- DT_wide %>% gather(variable, value, -time)
DT_long <- stocks %>% gather(variable, value, -time)
DT_long
DT_long <- DT_wide %>% spread (variable, value, -time)
DT_wide <- DT_long %>% spread (variable, value, -time)
?spread
DT_wide <- DT_long %>% spread(variable, value, -time)
DT_wide <- DT_long %>% spread(variable, value)
DT_wide
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2(4.5,3.0)))
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2(4.5,3.0))
library(data.table)
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2(4.5,3.0))
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2=c(4.5,3.0))
DT_wide
DT_wide %>% gather(variable, value, -i)
DT_long <- DT_wide %>% gather(variable, value, -i)
DT_long %>% spread(variable, value)
assignInNamespace("cedta.override", c(data.table:::cedta.override,"IRkernel#
                                      "), "data.table")
showMethods(expand)
library(matrix)
showMethods(expand)
library(Matrix)
showMethods(expand)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
library(statar)
library(data.table)
?hour
library(matrix)
library(Matrix)
?expand
showMethods(Matrix)
is.object(expand) & !isS4(expand)
is.object(expand
)
!isS4(expand)
isS4(expand)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
library(lubridate)
weeks
months
months(1)
years(1)
years
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
library(biglm)#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))
?expand
?expand_
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
lag
?lag
?lead
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
library(biglm)#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))
?lag
?lead
?expand
?xtile
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
?sum_up
library(statar)
?sum_up
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(statar)
?sum_up
library(statar)
?sum_up
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
lead_along <- function(x, n = 1L, units = NULL, date, default = NA) {#
  if (!is.null(units)) {#
    if (is.null(date)) stop("units cannot be used without order_by")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    date_origin <- as.Date('0001-01-01')#
    if (unitsc=="day"){#
      return(lead_along(x = x, n = n, default = default, date = along))#
    }#
    if (unitsc == "week"){#
      date_elapsed <- as.period(date-date_origin)  %/% weeks(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    }  #
    else if (unitsc == "month"){#
      date_elapsed <- as.period(date-date_origin)  %/% months(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    } else if (unitsc == "quarter"){#
      date_elapsed <- as.period(date-date_origin)  %/% 3*months(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    } else if (unitsc == "year"){#
      date_elapsed <- as.period(date-date_origin)  %/% years(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    }#
  }#
#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
  index <- match(date + n, date, incomparable = NA)#
  out <- x[index]#
  if (!is.na(default)) out[which(is.na(index))] <- default#
  attributes(out) <- attributes(x)#
  out#
}
lag_along <- function(x, n = 1L,  units = NULL, date = NULL, default = NA) {#
    if (!is.null(units)) {#
      if (is.null(date)) stop("units cannot be used without order_by")#
      unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
      date_origin <- as.Date('0001-01-01')#
      if (unitsc=="day"){#
        return(lag_along(x = x, n = n, default = default, date = along))#
      }#
      if (unitsc == "week"){#
        date_elapsed <- as.period(date-date_origin)  %/% weeks(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      }  #
      else if (unitsc == "month"){#
        date_elapsed <- as.period(date-date_origin)  %/% months(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      } else if (unitsc == "quarter"){#
        date_elapsed <- as.period(date-date_origin)  %/% 3*months(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      } else if (unitsc == "year"){#
        date_elapsed <- as.period(date-date_origin)  %/% years(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      }#
    }#
#
    if (n == 0) return(x)#
    if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
    index <- match(date - n, date, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
    attributes(out) <- attributes(x)#
    out#
  }
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
date := as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%y")
date = as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%y")
date+1
date
date = as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%y")
date
?as.Date
date = as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%Y")
date
devtools::install_github("matthieugomez/tidyr")#
devtools::install_github("matthieugomez/lazyeval")#
devtools::install_github("matthieugomez/dplyr")#
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(dplyr)#
library(data.table)#
library(statar)#
#
# partition creates quantile categories (corresponds to Stata xtile)#
v2 <-   sample(1e6, 1e6, TRUE)                   #
v2_categorized <- partition(v2, nq = 3) # 3 groups based on terciles#
v2_categorized <- partition(v2, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
# lag/lead create lag/lead variables (corresponds to Stata L. F.)#
## unbalanced panel#
DT <- data.frame(#
 date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
 value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% mutate(lag(value, 1, order_by = date)) # wrong#
DT %>% mutate(lag(value, 1, along_with = date)) # right#
#
## periods can be used instead of integers#
library(lubridate)#
df <- data.frame(     #
   id = c("id1", "id1", "id1", "id1"),#
   date = mdy(c("03/01/1992", "04/03/1992", "07/15/1992", "08/21/1992")),#
   value = c(4.1, 4.5, 3.3, 5.3)#
)#
df <- df %>% mutate(date = floor_date(date, "month"))#
df %>% group_by(id) %>% mutate(lag(value, months(1), along_with = date))
?data.table::lag
?lag
library(data.table)
library(dplyr)
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }#
#
DT <- data.table(#
   id = c(1, 1, 1, 1, 1, 2, 2),#
   date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
   value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
#
R> DT#
   id date value#
1:  1 1992   4.1#
2:  1 1989   4.5#
3:  1 1991   3.3#
4:  1 1990   5.3#
5:  1 1994   3.0#
6:  2 1992   3.2#
7:  2 1991   5.2#
R> DT %>% group_by(id) %>% mutate( lead_lag(value,1) )#
Source: local data table [7 x 4]#
Groups: id#
#
  id date value lead_lag(value, 1)#
1  1 1992   4.1                4.5#
2  1 1989   4.5                4.5#
3  1 1991   3.3                4.5#
4  1 1990   5.3                4.5#
5  1 1994   3.0                4.5#
6  2 1992   3.2                5.2#
7  2 1991   5.2                5.2#
R>
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }#
#
DT <- data.table(#
   id = c(1, 1, 1, 1, 1, 2, 2),#
   date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
   value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
#
DT#
   id date value#
1:  1 1992   4.1#
2:  1 1989   4.5#
3:  1 1991   3.3#
4:  1 1990   5.3#
5:  1 1994   3.0#
6:  2 1992   3.2#
7:  2 1991   5.2#
DT %>% group_by(id) %>% mutate( lead_lag(value,1) )#
Source: local data table [7 x 4]#
Groups: id#
#
  id date value lead_lag(value, 1)#
1  1 1992   4.1                4.5#
2  1 1989   4.5                4.5#
3  1 1991   3.3                4.5#
4  1 1990   5.3                4.5#
5  1 1994   3.0                4.5#
6  2 1992   3.2                5.2#
7  2 1991   5.2                5.2#
R>
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }#
#
DT <- data.table(#
   id = c(1, 1, 1, 1, 1, 2, 2),#
   date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
   value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)
R> DT %>% group_by(id) %>% mutate( lead_lag(value,1) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1,order_by(date)) )
debug(lead_lag)
DT %>% group_by(id) %>% mutate( lead_lag(value,1,order_by(date)) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1)) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1))
s
n
s
debug(lead_lag)
lead_lag(DT$value,1)
s
f
lead_lag(value,1)
s
f
undebug(lead_lag)
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }
lead_lag(c(1,2),k=1)
lag(c(1,2),n=1)
sign(k){if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}
sign(k){if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}}
lead_lag(k) <- function{if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}}
lead_lag(k) <- function(k){if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}}
lead_lag(k) <- function(k){if (k>0){function(x){lag(x,k)}}else{function(x){lead(x,k)}}
}
lead_lag <- function(k){if (k>0){function(x){lag(x,k)}}else{function(x){lead(x,k)}}}
lea_lag(3)(c(1,2)
_
lea_lag(3)(c(1,2))
lead_lag(3)(c(1,2))
lead_lag(1)(c(1,2))
?ifelse
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100,max=100), 4), N, TRUE)#
  )#
#
# colorder (= Stata order)#
DT  %>% colorder(starts_with("v"))#
DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))
library(statar)
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100,max=100), 4), N, TRUE)#
  )#
#
# colorder (= Stata order)#
DT  %>% colorder(starts_with("v"))#
DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
suppressMessages(library("data.table"))#
suppressMessages(library("biglm"))#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT[, condition := id>100]#
system.time(DT[ id >100, coefficients(biglm(v3 ~ v2 + v1, .SD)), .SDcols = c("v1","v2","v3")])#
system.time(DT[, coefficients(biglm(v3 ~ v2 + v1, .SD)), by = "condition", .SDcols = c("v1","v2","v3")])#
system.time(coefficients(biglm(v3 ~ v2 + v1, DT[id>100, c("v1","v2","v3"), with = FALSE])
)
suppressMessages(library("data.table"))#
suppressMessages(library("biglm"))#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT[, condition := id>100]
system.time(DT[, coefficients(biglm(v3 ~ v2 + v1, .SD)), by = condition, .SDcols = c("v1", "v2", "v3")])
library(Matrix)
?expand
isS4(expand)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
?expand
DT <- data.table(#
    id = c(1, 1, 1, 1, 1, 2, 2),#
    date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
    value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% expand(date)
library(dpryr)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
?lag
lag
devtools::install_github("smbache/magrittr")
library(magrittr)
rnorm(100) %T>%#
  plot(type = "l", col = "firebrick") %>%#
  abs %>%#
  sum
tmp :=#
  subset(Species == "setosa") %>%#
  set_names(LETTERS[1:5])
install.packages("colorout")
download.file("http://www.lepem.ufc.br/jaa/colorout_1.0-3.tar.gz", destfile = "colorout_1.0-3.tar.gz")#
install.packages("colorout_1.0-3.tar.gz", type = "source", repos = NULL)
savehistory
savehistory(ok)
savehistory("ok")
savehistory("~/.R.app.history")
savehistory()
fefe
savehistory()
setwd("/Users/Matthieu/Dropbox/Symlink")#
N <- 40e6#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE)                   #
      )
library(data.table)
DT[, value_filled_in := DT[!is.na(value), list(id, date, value)][DT[, list(id, date)], value, roll = TRUE]]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
        value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
DT[, value_filled_in := DT[!is.na(value), list(id, date, value)][DT[, list(id, date)], value, roll = TRUE]]
DT
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_in <- function(.data, ..., roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  fill_in_(.data, .dots = lazyeval::lazy_dots(...) , roll=roll, rollends=rollends)#
}#
#
#' @export#
fill_in_ <- function(.data, ..., .dots , roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  UseMethod("fill_in_")#
}#
#
#' @export#
fill_in_.grouped_dt <- function(.data, ...,.dots, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
   index <- match("order_by",names(dots))#
    if  (!is.na(index)) {#
      order_by <- as.character(dots$order_by$expr)#
      dots[[index]] <- NULL#
    }#
    else{#
      stop("option order_by not precised")#
    }#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  DT1 <- DT[, c(byvars, order_by, var_name), with = FALSE]#
  setkeyv(DT1,c(byvars, order_by))#
  for (t in var_name) {#
    .data[, t := DT1[!is.na(t)][DT1[, c(byvars,order_by), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]]#
    }#
}
DT %>% group_by(id) %>% fill_in(value)
library(dplyr)
DT %>% group_by(id) %>% fill_in(value)
DT %>% group_by(id) %>% fill_in(value, order_by = date)
DT
DT %>% group_by(id) %>% fill_in(value, order_by = date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#
fill_in <- function(.data, ..., roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  fill_in_(.data, .dots = lazyeval::lazy_dots(...) , roll=roll, rollends=rollends)#
}#
#
#' @export#
fill_in_ <- function(.data, ..., .dots , roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  UseMethod("fill_in_")#
}#
#
#' @export#
fill_in_.grouped_dt <- function(.data, ...,.dots, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
   index <- match("order_by",names(dots))#
    if  (!is.na(index)) {#
      order_by <- as.character(dots$order_by$expr)#
      dots[[index]] <- NULL#
    }#
    else{#
      stop("option order_by not precised")#
    }#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  DT1 <- DT[, c(byvars, order_by, var_name), with = FALSE]#
  setkeyv(DT1,c(byvars, order_by))#
  for (t in var_name) {#
    .data[, t := DT1[!is.na(t)][DT1[, c(byvars,order_by), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]]#
    }#
    .data#
}
DT %>% group_by(id) %>% fill_in(value, order_by = date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_in_.grouped_dt <- function(.data, ...,.dots, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
   index <- match("order_by",names(dots))#
    if  (!is.na(index)) {#
      order_by <- as.character(dots$order_by$expr)#
      dots[[index]] <- NULL#
    }#
    else{#
      stop("option order_by not precised")#
    }#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  DT1 <- DT[, c(byvars, order_by, var_name), with = FALSE]#
  setkeyv(DT1,c(byvars, order_by))#
  for (t in var_name) {#
    .data[, t := DT1[!is.na(t)][DT1[, c(byvars,order_by), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE, with = FALSE]]#
    }#
    .data#
}
DT %>% group_by(id) %>% fill_in(value, order_by = date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_in_.grouped_dt <- function(.data, ...,.dots, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
   index <- match("order_by",names(dots))#
    if  (!is.na(index)) {#
      order_by <- as.character(dots$order_by$expr)#
      dots[[index]] <- NULL#
    }#
    else{#
      stop("option order_by not precised")#
    }#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  DT1 <- DT[, c(byvars, order_by, var_name), with = FALSE]#
  setkeyv(DT1,c(byvars, order_by))#
  for (t in var_name) {#
    .data[, t := DT1[!is.na(t)][DT1[, c(byvars,order_by), with=FALSE], c(t), roll = roll, rollends = rollends, allow.cartesian = TRUE, with = FALSE]]#
    }#
    .data#
}
DT %>% group_by(id) %>% fill_in(value, order_by = date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_in_.grouped_dt <- function(.data, ...,.dots, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
   index <- match("order_by",names(dots))#
    if  (!is.na(index)) {#
      order_by <- as.character(dots$order_by$expr)#
      dots[[index]] <- NULL#
    }#
    else{#
      stop("option order_by not precised")#
    }#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  DT1 <- DT[, c(byvars, order_by, var_name), with = FALSE]#
  setkeyv(DT1,c(byvars, order_by))#
  for (t in var_name) {#
    .data[, c(t) := DT1[!is.na(t)][DT1[, c(byvars,order_by), with=FALSE], c(t), roll = roll, rollends = rollends, allow.cartesian = TRUE, with = FALSE]]#
    }#
    .data#
}
DT %>% group_by(id) %>% fill_in(value, order_by = date)
debug(fill_in)
DT %>% group_by(id) %>% fill_in(value, order_by = date)
s
s
s
s
n
DT1
var_name
s
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#
fill_in <- function(.data, ..., roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  fill_in_(.data, .dots = lazyeval::lazy_dots(...) , roll=roll, rollends=rollends)#
}#
#
#' @export#
fill_in_ <- function(.data, ..., .dots , roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  UseMethod("fill_in_")#
}#
#
#' @export#
fill_in_.grouped_dt <- function(.data, ...,.dots, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
   index <- match("order_by",names(dots))#
    if  (!is.na(index)) {#
      order_by <- as.character(dots$order_by$expr)#
      dots[[index]] <- NULL#
    }#
    else{#
      stop("option order_by not precised")#
    }#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  DT1 <- DT[, c(byvars, order_by, var_name), with = FALSE]#
  setkeyv(DT1,c(byvars, order_by))#
  for (t in var_name) {#
    eval(substitute(.data[, t := DT1[!is.na(t)][DT1[, c(byvars,order_by), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(t=as.name(t))))#
    }#
    .data#
}
f
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#
fill_in <- function(.data, ..., roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  fill_in_(.data, .dots = lazyeval::lazy_dots(...) , roll=roll, rollends=rollends)#
}#
#
#' @export#
fill_in_ <- function(.data, ..., .dots , roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  UseMethod("fill_in_")#
}#
#
#' @export#
fill_in_.grouped_dt <- function(.data, ...,.dots, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
   index <- match("order_by",names(dots))#
    if  (!is.na(index)) {#
      order_by <- as.character(dots$order_by$expr)#
      dots[[index]] <- NULL#
    }#
    else{#
      stop("option order_by not precised")#
    }#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  DT1 <- DT[, c(byvars, order_by, var_name), with = FALSE]#
  setkeyv(DT1,c(byvars, order_by))#
  for (t in var_name) {#
    eval(substitute(.data[, t := DT1[!is.na(t)][DT1[, c(byvars,order_by), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(t=as.name(t))))#
    }#
    .data#
}
DT %>% group_by(id) %>% fill_in(value, order_by = date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
# generating data#
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
        value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
# command#
DT[, value_filled_in := DT[!is.na(value), list(id, date, value)][DT[, list(id, date)], value, roll = TRUE]]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#
fill_in <- function(.data, ..., roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  fill_in_(.data, .dots = lazyeval::lazy_dots(...) , roll=roll, rollends=rollends)#
}#
#
#' @export#
fill_in_ <- function(.data, ..., .dots , roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  UseMethod("fill_in_")#
}#
#
#' @export#
fill_in_.grouped_dt <- function(.data, ...,.dots, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
   index <- match("order_by",names(dots))#
    if  (!is.na(index)) {#
      order_by <- as.character(dots$order_by$expr)#
      dots[[index]] <- NULL#
    }#
    else{#
      stop("option order_by not precised")#
    }#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  DT1 <- DT[, c(byvars, order_by, var_name), with = FALSE]#
  setkeyv(DT1,c(byvars, order_by))#
  for (t in var_name) {#
    eval(substitute(.data[, t := DT1[!is.na(t)][DT1[, c(byvars,order_by), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(t=as.name(t))))#
    }#
    .data#
}
DT %>% group_by(id) %>% fill_in(value, order_by = date)
DT
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
        value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_in <- function(.data, ..., roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  fill_in_(.data, .dots = lazyeval::lazy_dots(...) , roll=roll, rollends=rollends)#
}#
#
#' @export#
fill_in_ <- function(.data, ..., .dots , roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  UseMethod("fill_in_")#
}#
#
#' @export#
fill_in_.grouped_dt <- function(.data, ...,.dots, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
   index <- match("order_by",names(dots))#
    if  (!is.na(index)) {#
      order_by <- as.character(dots$order_by$expr)#
      dots[[index]] <- NULL#
    }#
    else{#
      stop("option order_by not precised")#
    }#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  DT1 <- DT[, c(byvars, order_by, var_name), with = FALSE]#
  setkeyv(DT1,c(byvars, order_by))#
  for (t in var_name) {#
    eval(substitute(.data[, t := DT1[!is.na(t)][DT1[, c(byvars,order_by), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(t=as.name(t))))#
    }#
    .data#
}
DT %>% group_by(id) %>% fill_in(value, order_by = date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with = , by, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x=x, along_with= along_with, by=by) #
    setkeyv(DT1,c(by, along_with))#
    DT[!is.na(x)][DT1[, c(by,along_with), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]]#
  }
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x=x, along_with= along_with, by=by) #
    setkeyv(DT1,c(by, along_with))#
    DT[!is.na(x)][DT1[, c(by,along_with), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]]#
  }
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x=x, along_with= along_with, by=by) #
    setkeyv(DT,c(by, along_with))#
    DT[!is.na(x)][DT1[, c(by,along_with), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]]#
  }
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x=x, along_with= along_with, by=by, key= c(by, along_with)) #
    DT[!is.na(x)][DT[, c(by, along_with), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]]#
  }
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x=x, along_with= along_with, by=by, key= c(by, along_with)) #
    DT[!is.na(x)][DT[, c(by, along_with), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]#
  }
DT
DT[, value_filled := fill_na(value, along_with = date, by= id)]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x=x, along_with= along_with, by=by, key= c("by", "along_with")) #
    DT[!is.na(x)][DT[, c(by, along_with), with=FALSE], t, roll = roll, rollends = rollends, allow.cartesian = TRUE]#
  }
DT[, value_filled := fill_na(value, along_with = date, by= id)]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
    DT[!is.na(x)][DT[, c(by, along_with), with=FALSE], x, roll = roll, rollends = rollends, allow.cartesian = TRUE]#
  }
DT[, value_filled := fill_na(value, along_with = date, by= id)]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
    DT[!is.na(x)][DT[, list(by, along_with), with=FALSE], x, roll = roll, rollends = rollends, allow.cartesian = TRUE]#
  }
DT[, value_filled := fill_na(value, along_with = date, by= id)]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
    DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE]#
  }
DT[, value_filled := fill_na(value, along_with = date, by= id)]
DT
DT[, value_filled := fill_na(value, along_with = date)]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
    DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE]#
  }
DT[, value_filled := fill_na(value, along_with = date)]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if by == NULL{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
#
    }#
    else{#
      DT <- data.table(x = x, along_with = along_with, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
  }
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if by == NULL{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }    else{#
      DT <- data.table(x = x, along_with = along_with, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
  }
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if by == NULL{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }    else{#
      DT <- data.table(x = x, along_with = along_with, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, along_with], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if by == NULL{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    } else{#
      DT <- data.table(x = x, along_with = along_with, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if by == NULL{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    } else{#
      DT <- data.table(x = x, along_with = along_with, key = c("along_with")) #
      return(DT[!is.na(x)][DT[, list(along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if (by == NULL){#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    } else{#
      DT <- data.table(x = x, along_with = along_with, key = c("along_with")) #
      return(DT[!is.na(x)][DT[, list(along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
DT[, value_filled := fill_na(value, along_with = date)]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if !is.null(by){#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    } else{#
      DT <- data.table(x = x, along_with = along_with, key = c("along_with")) #
      return(DT[!is.na(x)][DT[, list(along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if (is.null(by)){#
      DT <- data.table(x = x, along_with = along_with, key = c("along_with")) #
      return(DT[!is.na(x)][DT[, list(along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    } else{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
DT[, value_filled := fill_na(value, along_with = date)]
DT[, value_filled := fill_na(value, along_with = date, by = id)]
DT
DT[, value_filled1 := fill_na(value, along_with = date, by = id)]
DT
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if (is.null(by)){#
      DT <- data.table(x = x, along_with = along_with, key = c("along_with")) #
      return(DT[!is.na(x)][DT[, along_with], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    } else{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
DT[, value_filled1 := fill_na(value, along_with = date)]
DT
DT[,list(id)]
DT[, value_filled3 := fill_na(value, along_with = date), by=id]
DT
DT[, value_filled1 := fill_na(value, along_with = date, by = id)]
DT
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if (is.null(by)){#
      DT <- data.table(x = x, along_with = along_with, key = c("along_with")) #
      return(DT[!is.na(x)][DT[, list(along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    } else{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
DT[, value_filled1 := fill_na(value, along_with = date, by = id)]
DT
DT[, value_filled1 := fill_na(value, along_with = date, by = id)]
DT[, value_filled1 := fill_na(value, along_with = date), by = id]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na_matrix <-  function(M , roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
      setkeyv(M,  names(M)[2])) #
      eval(substitute(return(DT[!is.na(x)][DT[, names(M)[2], with = FALSE], x, roll = roll, rollends = rollends, allow.cartesian = TRUE]), list(x=as.name(names(M)[1]))))#
#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na_matrix <-  function(M , roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
      setkeyv(M,  names(M)[2]) #
      eval(substitute(return(DT[!is.na(x)][DT[, names(M)[2], with = FALSE], x, roll = roll, rollends = rollends, allow.cartesian = TRUE]), list(x=as.name(names(M)[1]))))#
#
}
DT[, value_filled1 := fill_na(value, along_with = date), by = id, .SDcols=c(]
DT[, value_filled1 := fill_na_matrix(.SD), by = id, .SDcols=c("value","date")]
fill_na_matrix <-  function(M , roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
      set2keyv(M,  names(M)[2]) #
      eval(substitute(return(DT[!is.na(x)][DT[, names(M)[2], with = FALSE], x, roll = roll, rollends = rollends, allow.cartesian = TRUE]), list(x=as.name(names(M)[1]))))#
#
}
DT[, value_filled1 := fill_na_matrix(.SD), by = id, .SDcols=c("value","date")]
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
        value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    if (is.null(by)){#
      DT <- data.table(x = x, along_with = along_with, key = c("along_with")) #
      return(DT[!is.na(x)][DT[, list(along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    } else{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
x=c(1,4,3)
id <- seq_along(x)
id
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    id <- seq_along(x)#
    if (is.null(by)){#
      DT <- data.table(x = x, along_with = along_with, id=id key = c("along_with")) #
      DT[!is.na(x)][DT[, list(along_with, id)], list(x,id), roll = roll, rollends = rollends, allow.cartesian = TRUE],id)#
      setkey(DT,id)#
      DT[, x]#
#
    } else{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
?data.table
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    id <- seq_along(x)#
    if (is.null(by)){#
      DT <- data.table(x = x, along_with = along_with, id=id, key = c("along_with")) #
      DT[!is.na(x)][DT[, list(along_with, id)], list(x,id), roll = roll, rollends = rollends, allow.cartesian = TRUE],id)#
      setkey(DT,id)#
      DT[, x]#
    } else{#
      DT <- data.table(x = x, along_with = along_with, by = by, key = c("by", "along_with")) #
      return(DT[!is.na(x)][DT[, list(by, along_with)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    id <- seq_along(x)#
    if (is.null(by)){#
      DT <- data.table(x = x, id = id, key = c("id")) #
      return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE],id))#
#
    } else{#
      DT <- data.table(x = x, by = by, key = c("by", "id")) #
      return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    id <- seq_along(x)#
    if (is.null(by)){#
      DT <- data.table(x = x, id = id, key = c("id")) #
      return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
#
    } else{#
      DT <- data.table(x = x, by = by, key = c("by", "id")) #
      return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
}
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    id <- seq_along(x)#
    if (is.null(by)){#
      DT <- data.table(x = x, id = id, key = c("id")) #
      return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
#
    } else{#
      DT <- data.table(x = x, by = by, key = c("by", "id")) #
      return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
  }
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    id <- seq_along(x)#
    if (is.null(by)){#
      DT <- data.table(x = x, id = id, key = c("id")) #
      return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
#
    } else{#
      DT <- data.table(x = x, by = by, key = c("by", "id")) #
      return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
  }
fill_na <-  function(x, along_with  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    id <- seq_along(x)#
    if (is.null(by)){#
      DT <- data.table(x = x, id = id, key = c("id")) #
      return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
#
    } else{#
      DT <- data.table(x = x, by = by, key = c("by", "id")) #
      return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
  }
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
        value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
#
system.time(DT[, filled := zoo::la.nocf(x), by = id])#
DT[, value_filled_in := fill_na(value, by = id)]#
DT[, value_filled_in := fill_na(value), by = id]
system.time(DT[, filled := zoo::na.nocf(x), by = id])
system.time(DT[, filled := zoo::na.locf(x), by = id])
DT
system.time(DT[, filled := zoo::na.locf(value), by = id])
fill_na <-  function(x  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
                 else if (roll>=0) c(FALSE,TRUE)#
                 else c(TRUE,FALSE)){#
        id <- seq_along(x)#
        if (is.null(by)){#
          DT <- data.table("x" = x, "id" = id, key = c("id")) #
          return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        } else{#
          DT <- data.table(x = x, by = by, key = c("by", "id")) #
          return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        }
}
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
        value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
#
system.time(DT[, filled := zoo::na.locf(value, na.rm = TRUE), by = id])#
system.time(DT[, value_filled_in := fill_na(value, by = id)])#
system.time(DT[, value_filled_in := fill_na(value), by = id])
fill_na <-  function(x  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
                 else if (roll>=0) c(FALSE,TRUE)#
                 else c(TRUE,FALSE)){#
        id <- seq_along(x)#
        if (is.null(by)){#
          DT <- data.table("x" = x, "id" = id, key = "id") #
          return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        } else{#
          DT <- data.table(x = x, by = by, key = c("by", "id")) #
          return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        }#
      }
setkey(DT,id, date)#
    DT[, value_filled_in := fill_na(value, by = id)]
fill_na <-  function(x  , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
                 else if (roll>=0) c(FALSE,TRUE)#
                 else c(TRUE,FALSE)){#
        id <- seq_along(x)#
        if (is.null(by)){#
          DT <- data.table("x" = x, "id" = id, key = id) #
          return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        } else{#
          DT <- data.table(x = x, by = by, key = c("by", "id")) #
          return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        }#
      }
setkey(DT,id, date)#
    DT[, value_filled_in := fill_na(value, by = id)]
debug(fill_na)
setkey(DT,id, date)#
    DT[, value_filled_in := fill_na(value, by = id)]
s
n
length(id)
fill_na <-  function(x , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
                 else if (roll>=0) c(FALSE,TRUE)#
                 else c(TRUE,FALSE)){#
        id <- seq_along(x)#
        if (is.null(by)){#
          DT <- data.table("x" = x, "id" = id, key = id) #
          return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        } else{#
          DT <- data.table(x = x, by = by, id = id, key = c("by", "id")) #
          return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        }#
      }
setkey(DT,id, date)#
    DT[, value_filled_in := fill_na(value, by = id)]
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
        value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
#
system.time(DT[, filled1 := zoo::na.locf(value, na.rm = TRUE), by = id])#
system.time(DT[, filled2 := fill_na(value, by = id)])#
system.time(DT[, filled3 := fill_na(value), by = id])
DT
fill_na <-  function(x , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
                 else if (roll>=0) c(FALSE,TRUE)#
                 else c(TRUE,FALSE)){#
        id <- seq_along(x)#
        if (is.null(by)){#
          DT <- data.table("x" = x, "id" = id, key = "id") #
          return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        } else{#
          DT <- data.table(x = x, by = by, id = id, key = c("by", "id")) #
          return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
        }#
      }#
#
And then write#
#
    setkey(DT,id, date)#
    DT[, value_filled_in := fill_na(value, by = id)]#
#
This is not really satisfying since one would like to write#
#
    setkey(DT,id, date)#
    DT[, value_filled_in := fill_na(value), by = id]#
#
However, this takes a huge amount of time to run. And, for the end-user, it is cumbersome to learn that  `fill_na` should be called with the `by` option, and should not be used with `data.table` `by`.   Is there an elegant solution around this? #
#
Some speed test#
#
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
        value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
#
system.time(DT[, filled1 := zoo::na.locf(value, na.rm = TRUE), by = id])#
system.time(DT[, filled2 := fill_na(value, by = id)])#
system.time(DT[, filled3 := fill_na(value), by = id])
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
        value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
#
system.time(DT[, filled1 := zoo::na.locf(value, na.rm = TRUE), by = id])#
system.time(DT[, filled2 := fill_na(value, by = id)])#
system.time(DT[, filled3 := fill_na(value), by = id])
system.time(DT[, filled0 := DT[!is.na(value), list(id, date, value)][DT[, list(id, date)], value, roll = TRUE]])
DT
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
#
system.time(DT[, filled0 := DT[!is.na(value), list(id, date, value)][DT[, list(id, date)], value, roll = TRUE]])#
#> user  system elapsed #
#>  0.086   0.006   0.105 #
system.time(DT[, filled1 := zoo::na.locf(value, na.rm = TRUE), by = id])#
#>    user  system elapsed #
#> 18.529   0.067  18.508 #
system.time(DT[, filled2 := fill_na(value, by = id)])#
#>   user  system elapsed #
#>  0.194   0.019   0.221
DT
fill_na <-  function(x , by = NULL, roll =TRUE , rollends= if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)){#
    id <- seq_along(x)#
    if (is.null(by)){#
      DT <- data.table("x" = x, "id" = id, key = "id") #
      return(DT[!is.na(x)][DT[, list(id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
#
    } else{#
      DT <- data.table("x" = x, "by" = by, "id" = id, key = c("by", "id")) #
      return(DT[!is.na(x)][DT[, list(by, id)], x, roll = roll, rollends = rollends, allow.cartesian = TRUE])#
    }#
  }
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)
system.time(DT[, filled0 := DT[!is.na(value), list(id, date, value)][DT[, list(id, date)], value, roll = TRUE]])#
#> user  system elapsed #
#>  0.086   0.006   0.105
system.time(DT[, filled2 := fill_na(value, by = id)])#
#>   user  system elapsed #
#>  0.194   0.019   0.221
DT
zoo::na.locf
?zoo::na.locf
system.time(DT[, filled1 := zoo::na.locf.default(value, na.rm = TRUE), by = id])#
#>    user  system elapsed #
#> 18.529   0.067  18.508
DT
warnings()
system.time(DT[, filled1 := zoo::na.locf.default(value, na.rm = FALSE), by = id])#
#>    user  system elapsed #
#> 18.529   0.067  18.508
DT
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
#
system.time(DT[, filled0 := DT[!is.na(value), list(id, date, value)][DT[, list(id, date)], value, roll = TRUE]])#
#> user  system elapsed #
#>  0.086   0.006   0.105 #
system.time(DT[, filled1 := zoo::na.locf.default(value, na.rm = FALSE), by = id])#
#> user  system elapsed #
#> 5.235   0.016   5.274 #
system.time(DT[, filled2 := fill_na(value, by = id)])#
#>   user  system elapsed #
#>  0.194   0.019   0.221 #
system.time(DT[, filled3 := fill_na(value), by = id])#
#>    user  system elapsed #
#> 237.256   0.913 238.405
DT
all.equal(DT$filled0, DT$filled1)
all.equal(DT$filled1, DT$filled2)
all.equal(DT$filled1, DT$filled3)
N <- 100#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
#
system.time(DT[, filled0 := DT[!is.na(value), list(id, date, value)][DT[, list(id, date)], value, roll = TRUE]])#
#> user  system elapsed #
#>  0.086   0.006   0.105 #
system.time(DT[, filled1 := zoo::na.locf.default(value, na.rm = FALSE), by = id])#
#> user  system elapsed #
#> 5.235   0.016   5.274 #
# (lower speed and no built in option like roll=integer or roll=nearest, rollend, etc)#
system.time(DT[, filled2 := fill_na(value, by = id)])#
#>   user  system elapsed #
#>  0.194   0.019   0.221 #
system.time(DT[, filled3 := fill_na(value), by = id])#
#>    user  system elapsed #
#> 237.256   0.913 238.405
all.equal(DT$filled1, DT$filled3)
na.locf.default
?na.locf.default
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)#
#
system.time(DT[, filled0 := DT[!is.na(value), list(id, date, value)][DT[, list(id, date)], value, roll = TRUE]])#
#> user  system elapsed #
#>  0.086   0.006   0.105 #
system.time(DT[, filled1 := zoo::na.locf.default(value, na.rm = FALSE), by = id])#
#> user  system elapsed #
#> 5.235   0.016   5.274 #
# (lower speed and no built in option like roll=integer or roll=nearest, rollend, etc)#
system.time(DT[, filled2 := fill_na(value, by = id)])#
#>   user  system elapsed #
#>  0.194   0.019   0.221 #
system.time(DT[, filled3 := fill_na(value), by = id])#
#>    user  system elapsed #
#> 237.256   0.913 238.405
system.time(DT[, filled1 := na.locf.default(value, na.rm = FALSE), by = id])
library(zoo)
system.time(DT[, filled1 := na.locf.default(value, na.rm = FALSE), by = id])
system.time(DT[, filled1 := na.locf.default(value, na.rm = FALSE), by = id])
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
set_na <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  keys <- key(.data)       #
  for col in cols{#
    eval(substitute(.data[, (col) := DT[!is.na(x), c(keys, col), with = FALSE ][DT[, c(keys, col), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
set_na <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)       #
  for col in cols{#
    eval(substitute(.data[, (col) := DT[!is.na(x), c(keys, col), with = FALSE ][DT[, c(keys, col), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
set_na <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)       #
  for (col in cols){#
    eval(substitute(.data[, (col) := DT[!is.na(x), c(keys, col), with = FALSE ][DT[, c(keys, col), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )
setkey(DT, id, date)
setna(DT, value)_
setna(DT, value)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)       #
  for (col in cols){#
    eval(substitute(.data[, (col) := DT[!is.na(x), c(keys, col), with = FALSE ][DT[, c(keys, col), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setna(DT, value)
setna(DT, "value")
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)       #
  for (col in cols){#
    eval(substitute(.data[, (col) := DT[!is.na(x), c(keys, col), with = FALSE ][DT[, c(keys, col), with = FALSE], value, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(x = as.name(col))))#
  }#
}
setna(DT, "value")
DT
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)       #
  for (col in cols){#
    eval(substitute(.data[, (col) := DT[!is.na(x), c(keys, col), with = FALSE ][DT[, c(keys), with = FALSE], value, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(x = as.name(col))))#
  }#
}
setna(DT, "value")
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)       #
  for (col in cols){#
    eval(substitute(.data[, (col) := DT[!is.na(x), c(keys, col), with = FALSE ][DT[, c(keys), with = FALSE], value, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(x = as.name(col))))#
  }#
}
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )
setkey(DT,id,date)
setna(DT, "value")
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)    #
  if (length(keys))<2{#
    stop(".data must be keyed by at least two variable, id and date")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(x = as.name(col))))#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)    #
  if (length(keys))<2){#
    stop(".data must be keyed by at least two variable, id and date")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(x = as.name(col))))#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)    #
  if (length(keys)<2){#
    stop(".data must be keyed by at least two variable, id and date")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends, allow.cartesian = TRUE]], list(x = as.name(col))))#
  }#
}
setna(DT, "value")
DT
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)
setna <- function(.data, cols,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)    #
  if (length(keys)<2){#
    stop(".data must be keyed by at least two variable, id and date")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setna(DT,"value")
DT[!is.na(x), c(keys, col), with = FALSE ]
DT[!is.na(x), c("id","date", "value"), with = FALSE ]
DT[!is.na(x), c("id","date", "value"), with = FALSE ][DT[, c("id","date"), with = FALSE]
]
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)#
DT<- unique(DT)
setna(DT,"value")
DT
#' DT <- data.table(#
#'  id    = c(1, 1, 1, 1, 1, 2, 2),#
#'  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
#'  value = c(4.1, NA, MA, 5.3, 3.0, 3.2, 5.2)#
#' )#
#' setkey(DT, id, date)#
#' setna(DT, "value", roll = TRUE)
?data.table
devtools::document(setna)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
?setcolorder
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
	setna_(setna, .dots = lazyeval::lazy_dots(...), roll = TRUE, rollends = rollends)#
}#
setna_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  dots <- lazyeval::all_dots(.dots, ...)#
  cols <- names(select_vars_(names(.data), dots))#
  keys <- key(.data)    #
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
N <- 2e6#
set.seed(1)#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE),#
       value2 = sample(c(NA,1:5), N, TRUE)                   #
      )#
setkey(DT,id,date)
DT<- unique(DT)
setna(DT,value)
debug(setna)
setna(DT,value)
s
n
debug(setna)
setna(DT,value)
s
n
dots
cols
setna(DT,value)
s
n
dots
dots$value
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' fill NA based on non missing observations#
#'#
#' @param .data a data.table #
#' @param cols a character vector of variable names to fill-in#
#' @param roll When roll is a positive number, this limits how far values are carried forward. roll=TRUE is equivalent to roll=+Inf. When roll is a negative number, values are rolled backwards; i.e., next observation carried backwards (NOCB). Use -Inf for unlimited roll back. When roll is "nearest", the nearest value is joined to.#
#' @param rollend  A logical vector length 2 (a single logical is recycled). When rolling forward (e.g. roll=TRUE) if a value is past the last observation within each group defined by the join columns, rollends[2]=TRUE will roll the last value forwards. rollends[1]=TRUE will roll the first value backwards if the value is before it. If rollends=FALSE the value of i must fall in a gap in x but not after the end or before the beginning of the data, for that group defined by all but the last join column. When roll is a finite number, that limit is also applied when rolling the end#
#' @examples#
#' DT <- data.table(#
#'  id    = c(1, 1, 1, 1, 1, 2, 2),#
#'  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
#'  value = c(4.1, NA, MA, 5.3, 3.0, 3.2, 5.2)#
#' )#
#' setkey(DT, id, date)#
#' setna(DT, "value", roll = TRUE)#
#' @name setna#
NULL#
setna <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
	setna_(setna, .dots = lazy_dots(...), roll = TRUE, rollends = rollends)#
}#
setna_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  if (length(vars) == 0) {#
     vars <- lazy_dots(everything())#
  }#
  keys <- key(.data)    #
  vars <- select_vars_(tbl_vars(.data), vars, exclude = keys)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- select_vars_(tbl_vars(.data), vars, exclude = as.character(groups(.data)))#
  keys <- key(.data)    #
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setna(DT,value)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
	setna_(setna, .dots = lazy_dots(...), roll = TRUE, rollends = rollends)#
}#
setna_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  	keys <- key(.data)    #
	dots <- lazyeval::all_dots(.dots, ...)#
	vars <- names(select_vars_(names(.data), dots, exclude = keys)#
	if (length(vars) == 0) {#
	vars <- lazy_dots(everything())#
	}#
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
	setna_(setna, .dots = lazy_dots(...), roll = TRUE, rollends = rollends)#
}#
setna_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  	keys <- key(.data)    #
	dots <- lazyeval::all_dots(.dots, ...)#
	vars <- names(select_vars_(names(.data), dots, exclude = keys))#
	if (length(vars) == 0) {#
	vars <- lazy_dots(everything())#
	}#
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setna(DT,value)
library(lazyeval)
setna(DT,value)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
	setna_(setna, .dots = lazy_dots(...), roll = TRUE, rollends = rollends)#
}#
setna_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  	keys <- key(.data)    #
	dots <- all_dots(.dots, ...)#
	vars <- select_vars_(names(.data), dots, exclude = keys))#
	if (length(vars) == 0) {#
	vars <- lazy_dots(everything())#
	}#
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#
setna <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
	setna_(setna, .dots = lazy_dots(...), roll = TRUE, rollends = rollends)#
}#
setna_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  	keys <- key(.data)    #
	dots <- all_dots(.dots, ...)#
	vars <- select_vars_(names(.data), dots, exclude = keys)#
	if (length(vars) == 0) {#
	vars <- lazy_dots(everything())#
	}#
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' fill NA based on non missing observations#
#'#
#' @param .data a data.table #
#' @param cols a character vector of variable names to fill-in#
#' @param roll When roll is a positive number, this limits how far values are carried forward. roll=TRUE is equivalent to roll=+Inf. When roll is a negative number, values are rolled backwards; i.e., next observation carried backwards (NOCB). Use -Inf for unlimited roll back. When roll is "nearest", the nearest value is joined to.#
#' @param rollend  A logical vector length 2 (a single logical is recycled). When rolling forward (e.g. roll=TRUE) if a value is past the last observation within each group defined by the join columns, rollends[2]=TRUE will roll the last value forwards. rollends[1]=TRUE will roll the first value backwards if the value is before it. If rollends=FALSE the value of i must fall in a gap in x but not after the end or before the beginning of the data, for that group defined by all but the last join column. When roll is a finite number, that limit is also applied when rolling the end#
#' @examples#
#' DT <- data.table(#
#'  id    = c(1, 1, 1, 1, 1, 2, 2),#
#'  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
#'  value = c(4.1, NA, MA, 5.3, 3.0, 3.2, 5.2)#
#' )#
#' setkey(DT, id, date)#
#' setna(DT, "value", roll = TRUE)#
#' @name setna#
NULL#
setna <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
	setna_(setna, .dots = lazy_dots(...), roll = TRUE, rollends = rollends)#
}#
setna_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  	keys <- key(.data)    #
	dots <- all_dots(.dots, ...)#
	vars <- names(select_vars_(names(.data), dots, exclude = keys))#
	if (length(vars) == 0) {#
	vars <- lazy_dots(everything())#
	}#
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
debug(setna)
setna(DT,value)
s
n
dots
select_vars_(names(.data), dots)
DT
setna(DT,value)
s
n
names(dots)
dots
DT %>% select(value)
debug(select)
DT %>% select(value)
s
n
dots
select_vars_(names(.data), dots)
dots$value
select_vars_(names(.data), dots, exclude = key(.data))
names(select_vars_(names(.data), dots, exclude = key(.data)))
setna(DT,value)
s
n
dplyr::select_vars_(names(.data), dots, exclude = keys)
dots
names(.data)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' fill NA based on non missing observations#
#'#
#' @param .data a data.table #
#' @param cols a character vector of variable names to fill-in#
#' @param roll When roll is a positive number, this limits how far values are carried forward. roll=TRUE is equivalent to roll=+Inf. When roll is a negative number, values are rolled backwards; i.e., next observation carried backwards (NOCB). Use -Inf for unlimited roll back. When roll is "nearest", the nearest value is joined to.#
#' @param rollend  A logical vector length 2 (a single logical is recycled). When rolling forward (e.g. roll=TRUE) if a value is past the last observation within each group defined by the join columns, rollends[2]=TRUE will roll the last value forwards. rollends[1]=TRUE will roll the first value backwards if the value is before it. If rollends=FALSE the value of i must fall in a gap in x but not after the end or before the beginning of the data, for that group defined by all but the last join column. When roll is a finite number, that limit is also applied when rolling the end#
#' @examples#
#' DT <- data.table(#
#'  id    = c(1, 1, 1, 1, 1, 2, 2),#
#'  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
#'  value = c(4.1, NA, MA, 5.3, 3.0, 3.2, 5.2)#
#' )#
#' setkey(DT, id, date)#
#' setna(DT, "value", roll = TRUE)#
#' @name setna#
NULL#
setna <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
	setna_(.data, .dots = lazy_dots(...), roll = TRUE, rollends = rollends)#
}#
setna_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  	keys <- key(.data)    #
	dots <- all_dots(.dots, ...)#
	vars <- names(select_vars_(names(.data), dots, exclude = keys))#
	if (length(vars) == 0) {#
	vars <- lazy_dots(everything())#
	}#
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setna(DT,value)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#
setna <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
	setna_(.data, .dots = lazy_dots(...), roll = TRUE, rollends = rollends)#
}#
setna_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  	keys <- key(.data)    #
	dots <- all_dots(.dots, ...)#
	vars <- names(select_vars_(names(.data), dots, exclude = keys))#
	if (length(vars) == 0) {#
	vars <- lazy_dots(everything())#
	}#
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in vars){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
setna(DT,value)
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, MA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
DT %>% fill_na(value, roll = 3)#
DT %>% fill_na(value, roll = -Inf, inplace = TRUE)
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
DT %>% fill_na(value, roll = 3)#
DT %>% fill_na(value, roll = -Inf, inplace = TRUE)
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
DT %>% fill_na(value, roll = 3)#
DT %>% fill_na(value, roll = -Inf, inplace = TRUE)
DT
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
DT %>% fill_na(value, roll = 3)#
DT %>% fill_na(value, roll = -Inf, inplace = TRUE)
debug(fill_na)
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
DT %>% fill_na(value, roll = 3)#
DT %>% fill_na(value, roll = -Inf, inplace = TRUE)
f
DT %>% fill_na(value, roll = 3)
f
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
fill_na <- function(.data, ...,roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE), inplace = FALSE){#
	fill_na_(.data, .dots = lazy_dots(...), roll = TRUE, rollends = rollends, inplace = inplace)#
}#
fill_na_ <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE), inplace = FALSE){#
  keys <- key(.data)    #
	dots <- all_dots(.dots, ...)#
	vars <- names(select_vars_(names(.data), dots, exclude = keys))#
	if (length(vars) == 0) {#
	vars <- lazy_dots(everything())#
	}#
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }  #
  if (!inplace) .data <- copy(.data) #
  for (col in vars){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
DT %>% fill_na(value, roll = 3)
DT
DT %>% fill_na(value, roll = 3, inplace = TRUE)
DT
DT <- data.table(#
    id = c(1, 1, 1, 1, 1, 2, 2),#
    date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
    value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% expand(date)
unique
data.table::unique
unique.data.table
library(data.table)
unique.data.table
unique
DT
DT $>$ select(list(id,date))
DT %>% select(list(id,date))
DT %>% select(list(id))
DT %>% select(.(id,date))
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
setna("value", roll = 3)
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
setna(DT,"value", roll = 3)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)    #
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in vars){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
setna(DT,"value", roll = 3)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
setna <- function(.data, ...,.dots, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)    #
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
setna(DT,"value", roll = 3)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' fill NA based on non missing observations#
#'#
#' @param .data a data.table #
#' @param cols a character vector of variable names to fill-in#
#' @param roll When roll is a positive number, this limits how far values are carried forward. roll=TRUE is equivalent to roll=+Inf. When roll is a negative number, values are rolled backwards; i.e., next observation carried backwards (NOCB). Use -Inf for unlimited roll back. When roll is "nearest", the nearest value is joined to.#
#' @param rollend  A logical vector length 2 (a single logical is recycled). When rolling forward (e.g. roll=TRUE) if a value is past the last observation within each group defined by the join columns, rollends[2]=TRUE will roll the last value forwards. rollends[1]=TRUE will roll the first value backwards if the value is before it. If rollends=FALSE the value of i must fall in a gap in x but not after the end or before the beginning of the data, for that group defined by all but the last join column. When roll is a finite number, that limit is also applied when rolling the end#
#' @examples#
#' DT <- data.table(#
#'  id    = c(1, 1, 1, 1, 1, 2, 2),#
#'  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
#'  value = c(4.1, NA, MA, 5.3, 3.0, 3.2, 5.2)#
#' )#
#' setkey(DT, id, date)#
#' setna(DT, value, roll = TRUE)#
#' @name setna#
NULL#
setna <- function(.data, cols, roll = TRUE ,  rollends = if (roll=="nearest") c(TRUE,TRUE)#
  else if (roll>=0) c(FALSE,TRUE)#
  else c(TRUE,FALSE)){#
  keys <- key(.data)    #
  if (length(keys)<1){#
    stop(".data must be keyed by at least one variable")#
  }   #
  for (col in cols){#
    eval(substitute(.data[, (col) := .data[!is.na(x), c(keys, col), with = FALSE ][.data[, c(keys), with = FALSE], value, roll = roll, rollends = rollends]], list(x = as.name(col))))#
  }#
}
DT <- data.table(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(4.1, NA, NA, 5.3, 3.0, 3.2, 5.2)#
 )#
setkey(DT, id, date) #
setna(DT,"value", roll = 3)
DT
