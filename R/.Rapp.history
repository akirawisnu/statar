DT[,V1:=1]
setkey(DT)
setkey(DT,V1)
DT[,list(id,V1)]
DT[,list(mean(id),V1)]
DT[,list(mean(V1))]
DT[,list(mean(v2))]
DT[,list(mean(v2)),by=V1]
DT[,list(v2),by=V1]
DT[,list(V1=mean(v2)),by=V1]
DT[,list(mean(v2)),by=V1]
setkey(DT,id)
DT
DT[J(id,v2)]
DT[J(id,v2),allow.cartesian=T]
require(devtools)#
install_github("Rdatatable/data.table")
require(devtools)#
install_github("Rdatatable/data.table", build_vignettes=FALSE)
install_github("hadley/dplyr")
library(data.table)
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
DT1 <- copy(DT)
library(pryr)
object_size(DT,DT1)
object_size(DT)
sessionInfo()
library(data.table)
library(dplyr)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
DT1 <- DT %>% mutate(y=mean(v1))
object_size(DT,DT1)
library(pryr)
object_size(DT,DT1)
library(data.table)
data.table:::shallow
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
data.table:::shallow(DT)
DT1<-data.table:::shallow(DT)
DT1[,y:=mean(v1)]
copy(DT,DT1)
library(pryr)
copy(DT,DT1)
object_size(DT,DT1)
DT
DT1
set(DT,id)
setkey(DT,id)
setkey(DT1,id)
Y <- DT[DT1]
object_size(DT,DT1,Y)
DT
DT %>% select(v1) %>% mutate_each(funs(mean),inplace=T)
library(dplyr)
library(data.table)#
x <- data.table(a = 11:15, b = 111:115, val1 = rnorm(5), key = c("a", "b"))#
y <- data.table(b = 101:120, val2 = letters[1:20], key = "b")
x
y
N=1e4; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
)
N=1e4; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE)                         # int in range [1,5]#
)
setkey(DT,id)
DT[J(id,v1)]
DT1 <- DT[,list(id,v1)]
DT[DT1]
names(DT[J(id,v1)])
names(DT[DT1])
setkey(DT,id)#
names(DT[DT[,list(id,v1)]])
names(DT[list(id,v1)])
library(data.table)
library(dplyr)
N=1e8; K=100#
set.seed(1)#
DF <- data.frame(#
  id = 1:N,#
  v1 =  sample(round(runif(100,max=100),4), N, TRUE)                       #
)
rm(DF)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
DT1 <- DT[,names(DT),with=FALSE]
copy(DT,DT1)
library(pryr)
object_size(DT,DT1)
DT1 <-DT[5*1e7]
DT1 <-DT[1:(5*1e7)]
object_size(DT,DT1)
object_size(DT)
object_size(DT,DT1)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
library(data.table)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
   id = 1:N,#
   v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
system.time(DT1 <- DT[,c("id","v1")])
object_size(DT,DT1)
system.time(DT1 <- DT[,c("id","v1")])
object_size(DT,DT1)
library(plyr)
system.time(DT1 <- DT[,c("id","v1")])
object_size(DT,DT1)
library(pryr)
object_size(DT,DT1)
object_size(DT)
object_size(DT,DT1)
system.time(DT1 <- DT[,c("id")])
object_size(DT,DT1)
object_size(DT)
system.time(DT1 <- DT[,c("id","v1")])
object_size(DT,DT1)
DT
DT1
system.time(DT1 <- DT[,c("id","v1"),with=FALSE])
object_size(DT, DT1)
system.time(DT1 <- setDT(setDF(DT)[,c("id","v1")]))
object_size(DT, DT1)
library(dplyr)#
library(data.table)
DT1 <- DT %>% mutate(y=mean(v1))
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
DT1 <- DT %>% mutate(y=mean(v1))
object_size(DT,DT1)
library(pryr)
object_size(DT,DT1)
DT1 <- DT %>% select(v1)
object_size(DT,DT1)
DF1 <- DF %>% select(v1)#
object_size(DF,DF1)
library(pryr)
library(dplyr)#
library(data.table)#
#
N=1e8; K=100#
set.seed(1)#
DF <- data.frame(#
  id = 1:N,#
  v1 =  sample(round(runif(100,max=100),4), N, TRUE)                       #
)#
object_size(DF)#
1.2 GB#
DF1 <- DF %>% mutate(y=mean(v1))#
object_size(DF,DF1)#
2 GB#
DF1 <- DF %>% select(v1)#
object_size(DF,DF1)#
2 GB
names(DF1)
rm(ls())
rm(list=ls())
N=1e8; K=100#
set.seed(1)#
DF <- data.frame(#
  id = 1:N,#
  v1 =  sample(round(runif(100,max=100),4), N, TRUE)                       #
)#
object_size(DF)
DF1 <- DF %>% select(v1)
object_size(DF,DF1)
DT1<-DT[,list(id)]
setDT(DT)
setDT(DF)
DF1<-DT[,list(id)]
DF1<-DF[,list(id)]
object_size(DF,DF1)
object_size(DF)
library(data.table)
df1 <- data.frame(id = 1:10)#
f <- function(df){eval(substitute(setDT(df)),parent.frame())}#
f(df1)#
df1[, temp := 1]
df1
df <- data.frame(id = 1:10)#
f <- function(df){eval(substitute(setDT(df)),parent.frame())}#
f(df)#
df[, temp := 1]
df
df <- data.frame(id = 1:10)#
f <- function(df){eval(substitute(setDT(df)),parent.frame()); df[, temp := 1]}
f(df)
df
df1 <- data.frame(id = 1:10)#
f <- function(df){eval(substitute(setDT(df)),parent.frame()); df[, temp := 1]}
f(df1)
df1
df1 <- data.frame(id = 1:10)#
f <- function(df){#
      eval(substitute(setDT(df)),parent.frame())#
      df[, temp := 1]#
      }#
f(df1)
df1
library(dplyr)#
library(data.table)#
as.data.table(mtcars) %>% mutate(mean(1))#
mtcars %>% mutate(mean(1))
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
system.time( DT1 <- DT[,c("id","v1","v2"), with = FALSE] )#
object_size(DT,DT1)#
system.time( DT1 <- setDT(setDF(DT)[,c("id","v1","v2")]) ) #
system.time( setDT(DT)  )#
object_size(DT,DT1)
library(data.table)#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
system.time( DT1 <- DT[,c("id","v1","v2"), with = FALSE] )#
object_size(DT,DT1)#
system.time( DT1 <- setDT(setDF(DT)[,c("id","v1","v2")]) ) #
system.time( setDT(DT)  )#
object_size(DT,DT1)
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
system.time( DT1 <- DT[,c("id","v1","v2"), with = FALSE] )#
object_size(DT,DT1)#
system.time( DT1 <- setDT(setDF(DT)[,c("id","v1","v2")]) ) #
system.time( setDT(DT)  )#
object_size(DT,DT1)
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
object_size(DT[1:(.N-1)])
object_size(DT[1:(.N-1)],DT)
object_size(DT[1:.N/2],DT)
object_size(DT)
DT1 <- DT[1:.N/2]
object_size(DT,DT1)
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT1 <- DT[,c("id","v1","v2"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.N/2]#
object_size(DT,DT1)#
400 MB
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.N/2]#
object_size(DT,DT1)
DF1 <- DF[1:1e7/2]
setDF(DT)#
DT1 <- DT[,c("id","v1","v2")]) #
DT1 <- DT[1:1e7/2]
setDF(DT)#
DT1 <- DT[,c("id","v1","v2")]#
DT1 <- DT[1:1e7/2]
DT1 <- DT[1:(1e7/2)]
DT1 <- DT[1:(5e6)]
DT1 <- DT[1:(5e6),]
object_size(DT,DT1)
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
DT1 <- DT[,c("id","v1","v2")]#
object_size(DT,DT1)#
DT1 <- DT[1:(5e6),]#
object_size(DT,DT1)#
#
setDT(DT)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
DT1 <- DT[,c("id","v1","v2")]#
object_size(DT,DT1)#
#> 200#
DT1 <- DT[1:(5e6),]#
object_size(DT,DT1)#
#> 300#
#
setDT(DT)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
#> 400 MB#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)#
#> 210 MB
DT1 <- DT[1:.5e6,]
object_size(DT,DT1)#
210 MB
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
DT1 <- DT[,c("id","v1","v2")]#
object_size(DT,DT1)#
#> 200 MB#
DT1 <- DT[1:(5e6),]#
object_size(DT,DT1)#
#> 300 MB#
#
setDT(DT)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
#> 400 MB#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)#
#> 210 MB
DT1
DT1 <- DT[,list(id,v1,v2,v3)] #
object_size(DT,DT1)
library(dplyr)
library(data.table)#
library(pryr)#
N = 1e7; K = 100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT1 <- DT %>% filter(v1>=3)
object_size(DT,DT1)
object_size(DT)
DT[v1==3,lm(v3~v2,.SD),.SDcols=names(DT)]
setDT(DT)
DT[v1==3,lm(v3~v2,.SD),.SDcols=names(DT)]
system.time(DT[v1==3,lm(v3~v2,.SD),.SDcols=names(DT)])
system.time(lm(v3~v2,DT[v1==3]))
system.time(DT[v1==3,lm(v3~v2,.SD),.SDcols=names(DT)])
library(data.table)#
library(pryr)#
N = 1e7; K = 100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
DT1 <- DT[1:(5e6),]#
object_size(DT, DT1)#
#> 300 MB#
#
setDT(DT)#
DT1 <- DT[1:.5e6]#
object_size(DT ,DT1)#
#> 210 MB
DT1 <- DT[3:.5e6]
object_size(DT,DT1)
library(dplyr)
?order_by
?lag
?lead
?break
break=function(x){x+2}
break <- function(x){x+2}
?separate
?culster
?cluster
devtools::document("/Users/Matthieu/Dropbox/github/statar-package")
#' lead and lag.#
#'#
#' lead and lag are useful for comparing values for date offset by a constant#
#' @param x a vector of values#
#' @param n a positive integer of length 1, giving the number of positions to lead or lag by#
#' @param order_by override the default ordering to use another vector#
#' @param along_with  compute lag with respect to this vector instead of previous row#
#' @param units computes lag in units of "day", "week", "month", "quarter" or "year" periods. Should be used when \code{along_with} is a date. #
#' @param default value used for non-existant rows. Defaults to \code{NA}.#
#' @examples#
#' # Unbalanced panel#
#' DT <- data.table(#
#'  id    = c(1, 1, 1, 1, 1, 2, 2),#
#'  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#' )#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, order_by = date)) # wrong#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, along_with = date)) # right#
#
#' # Units#
#' DT[, date := as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "08/21/1992"), "%m/%d/%Y")]#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, units = "month", along_with = date)) #
#' @name lead-lag#
NULL#
#
#' @export#
#' @rdname lead-lag#
lead <- function(x, n = 1L, order_by, along_with, units = NULL, default = NA, ...) {#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
#
  if (!is.null(order_by)) {#
       if (!is.null(along_with) | !is.null(units)) stop("order_by cannot be used with along_with or units")#
       return(dplyr::with_order(order_by, lead, x, n = n, default = default))#
  }#
  if (!is.null(units)) {#
    if (is.null(along_with)) stop("units cannot be used without along_with")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    along_with_origin <- as.along_with('0001-01-01')#
    if (unitsc=="day"){#
      return(lead(x = x, n = n, default = default, along_with = along))#
    }#
    if (unitsc == "week"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% weeks(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }  #
    else if (unitsc == "month"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% months(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "quarter"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% 3*months(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "year"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% years(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }#
  }#
#
  if (!is.null(along_with)) {#
    index <- match(along_with - n, along_with, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
  } else{#
    xlen <- length(x)#
    n <- pmin(n, xlen)#
    out <- c(x[-seq_len(n)], rep(default, n))#
  }#
  attributes(out) <- attributes(x)#
  out#
}#
#' @export#
#' @rdname lead-lag#
lag.default <- function(x, n = 1L, order_by, along_with, units = NULL, default = NA, ...) {#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
#
  if (!is.null(order_by)) {#
       if (!is.null(along_with) | !is.null(units)) stop("order_by cannot be used with along_with or units")#
       return(dplyr::with_order(order_by, lag, x, n = n, default = default))#
  }#
  if (!is.null(units)) {#
    if (is.null(along_with)) stop("units cannot be used without along_with")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    along_with_origin <- as.along_with('0001-01-01')#
    if (unitsc=="day"){#
      return(lag(x = x, n = n, default = default, along_with = along))#
    }#
    if (unitsc == "week"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% weeks(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }  #
    else if (unitsc == "month"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% months(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "quarter"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% 3*months(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "year"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% years(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }#
  }#
  if (!is.null(along_with)) {#
    index <- match(along_with + n, along_with, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
  } else{#
    xlen <- length(x)#
    n <- pmin(n, xlen)#
    out <- c(rep(default, n), x[seq_len(xlen - n)])#
  }#
  attributes(out) <- attributes(x)#
  out#
}
date <- as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "08/21/1992"), "%m/%d/%Y")
date
as.Date(c("03/01/1992", "04/03/1992", "07/15/1992", "08/21/1992"), "%m/%d/%Y")
#' lead and lag.#
#'#
#' lead and lag are useful for comparing values for date offset by a constant#
#' @param x a vector of values#
#' @param n a positive integer of length 1, giving the number of positions to lead or lag by#
#' @param order_by override the default ordering to use another vector#
#' @param along_with  compute lag with respect to this vector instead of previous row#
#' @param units computes lag in units of "day", "week", "month", "quarter" or "year" periods. Should be used when \code{along_with} is a date. #
#' @param default value used for non-existant rows. Defaults to \code{NA}.#
#' @examples#
#' # along_with#
#' DT <- data.table(#
#'  id    = c(1, 1, 1, 1, 1, 2, 2),#
#'  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#' )#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, order_by = date)) # wrong#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, along_with = date)) # right#
#
#' # units#
#' value <- c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#' date <- as.Date(c("03/01/1992", "04/03/1992", "07/15/1992", "08/21/1992"), "%m/%d/%Y")#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, along_with = date, units = "month")) #
#' @name lead-lag#
NULL#
#
#' @export#
#' @rdname lead-lag#
lead <- function(x, n = 1L, order_by, along_with, units = NULL, default = NA, ...) {#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
#
  if (!is.null(order_by)) {#
       if (!is.null(along_with) | !is.null(units)) stop("order_by cannot be used with along_with or units")#
       return(dplyr::with_order(order_by, lead, x, n = n, default = default))#
  }#
  if (!is.null(units)) {#
    if (is.null(along_with)) stop("units cannot be used without along_with")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    along_with_origin <- as.along_with("0001-01-01")#
    if (unitsc=="day"){#
      return(lead(x = x, n = n, default = default, along_with = along))#
    }#
    if (unitsc == "week"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% weeks(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }  #
    else if (unitsc == "month"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% months(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "quarter"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% 3*months(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "year"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% years(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }#
  }#
#
  if (!is.null(along_with)) {#
    index <- match(along_with - n, along_with, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
  } else{#
    xlen <- length(x)#
    n <- pmin(n, xlen)#
    out <- c(x[-seq_len(n)], rep(default, n))#
  }#
  attributes(out) <- attributes(x)#
  out#
}#
#' @export#
#' @rdname lead-lag#
lag.default <- function(x, n = 1L, order_by, along_with, units = NULL, default = NA, ...) {#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
#
  if (!is.null(order_by)) {#
       if (!is.null(along_with) | !is.null(units)) stop("order_by cannot be used with along_with or units")#
       return(dplyr::with_order(order_by, lag, x, n = n, default = default))#
  }#
  if (!is.null(units)) {#
    if (is.null(along_with)) stop("units cannot be used without along_with")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    along_with_origin <- as.along_with("0001-01-01")#
    if (unitsc=="day"){#
      return(lag(x = x, n = n, default = default, along_with = along))#
    }#
    if (unitsc == "week"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% weeks(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }  #
    else if (unitsc == "month"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% months(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "quarter"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% 3*months(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "year"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% years(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }#
  }#
#
  if (!is.null(along_with)) {#
    index <- match(along_with + n, along_with, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
  } else{#
    xlen <- length(x)#
    n <- pmin(n, xlen)#
    out <- c(rep(default, n), x[seq_len(xlen - n)])#
  }#
  attributes(out) <- attributes(x)#
  out#
}
library(dplyr)
library(data.table)
df <- data.frame(#
   date = 1:N,#
   id =  sample(5, N, TRUE),   #
   value =  sample(1e6, N, TRUE)                   #
 )#
# This solution#
system.time(setDT(df)[, lag_value := lag(value, 1, along_with = date), by = id])#
#> user  system elapsed #
#> 0.186   0.007   0.157  #
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#> user  system elapsed #
#> 0.186   0.007   0.200 #
# pure data.table solution#
setDF(df)#
system.time(setkey(setDT(df), id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#> user  system elapsed #
#> 0.113   0.023   0.147 #
#
# pure dplyr solution#
setDF(df)#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#> user  system elapsed #
#> 1.148   0.057   1.197
N <- 2e6#
df <- data.frame(#
   date = 1:N,#
   id =  sample(5, N, TRUE),   #
   value =  sample(1e6, N, TRUE)                   #
 )#
# This solution#
system.time(setDT(df)[, lag_value := lag(value, 1, along_with = date), by = id])#
#> user  system elapsed #
#> 0.186   0.007   0.157  #
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#> user  system elapsed #
#> 0.186   0.007   0.200 #
# pure data.table solution#
setDF(df)#
system.time(setkey(setDT(df), id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#> user  system elapsed #
#> 0.113   0.023   0.147 #
#
# pure dplyr solution#
setDF(df)#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#> user  system elapsed #
#> 1.148   0.057   1.197
library(microbenchmark)
microbenchmark(setDT(df)[, lag_value := lag(value, 1, along_with = date), by = id],times=10L)
N <- 2e6#
    df <- data.frame(#
       date = 1:N,#
       id =  sample(5, N, TRUE),   #
       value =  sample(1e6, N, TRUE)                   #
     )#
    # This solution#
    microbenchmark(setDT(df)[, lag_value := lag(value, 1, along_with = date), by = id])#
    #> user  system elapsed #
    #> 0.186   0.007   0.157  #
    microbenchmark(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
    #> user  system elapsed #
    #> 0.186   0.007   0.200 #
    # pure data.table solution#
    setDF(df)#
    microbenchmark(setkey(setDT(df), id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
    #> user  system elapsed #
    #> 0.113   0.023   0.147 #
#
    # pure dplyr solution#
    setDF(df)#
    microbenchmark(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
    #> user  system elapsed #
    #> 1.148   0.057   1.197
# This solution#
    setDT(df)#
    microbenchmark(df[, lag_value := lag(value, 1, along_with = date), by = id])#
    #> user  system elapsed #
    #> 0.186   0.007   0.157  #
    setDF(df)#
    microbenchmark(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
    #> user  system elapsed #
    #> 0.186   0.007   0.200 #
    # pure data.table solution#
    setDT(df)#
    microbenchmark(setkey(df, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
    #> user  system elapsed #
    #> 0.113   0.023   0.147 #
#
    # pure dplyr solution#
    setDF(df)#
    microbenchmark(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
    #> user  system elapsed #
    #> 1.148   0.057   1.197
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
   }#
# This solution against pure data.table#
setDT(df)#
microbenchmark(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>      min       lq   median       uq      max neval#
#> 39.23331 45.63224 48.26503 51.30011 88.56598   100 #
microbenchmark(setkey(df, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>      min       lq   median       uq      max neval#
#> 162.0913 179.7229 191.2539 230.4258 1663.312   100
setDF(df)#
    microbenchmark(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
    #>      min       lq   median       uq      max neval#
    #> 97.22887 111.8242 121.0254 141.8194 1090.357   100#
#
    microbenchmark(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))
df
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>     min       lq   median       uq      max neval#
#> 98.4322 105.3136 110.1891 116.5764 320.0336   100#
df1 <- copy(df)#
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>      min       lq   median       uq      max neval#
#> 135.2102 145.7594 161.0235 188.1168 390.2336   100#
#
# This solution against pure dplyr#
setDF(df)#
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#>      min       lq   median       uq      max neval#
#> 92.40668 95.37822 99.20339 103.0889 140.8624   100#
#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#>      min       lq   median       uq      max neval#
#> 2.422102 3.071185 3.281669 3.631934 4.818416   100
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>   user  system elapsed #
#>  0.094   0.007   0.103 #
df1 <- copy(df)#
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>   user  system elapsed #
#>  0.201   0.026   0.228 #
#
# This solution against pure dplyr#
setDF(df)#
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#>   user  system elapsed #
#>  0.156   0.028   0.186 #
#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#>   user  system elapsed #
#>  3.301   0.086   3.363
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ]))
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
setDT(df)
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>   user  system elapsed #
#>  0.094   0.007   0.103 #
df1 <- copy(df)#
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>   user  system elapsed #
#>  0.201   0.026   0.228 #
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>   user  system elapsed #
#>  0.094   0.007   0.103 #
df1 <- copy(df)#
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>   user  system elapsed #
#>  0.201   0.026   0.228
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
all.equal(setkey(df),df1)
all.equal(setkey(df,id,date),df1)
all.equal(setkey(df[, lag_value := lag(value, 1, along_with = date), by = id],id,date),setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
df1<- setkey(df[, lag_value := lag(value, 1, along_with = date), by = id],id,date)
df2<- setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
df2<- setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ]
df1
df2
dfdf1[!is.na(value_lagged)]
df1[!is.na(value_lagged)]
df[!is.na(value_lagged)]
lag <- function(x, n = 1L, along_with){#
 index <- match(along_with - n, along_with, incomparable = NA)#
 out <- x[index]#
 attributes(out) <- attributes(x)#
 out#
}
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>   user  system elapsed #
#>  0.094   0.007   0.103 #
df1 <- copy(df)
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
setDF(df)#
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#>   user  system elapsed #
#>  0.156   0.028   0.186 #
#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#>   user  system elapsed #
#>  3.301   0.086   3.363
?biglm
library(biglm)
install.packages("biglm")
?biglm
library(biglm)
?biglm
FALSE && NA
true || NA
TRUE || NA
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors specifying variables to match on. Default to common names between x and y. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi", "anti" and "cross".#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character checking for the presence of duplicates. Specifying "1:m" (resp "m:1") checks that joined variables uniquely identify observations in x (resp y).#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with .x and .y suffixes. The order of data.tables x and y is not conserved, unless they are keyed.#
#' @examples#
#'  join(x, y, on = intersect(names(x),names(y)), type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  if (type == "cross"){#
        k <- NULL # Setting the variables to NULL first for CRAN check NOTE#
        DT_output <- setkey(x[,c(k=1, .SD)],k)[y[, c(k = 1,.SD)], allow.cartesian = TRUE][,k := NULL]#
  }else {#
    # check gen#
    if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
      stop(" The option gen is only available for left, right and outer joins")#
    }#
#
    # join names#
    vars <- on#
    message(paste0("Join based on : ", paste(vars, collapse = " ")))#
#
    # set keys#
    key_x <- key(x)#
    key_y <- key(y)#
    setkeyv(x, vars)#
    setkeyv(y, vars)#
    on.exit(setkeyv(x, key_x);setkeyv(y, key_y))#
#
    # check duplicates#
    if (check[1] == "1"){#
       if (anyDuplicated(x)){ #
         stop("Variables don't uniquely identify observations in the master dataset")#
       }#
     }#
#
    if (check[3] == "1"){#
     if (anyDuplicated(y)){ #
       stop("Variables don't uniquely identify observations in the using dataset")#
     }#
    }#
#
    common_names <- setdiff(intersect(names(x),names(y)), vars)#
    if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"))#
    if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"))#
#
    if (length(common)>0){#
      x <- copy(x)#
      y <- copy(y)#
      setnames(x, common_names, paste0(common_names, ".x"))#
      setnames(x, common_names, paste0(common_names, ".y"))#
    }#
    if (type %in% c("left", "right", "outer", "inner")){#
      all.x <- FALSE#
      all.y <- FALSE#
      if (type == "left"| type == "outer"){#
        all.x = TRUE#
      }#
      if (type == "right" | type == "outer"){#
        all.y = TRUE#
      }#
      if (!gen == FALSE){#
        if (gen %chin% names(x)){#
          stop(paste0(gen," alreay exists in master"))#
        }#
        if (gen %chin% names(y)){#
          stop(paste0(gen," alreay exists in using"))#
        }#
        idm <- tempname_list("temp", c(names(x),names(y),gen))#
        x[, c(idm) := 1L]#
        idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
        y[, c(idu) := 1L]#
        on.exit(x[, c(idm) := NULL]; y[, c(idu) := NULL], add = TRUE) #
      }#
#
      DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
      if (gen != FALSE){#
        DT_output[, c(gen) := 3L]#
        eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
        eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
        DT_output[, c(idm) := NULL]#
        DT_output[, c(idu) := NULL]#
      }#
    } else if (type == "semi"){#
      w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
      w <- w[!is.na(w)]#
      DT_output <- x[w]#
    } else if (type == "anti"){#
      DT_output <- x[!y, allow.cartesian = TRUE]#
    } #
#
  }#
  DT_output#
}
?on.exit
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors specifying variables to match on. Default to common names between x and y. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi", "anti" and "cross".#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character checking for the presence of duplicates. Specifying "1:m" (resp "m:1") checks that joined variables uniquely identify observations in x (resp y).#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with .x and .y suffixes. The order of data.tables x and y is not conserved, unless they are keyed.#
#' @examples#
#'  join(x, y, on = intersect(names(x),names(y)), type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  if (type == "cross"){#
        k <- NULL # Setting the variables to NULL first for CRAN check NOTE#
        DT_output <- setkey(x[,c(k=1, .SD)],k)[y[, c(k = 1,.SD)], allow.cartesian = TRUE][,k := NULL]#
  }else {#
    # check gen#
    if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
      stop(" The option gen is only available for left, right and outer joins")#
    }#
#
    # join names#
    vars <- on#
    message(paste0("Join based on : ", paste(vars, collapse = " ")))#
#
    # set keys#
    key_x <- key(x)#
    key_y <- key(y)#
    setkeyv(x, vars)#
    setkeyv(y, vars)#
    on.exit(setkeyv(x, key_x))#
    on.exit(setkeyv(y, key_y), add = TRUE)#
#
    # check duplicates#
    if (check[1] == "1"){#
       if (anyDuplicated(x)){ #
         stop("Variables don't uniquely identify observations in the master dataset")#
       }#
     }#
#
    if (check[3] == "1"){#
     if (anyDuplicated(y)){ #
       stop("Variables don't uniquely identify observations in the using dataset")#
     }#
    }#
#
    common_names <- setdiff(intersect(names(x),names(y)), vars)#
    if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"))#
    if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"))#
#
    if (length(common)>0){#
      x <- copy(x)#
      y <- copy(y)#
      setnames(x, common_names, paste0(common_names, ".x"))#
      setnames(x, common_names, paste0(common_names, ".y"))#
    }#
    if (type %in% c("left", "right", "outer", "inner")){#
      all.x <- FALSE#
      all.y <- FALSE#
      if (type == "left"| type == "outer"){#
        all.x = TRUE#
      }#
      if (type == "right" | type == "outer"){#
        all.y = TRUE#
      }#
      if (!gen == FALSE){#
        if (gen %chin% names(x)){#
          stop(paste0(gen," alreay exists in master"))#
        }#
        if (gen %chin% names(y)){#
          stop(paste0(gen," alreay exists in using"))#
        }#
        idm <- tempname_list("temp", c(names(x),names(y),gen))#
        x[, c(idm) := 1L]#
        idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
        y[, c(idu) := 1L]#
        on.exit(x[, c(idm) := NULL], add = TRUE)#
        on.exit(y[, c(idu) := NULL], add = TRUE) #
      }#
#
      DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
      if (gen != FALSE){#
        DT_output[, c(gen) := 3L]#
        eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
        eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
        DT_output[, c(idm) := NULL]#
        DT_output[, c(idu) := NULL]#
      }#
    } else if (type == "semi"){#
      w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
      w <- w[!is.na(w)]#
      DT_output <- x[w]#
    } else if (type == "anti"){#
      DT_output <- x[!y, allow.cartesian = TRUE]#
    } #
#
  }#
  DT_output#
}
