DT
sum_up(DT, v2)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        eval(substitute(DT[, temp := winsorize(v)], list(v=as.name(v))))#
        ggplot(DT, aes_string(x = "temp")) + stat_density()#
    }#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, mean(x,na.rm=na.rm), sd(x,na.rm= na.rm), quantile(x, c(0,1), type = 1, na.rm = na.rm))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=quantile(x,c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type=1,na.rm=na.rm,names=FALSE)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
sum_up(DT, v2)
graph(DT, v2)
sum_up(DT, v2, graph = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        temp := winsorize(v)#
        ggplot(DT, aes_string(x = "temp")) + stat_density()#
    }#
  }#
}
sum_up(DT, v2, graph = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        temp = winsorize(v)#
        ggplot(DT, aes_string(x = "temp")) + stat_density()#
    }#
  }#
}
sum_up(DT, v2, graph = T)
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        eval(substitute(ans <- DT[, temp <- winsorize(v)], list(v= as.name(v))))#
        ggplot(DT, aes_string(x = "temp")) + stat_density()#
    }#
  }#
}
sum_up(DT, v2, graph = T)
sum_up <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        eval(substitute(ans <- DT[, temp <- winsorize(v)], list(v= as.name(v))))#
        g <- ggplot(DT, aes_string(x = "temp"))#
        g + stat_density()#
    }#
  }#
}
sum_up(DT, v2, graph = T)
sum_up(DT, v1, graph = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        eval(substitute(ans <- DT[, temp <- winsorize(v)], list(v= as.name(v))))#
        g <- ggplot(ans, aes_string(x = "temp"))#
        g + stat_density()#
    }#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, mean(x,na.rm=na.rm), sd(x,na.rm= na.rm), quantile(x, c(0,1), type = 1, na.rm = na.rm))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=quantile(x,c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type=1,na.rm=na.rm,names=FALSE)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
sum_up(DT, v1, graph = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        eval(substitute(ans <- x[, temp <- winsorize(v)], list(v= as.name(v))))#
        g <- ggplot(ans, aes_string(x = "temp"))#
        g + stat_density()#
    }#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, mean(x,na.rm=na.rm), sd(x,na.rm= na.rm), quantile(x, c(0,1), type = 1, na.rm = na.rm))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=quantile(x,c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type=1,na.rm=na.rm,names=FALSE)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
sum_up(DT, v1, graph = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        eval(substitute(ans <- x[, temp = winsorize(v)], list(v= as.name(v))))#
        g <- ggplot(ans, aes_string(x = "temp"))#
        g + stat_density()#
    }#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, mean(x,na.rm=na.rm), sd(x,na.rm= na.rm), quantile(x, c(0,1), type = 1, na.rm = na.rm))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=quantile(x,c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type=1,na.rm=na.rm,names=FALSE)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        eval(substitute(ans <- x[, list(temp = winsorize(v))], list(v= as.name(v))))#
        g <- ggplot(ans, aes_string(x = "temp"))#
        g + stat_density()#
    }#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, mean(x,na.rm=na.rm), sd(x,na.rm= na.rm), quantile(x, c(0,1), type = 1, na.rm = na.rm))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=quantile(x,c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type=1,na.rm=na.rm,names=FALSE)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
sum_up(DT, v1, graph = T)
sum_up(DT, v1, graph = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        eval(substitute(ans <- x[, list(temp = winsorize(v))], list(v= as.name(v))))#
        print(ans)#
        g <- ggplot(ans, aes_string(x = "temp"))#
        g + stat_density()#
    }#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, mean(x,na.rm=na.rm), sd(x,na.rm= na.rm), quantile(x, c(0,1), type = 1, na.rm = na.rm))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=quantile(x,c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type=1,na.rm=na.rm,names=FALSE)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
sum_up(DT, v1, graph = T)
?aes_string
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        eval(substitute(ans <- x[, list(temp = winsorize(v))], list(v= as.name(v))))#
        print(ans)#
        print(ggplot(ans, aes_string(x = "temp")) + stat_density())#
    }#
  }#
}
?aes_string
sum_up(DT, v1, graph = T)
is.integer(DT[,c("id")])
is.integer(DT[,c("id"), with = FALSE])
DT
is.integer(DT[,c("v1"), with = FALSE])
DT
glimpse(DT)
is.integer(DT[,v1, with = FALSE])
is.integer(DT[,v1])
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) (#
          print(ggplot(DT, aes_string(x = v)) + geom_histogram())#
        }#
#
        eval(substitute(ans <- x[, list(temp = winsorize(v))], list(v= as.name(v))))#
        print(ggplot(ans, aes_string(x = "temp")) + stat_density())#
      } els#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) (#
          print(ggplot(DT, aes_string(x = v)) + geom_histogram())#
        } else{ #
          eval(substitute(ans <- x[, list(temp = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = "temp")) + stat_density())#
        }#
    } #
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, mean(x,na.rm=na.rm), sd(x,na.rm= na.rm), quantile(x, c(0,1), type = 1, na.rm = na.rm))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=quantile(x,c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type=1,na.rm=na.rm,names=FALSE)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
sum_up(DT, v1, graph = T)
sum_up(DT, id, graph = T)
sum_up(DT, v1, graph = T)
is.integer(DT[,v])
is.integer(DT[,v1])
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) (#
          print(ggplot(DT, aes_string(x = v)) + geom_histogram())#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density())#
        }#
    } #
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, mean(x,na.rm=na.rm), sd(x,na.rm= na.rm), quantile(x, c(0,1), type = 1, na.rm = na.rm))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=quantile(x,c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type=1,na.rm=na.rm,names=FALSE)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
is.integer(DT[,v1])
sum_up(DT, v1, graph = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) (#
          print(ggplot(DT, aes_string(x = v)) + geom_histogram())#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density())#
        }#
    } #
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(DT, aes_string(x = v)) + geom_histogram()#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density())#
        }#
    } #
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(DT, aes_string(x = v)) + geom_histogram())#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density())#
        }#
    } #
  }#
}
sum_up(DT, v1, graph = T)
geom_facet
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(DT, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    DT[unique(x, by=byvars), group:=1]#
    DT[, (group):= cumsum(tag, na.rm = TRUE)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(DT, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(DT, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    DT[unique(x, by=byvars), group:=1]#
    DT[, (group):= cumsum(tag, na.rm = TRUE)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(DT, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    x[unique(x, by=byvars), group:=1]#
    x[, (group):= cumsum(tag, na.rm = TRUE)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(x, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
} #
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d), .SDcols = vars, by = byvars])#
  }#
#
  if (graph){#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) (#
          print(ggplot(DT, aes_string(x = v)) + geom_histogram())#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density())#
        }#
    } #
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    x[unique(x, by=byvars), group:=1]#
    x[, (group):= cumsum(tag, na.rm = TRUE)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(x, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, id)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v)))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    x[unique(x, by=byvars), group:=1]#
    x[, (group):= cumsum(tag, na.rm = TRUE)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(x, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    x[unique(x, by=byvars), group:=1]#
    x[, (group):= cumsum(tag, na.rm = TRUE)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(x, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
traceback()
graph(DT, id)
graph(DT, v1)
graph(DT, v1, by = id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    ans <- x[,c(byvars, vars), with = FALSE]#
    x[unique(x, by = byvars), group := 1]#
    x[, (group):= cumsum(tag, na.rm = TRUE)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(x, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1, by = id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    ans <- x[,c(byvars, vars), with = FALSE]#
    setkeyv(ans, byvars)#
    x[unique(x), group := 1]#
    x[, (group):= cumsum(tag, na.rm = TRUE)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(x, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1, by = id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    ans <- x[,c(byvars, vars), with = FALSE]#
    setkeyv(ans, byvars)#
    ans[unique(ans), group := 1]#
    ans[, (group):= cumsum(tag, na.rm = TRUE)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(ans = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(ans = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1, by = id)
?cumsum
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    ans <- x[,c(byvars, vars), with = FALSE]#
    setkeyv(ans, byvars)#
    ans[, group := 0]#
    ans[unique(ans), group := 1]#
    ans[, (group):= cumsum(tag)]#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(ans = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(ans = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1, by = id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    ans <- x[,c(byvars, vars), with = FALSE]#
    setkeyv(ans, byvars)#
    ans[, (group) := 0]#
    ans[unique(ans), (group) := 1]#
    eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(ans = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(ans = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1, by = id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    group <- "group"#
    ans <- x[,c(byvars, vars), with = FALSE]#
    setkeyv(ans, byvars)#
    ans[, (group) := 0]#
    ans[unique(ans), (group) := 1]#
    eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1, by = id)
DT
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    if (length(byvars)>1){#
      group <- "group"#
      ans <- x[,c(byvars, vars), with = FALSE]#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1, by = id)
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, d = FALSE, graph = FALSE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]) + is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            print(ggplot(x, aes_string(x = v)) + geom_histogram())#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
graph(DT, v1, by = id)
suppressWarnings(graph(DT, v1))
?stat_bin
ggplot(DT, aes_string(x = "id")) + geom_histogram() + coord_flip()
ggplot(DT, aes_string(x = "id")) + geom_histogram() + coord_flip()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]+ is.character(x[,v]), list(v = as.name(v))))#
          if ((reorder){#
          }#
#
          if (dummy) {#
            if ((!reorder)){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- x[, c(v,N):=list(v,.N)]#
              setkeyv(ans, "N")#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]+ is.character(x[,v]), list(v = as.name(v))))#
          if ((reorder){#
          }#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- x[, c(v,N):=list(v,.N)]#
              setkeyv(ans, "N")#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- x[, c(v,N):=list(v,.N)]#
              setkeyv(ans, "N")#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v]+ is.character(x[,v]), list(v = as.name(v)))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- x[, c(v,N):=list(v,.N)]#
              setkeyv(ans, "N")#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- x[, c(v,N):=list(v,.N)]#
              setkeyv(ans, "N")#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, c(v,N):=list(v,.N)], list( v = as.name(v))))#
              setkeyv(ans, "N")#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, c(v,N):=list(v,.N), by = v], list( v = as.name(v))))#
              setkeyv(ans, "N")#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
traceback()
graph(DT, v1)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v,.N), by = v], list( v = as.name(v))))#
              setnames(DT, c("v","N"))#
              setkeyv(ans, "N")#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(.N), by = v], list( v = as.name(v))))#
              setkeyv(ans, c(".N",v))#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
DT[,list(.N)]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(.N), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N",v))#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
DT[,list(.N)]
graph(DT, v1)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(.N), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N",v))#
              print(ans)#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v,.N), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N",v))#
              print(ans)#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
DT
DT[, list(id), by=id]
DT[, list(v2), by=id]
DT <- data.table(id = c(1,1,2,2))#
DT[, list(id), by=id]
DT[, by=id]
DT <- data.table(id = c(1,1,2,2))#
DT[, list(id), by=id]
DT <- data.table(id = c(1,1,2,2))#
DT[, list(id), by=id]
DT <- data.table(id = c(1,1,2,2))#
DT[, list(id, N), by=id]
DT <- data.table(id = c(1,1,2,2))#
DT[, list(id), by=id]#
DT[, list(id, .N), by=id]
DT <- data.table(id = c(1,1,2,2))#
DT[, list(id), by=id]#
DT[, list(id, .N), by=id]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v,rep(.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N",v))#
              print(ans)#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
DT <- data.table(id = c(1,1,2,2))#
DT[, list(id), by=id]#
DT[, list(id, .N), by=id]
graph(DT, v1)
traceback()
setwd("/Users/Matthieu/Dropbox/Symlink")#
N=1e2; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N",v))#
              print(ans)#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N",v))#
              print(ans)#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
DT
DT[, N := .N, by = v1]
DT
setkey(DT,N,v1)
DT
print(ggplot(DT, aes_string(x = v1)) + geom_histogram() + coord_flip())
print(ggplot(DT, aes(x = v1)) + geom_histogram() + coord_flip())
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N",v))#
              print(ggplot(ans, aes_string(x = v)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
?as.factor
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N","var"))#
              ans <- eval(substitute(x[, v := as.factor(v)]#
              print(ggplot(ans, aes(x = var)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N","var"))#
              ans <- eval(substitute(x[, v := as.factor(v)]))#
              print(ggplot(ans, aes(x = var)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N","var"))#
              ans <- x[, v := as.factor(v)]#
              print(ggplot(ans, aes(x = var)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(x[, v := as.factor(v)], list( v= as.name(v))))#
              print(ggplot(ans, aes(x = var)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_histogram()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ggplot(ans, aes(x = var)) + geom_histogram() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ggplot(ans, aes(x = var)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT, v1)
?quantile
?mean
?wtd.quantile
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = w)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = NULL), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0,1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm, weights = w)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, weights = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT)
traceback()
wtd.mean(c(1,2), w = NULL)
library(Hmisc)
install.packages(Hmisc)
install.packages("Hmisc")
library(Hmisc)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = w)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = NULL), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0,1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min","Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm, weights = w)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, weights = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT)
traceback()
wtd.mean(c(1,2), w = NULL)
wtd.var(c(1,2), w = NULL)
wtd.quantile(c(1,2), w = NULL)
wtd.quantile(c(1,2), w = NULL, names = FALSE)
function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = NULL), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}
f <-function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = NULL), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}
f(c(1,2))
na.rm= TRUE
w = NULL
f <-function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = NULL), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}
f(c(1,2))
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = w)#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = w), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "Median", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm, weights = w)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, weights = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, w = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = w), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "Median", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm, weights = w)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, weights = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, w = v1)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = w), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm, weights = w)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, weights = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, w = v1)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = w), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm, weights = w)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, weights = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"0+$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, w = v1)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, w = v1)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
#
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = w), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colMeans(M ,na.rm=na.rm, weights = w)#
    f=function(x,m){#
      sum_higher <- colMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, weights = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
?colMeans
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, wtd.mean(x,na.rm=na.rm, w = w), sqrt(wtd.var(x,na.rm= na.rm)), wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- colWeightedMeans(M ,na.rm=na.rm, w= w)#
    f=function(x,m){#
      sum_higher <- colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- matrixStats::colWeightedMeans(M ,na.rm=na.rm, w= w)#
    f=function(x,m){#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
install.packages(matrixStats)
install.packages("matrixStats")
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = x[,w, with = FALSE], na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- matrixStats::colWeightedMeans(M ,na.rm=na.rm, w= w)#
    f=function(x,m){#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
colWeightedMeans(M, na.rm = TRUE
)
matrix.Stats::colWeightedMeans(M, na.rm = TRUE
)
matrixStats::colWeightedMeans(M, na.rm = TRUE)
matrixStats::colWeightedMeans(as.matrix(DT[[2]], na.rm = TRUE)
)
?data.table
names(DT)[names(DT)=="id"]
names(DT)[names(DT)==NULL]
names(DT)==NULL
names(DT)=="id"
which(names(DT)=="id")
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if !is.null(w){#
    w <- x[[which(names(x)[names(x)== w])]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- matrixStats::colWeightedMeans(M ,na.rm=na.rm, w = w)#
    f=function(x,m){#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)[names(x)== w])]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- matrixStats::colWeightedMeans(M ,na.rm=na.rm, w = w)#
    f=function(x,m){#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  if (!length(w)) w <- NULL#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(as.matrix(.SD),d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    sum_mean <- matrixStats::colWeightedMeans(M ,na.rm=na.rm, w = w)#
    f=function(x,m){#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  if (!length(w)) w <- NULL#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    f=function(x,m){#
      m <- wtd.mean(m, na.rm = na.rm, w= w)#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M,sum_mean))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  if (!length(w)) w <- NULL#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    f=function(x){#
      m <- wtd.mean(m, na.rm = na.rm, w= w)#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mcMap(f,M))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  if (!length(w)) w <- NULL#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    f=function(x){#
      m <- wtd.mean(m, na.rm = na.rm, w= w)#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mclapply(f,M))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  if (!length(w)) w <- NULL#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    f=function(x){#
      m <- wtd.mean(m, na.rm = na.rm, w= w)#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n",na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mclapply(f,M))#
    print(sum)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
debug(sum_up)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
s
n
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
s
n
undebug(sum_up)
debug(describe_matrix)
undebug(sum_up)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
n
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
sum
f
f
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT)
f
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  if (!length(w)) w <- NULL#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    f=function(x){#
      m <- wtd.mean(m, na.rm = na.rm, w = w)#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n", na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- do.call(cbind,mclapply(M, f))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  if (!length(w)) w <- NULL#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    f=function(x){#
      m <- wtd.mean(m, na.rm = na.rm, w = w)#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n", na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- as.data.frame(mclapply(M, f)))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  if (!length(w)) w <- NULL#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    f=function(x){#
      m <- wtd.mean(m, na.rm = na.rm, w = w)#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n", na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- as.data.frame(mclapply(M, f))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
sum_up <- function(x, ...,  d = FALSE, w = NULL, na.rm = TRUE, by = NULL) {#
  sum_up_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, w = substitute(w))#
}#
#' @export#
#' @rdname sum_up#
sum_up_<- function(x, ..., .dots,  d = FALSE, w = NULL, by = NULL) {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x), w))#
  if (!length(w)) w <- NULL#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars,w))#
  }#
  nums <- sapply(x, is.numeric)#
  nums_name <- names(nums[nums==TRUE])#
  vars=intersect(vars,nums_name)#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
#
  if (!is.null(w)){#
    w <- x[[which(names(x)== w)]]#
  }#
  if (!length(byvars)){#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars])#
  } else{#
    invisible(x[, describe_matrix(.SD,d = d, w = w, na.rm = na.rm ), .SDcols = vars, by = byvars])#
  }#
}#
describe_matrix <- function(M, details = FALSE, na.rm = TRUE, w = NULL, mc.cores=getOption("mc.cores", 2L)){#
  # import from stargazer#
  .iround <- function(x, decimal.places = 0, round.up.positive = FALSE, #
      simply.output = FALSE,  .format.digit.separator = ",") {#
    .format.initial.zero <- TRUE#
    .format.until.nonzero.digit <- TRUE#
    .format.max.extra.digits <- 2#
    .format.digit.separator.where <- c(3)#
    .format.ci.separator <- ", "#
    .format.round.digits <- 3#
    .format.decimal.character <- "."#
    .format.dec.mark.align <- FALSE#
    .format.dec.mark.align <- TRUE#
    x.original <- x#
    first.part <- ""#
    if (is.na(x) | is.null(x)) {#
      return("")#
    }#
    if (simply.output == TRUE) {#
      if (!is.numeric(x)) {#
        return(.remove.special.chars(x))#
      }#
    }#
    if (x.original < 0) {#
      x <- abs(x)#
    }#
    if (!is.na(decimal.places)) {#
        if ((.format.until.nonzero.digit == FALSE) | (decimal.places <= #
            0)) {#
            round.result <- round(x, digits = decimal.places)#
        }#
        else {#
            temp.places <- decimal.places#
            if (!.is.all.integers(x)) {#
              while ((round(x, digits = temp.places) == 0) & #
                (temp.places < (decimal.places + .format.max.extra.digits))) {#
                temp.places <- temp.places + 1#
              }#
            }#
            round.result <- round(x, digits = temp.places)#
            decimal.places <- temp.places#
        }#
        if ((round.up.positive == TRUE) & (round.result < #
            x)) {#
            if (x > (10^((-1) * (decimal.places + 1)))) {#
              round.result <- round.result + 10^((-1) * decimal.places)#
            }#
            else {#
              round.result <- 0#
            }#
        }#
    }#
    else {#
        round.result <- x#
    }#
    round.result.char <- as.character(format(round.result, #
        scientific = FALSE))#
    split.round.result <- unlist(strsplit(round.result.char, #
        "\\."))#
    for (i in seq(from = 1, to = length(.format.digit.separator.where))) {#
        if (.format.digit.separator.where[i] <= 0) {#
            .format.digit.separator.where[i] <<- -1#
        }#
    }#
    separator.count <- 1#
    length.integer.part <- nchar(split.round.result[1])#
    digits.in.separated.unit <- 0#
    for (i in seq(from = length.integer.part, to = 1)) {#
        if ((digits.in.separated.unit == .format.digit.separator.where[separator.count]) & #
            (substr(split.round.result[1], i, i) != "-")) {#
            first.part <- paste(.format.digit.separator, #
              first.part, sep = "")#
            if (separator.count < length(.format.digit.separator.where)) {#
              separator.count <- separator.count + 1#
            }#
            digits.in.separated.unit <- 0#
        }#
        first.part <- paste(substr(split.round.result[1], #
            i, i), first.part, sep = "")#
        digits.in.separated.unit <- digits.in.separated.unit + #
            1#
    }#
    if (x.original < 0) {#
        if (.format.dec.mark.align == TRUE) {#
            first.part <- paste("-", first.part, sep = "")#
        }#
        else {#
            first.part <- paste("$-$", first.part, sep = "")#
        }#
    }#
    if (!is.na(decimal.places)) {#
        if (decimal.places <= 0) {#
            return(first.part)#
        }#
    }#
    if (.format.initial.zero == FALSE) {#
        if ((round.result >= 0) & (round.result < 1)) {#
            first.part <- ""#
        }#
    }#
    if (length(split.round.result) == 2) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
        if (nchar(split.round.result[2]) < decimal.places) {#
            decimal.part <- split.round.result[2]#
            for (i in seq(from = 1, to = (decimal.places - #
              nchar(split.round.result[2])))) {#
              decimal.part <- paste(decimal.part, "0", sep = "")#
            }#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        else {#
            return(paste(first.part, .format.decimal.character, #
              split.round.result[2], sep = ""))#
        }#
    }#
    else if (length(split.round.result) == 1) {#
        if (is.na(decimal.places)) {#
            return(paste(first.part, .format.decimal.character, #
              decimal.part, sep = ""))#
        }#
        decimal.part <- ""#
        for (i in seq(from = 1, to = decimal.places)) {#
            decimal.part <- paste(decimal.part, "0", sep = "")#
        }#
        return(paste(first.part, .format.decimal.character, #
            decimal.part, sep = ""))#
    }#
    else {#
        return(NULL)#
    }#
  }#
  is.wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - #
      round(x)) < tol#
  .is.all.integers <- function(x) {#
      if (!is.numeric(x)) {#
          return(FALSE)#
      }#
      if (length(x[!is.na(x)]) == length(is.wholenumber(x)[(!is.na(x)) & #
          (is.wholenumber(x) == TRUE)])) {#
          return(TRUE)#
      }#
      else {#
          return(FALSE)#
      }#
  }#
  # Now starts the code #
  if (details==FALSE) {#
   sum_mean <-as.data.frame(mclapply(M ,function(x){a <- sum(is.na(x)) ; c(length(x)-a,a, Hmisc::wtd.mean(x,na.rm=na.rm, w = w), sqrt(Hmisc::wtd.var(x,na.rm= na.rm)), Hmisc::wtd.quantile(x, c(0, 0.5, 1), type = "i/n", na.rm = na.rm, weights = w))}))#
    sum <- as.matrix(sum_mean)#
    rownames(sum) <-  c("N","NA","Mean","Sd","Min", "50%", "Max")#
#
  } else {#
    N <- nrow(M)#
    f=function(x){#
      m <- wtd.mean(x, na.rm = na.rm, w = w)#
      sum_higher <- matrixStats::colWeightedMeans(cbind((x-m)^2,(x-m)^3,(x-m)^4), na.rm=na.rm, w = w)#
      sum_higher[1] <- sqrt(sum_higher[1])#
      sum_higher[2] <- sum_higher[2]/sum_higher[1]^3#
      sum_higher[3] <- sum_higher[3]/sum_higher[1]^4#
      sum_quantile=Hmisc::wtd.quantile(x, c(0,0.01,0.05,0.1,0.25,0.50,0.75,0.9,0.95,0.99,1),type= "i/n", na.rm=na.rm, weights = w)#
      n_NA <- sum(is.na(x))#
      sum <- c(N-n_NA,n_NA,m,sum_higher,sum_quantile)#
    }#
    sum <- as.data.frame(mclapply(M, f))#
    rownames(sum) <-  c("N","NA","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
    # rownames(sum) <- c("Rows","N","Mean","Sd","Skewness","Kurtosis","Min","1%","5%","10%","25%","50%","75%","90%","95%","99%","Max")#
  }#
  print <- apply(sum,c(1,2),#
    function(x){#
    if (is.numeric(x)){#
      y <- .iround(x,decimal.places=3)#
      y <- str_replace(y,"000$","")#
      if (y==""){#
        y <- "0"#
      }#
      y <- str_replace(y,"\\.$","")#
      y <- str_replace(y,"-0","0")#
    } else{#
      y <- x#
    }#
    y#
  })#
  print(noquote(format(print,justify="right")),right=TRUE)#
  cat("\n")#
}
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T)
N <- 100; K <- 10#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE)#
)#
sum_up(DT, d = T, w = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ggplot(ans, aes(x = var)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT,id)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(v, N = rep(-.N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(ggplot(ans, aes(x = var)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
traceback()
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = rep(N,.N)), by = v], list( v = as.name(v))))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(ggplot(ans, aes(x = var)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = rep(N,.N)), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(ggplot(ans, aes(x = var)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = rep(N,.N)), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              print(ggplot(ans, aes(x = var)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = rep(N,.N)), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              print(ggplot(ans, aes(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = rep(N,.N)), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              print(ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
graph(DT,id)
DDT
DT
DT[,.N]
DT[,N := .N]
DT
glimpse(N)
glimpse(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
  if (!length(byvars)){#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              print(ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              print(ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            print(ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- "group"#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
        dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
        if (dummy) {#
          print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0("~",group))))#
        } else{ #
          eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
          print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
        }#
    }#
  }#
}
glimpse(DT)
DT[,N := .N]
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Symlink")#
N=1e2; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
graph(DT,id)
graph(DT,id, by = v1)
DT <- data.table(id = c(1,1,2,2))
DT[, list(id, .N), by=id]
DT
append(NULL, 1)
append(NULL, 1, 3)
append(1, 3)
?append
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g <- c(g, ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g <- c(g,gplot(ans, aes_string(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g <- c(g, ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
        do.call(multiplot, g)#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
    }#
  }#
} #
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g <- c(g, ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g <- c(g,gplot(ans, aes_string(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g <- c(g, ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
        do.call(multiplot, g)#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
    }#
  }#
} #
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g <- c(g, ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g <- c(g,gplot(ans, aes_string(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g <- c(g, ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
        print(do.call(multiplot, g))#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
    }#
  }#
} #
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT,id)
g
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g <- c(g, ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g <- c(g,gplot(ans, aes_string(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g <- c(g, ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
        pring(g)#
        print(do.call(multiplot, g))#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
    }#
  }#
} #
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
g
graph(DT,id)
graph(DT,id1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g <- c(g, ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g <- c(g,gplot(ans, aes_string(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g <- c(g, ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
        print(g)#
        print(do.call(multiplot, g))#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
    }#
  }#
} #
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
DT
setwd("/Users/Matthieu/Dropbox/Symlink")#
DT <- data.table(#
         date = sample(10, N, TRUE),#
           id = sample(1e5, N, TRUE),   #
        value = sample(c(NA,1:5), N, TRUE)                   #
      )
graph(DT,id1)
DT
graph(DT,id1)
traceback()
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g <- c(g, ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g <- c(g,ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g <- c(g, ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
        print(g)#
        print(do.call(multiplot, g))#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
    }#
  }#
} #
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT,id)
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g <- c(g, ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip())#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g <- c(g, ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip())#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g <- c(g, ggplot(ans, aes_string(x = v)) + stat_density())#
          }#
        print(g)#
        print(do.call(multiplot, g))#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
    }#
  }#
} #
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
DT
graph(DT)
g <- ggplot(DT, aes = id) + geom_bar
g <- ggplot(DT, aes(x=id)) + geom_bar
g <- ggplot(DT, aes(x=id)) + geom_bar()
g <- c(g,ggplot(DT, aes(x=v1)) + geom_bar())
g
g
g
g
g
g <- ggplot(DT, aes(x=id)) + geom_bar()
h
g
g1 <- ggplot(DT, aes(x=v1)) + geom_bar()
g
g1
g
setwd("/Users/Matthieu/Dropbox/Symlink")#
N=1e2; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
g <- ggplot(DT, aes(x=id)) + geom_bar()
g1 <- ggplot(DT, aes(x=v1)) + geom_bar()
multiplot(g,g1)
do.call(multiplot(list(g,g1))
)
do.call(multiplot,list(g,g1)))
do.call(multiplot,list(g,g1))
do.call(multiplot,c(g,g1))
do.call(multiplot,list(g,g1))
i=3
g[[i]]<-3
g
g <- NULL
g[[i]]<-3
g
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
        print(g)#
        print(do.call(multiplot, g))#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
    }#
  }#
} #
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
        print(g)#
        print(do.call(multiplot, g))#
      } #
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
        print(g)#
      } #
    do.call(multiplot, g)#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Symlink")#
N=1e2; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g))==1{#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g))==1{#
      print(g)#
    } else{#
      print(do.call(multiplot, g))#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              print(ans)#
              print(glimpse(ans))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
      for (v in vars){#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          print(g)#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              glimpse(ans)#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v)], list( v= as.name(v))))#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v1)
f <- as.factor(c("ok","ok1"))
f
?as.factor
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := as.factor(v, ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(-.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v1)
?factor
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(-.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_grid(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v1)
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
    if (dummy) {#
      print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0(vars,"~",group))))#
    } else{ #
      eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
      print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1]
graph(DT, v3, by = v1)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    for (v in vars){#
      dummy <- eval(substitute(is.integer(ans[,v]) + is.character(ans[,v]), list(v = as.name(v))))#
      if (dummy) {#
        print(ggplot(ans, aes_string(x = v)) + geom_histogram() + facet_wrap(as.formula(paste0(vars,"~",group))))#
      } else{ #
        eval(substitute(ans <- ans[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
        print(ggplot(ans, aes_string(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group))))#
      }#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_wrap(as.formula(paste0(vars,"~",group)))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_wrap(as.formula(paste0(vars,"~",group)))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_wrap(as.formula(paste0(vars,"~",group)))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_wrap(as.formula(paste0("~",group)))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_wrap(as.formula(paste0("~",group)))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_wrap(as.formula(paste0(vars,"~",group)))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_wrap(as.formula(paste0("~",group)))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_wrap(as.formula(paste0("~",group)))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group)))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_wrap(as.formula(paste0("~",group)))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_wrap(as.formula(paste0("~",group)))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v), verbose = FALSE)], list(v= as.name(v))))#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group)))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_wrap(as.formula(paste0("~",group)))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_wrap(as.formula(paste0("~",group)))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group)))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_wrap(as.formula(paste0("~",group)))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_wrap(as.formula(paste0("~",group)))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE)), by = c(byvars)], list(v= as.name(v))))#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_wrap(as.formula(paste0("~",group)))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0("~",group)))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0("~",group)))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE)), by = c(byvars)], list(v= as.name(v))))#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0("~",group)))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group, "~")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~")))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE)), by = c(byvars)], list(v= as.name(v))))#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE)), by = c(byvars)], list(v= as.name(v))))#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v, color = group)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v, color = group)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE)), by = c(byvars)], list(v= as.name(v))))#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes(x = v, color = group)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v, fill = group)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v, fill = group)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE)), by = c(byvars)], list(v= as.name(v))))#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes(x = v, fill = group)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE)), by = c(byvars)], list(v= as.name(v))))#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
graph(DT, v3, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE)), by = c(byvars)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
graph(DT)
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
#
              glimpse(ans)#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE)), by = c(byvars)], list(v= as.name(v))))#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
graph(DT, reorder = FALSE)
graph(DT)
?geom_bar
graph(DT, v3, by = v1)
graph(DT, v2, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
    pring(vars)#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v2, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    pring(byvars)#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v2, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    print(byvars)#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v2, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    print(vars)#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v2, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          print(dummy)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, v3, by = v1)
graph(DT, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, by = v1)
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(byvars,v)]))#
              setkeyv(ans, c(byvars, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
graph(DT, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, by = v1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = FALSE))], list(group = as.name(group), v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT, by = v1)
graph(DT, v3)
graph(DT, v1)
graph(DT)
v<-"ok"
assign(v,v)
ok
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = FALSE))], list(group = as.name(group), v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = FALSE))], list(group = as.name(group), v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(v = winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            print(ans)#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = FALSE))], list(group = as.name(group), v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
              setnames(DT,v)#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = FALSE))], list(group = as.name(group), v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
              setnames(ans,v)#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = FALSE))], list(group = as.name(group), v= as.name(v))))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Gives summary statistics (corresponds to Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which summary statistics are printed. Default to NULL. See the \link[dplyr]{select} documentation.#
#' @param d Should detailed summary statistics be printed?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, graph = FALSE, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, graph = graph, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, graph = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(winsorize(v, verbose = FALSE))], list(v= as.name(v))))#
              setnames(ans,v)#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = FALSE))], list(group = as.name(group), v= as.name(v))))#
              setnames(ans,c(group,v))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Experimental function to graph a dataset#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which variables should be ploted.#
#' @param reorder Should the value of strings with the most count be printed first?#
#' @param winsorize Should numeric variables winsorized?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 = sample(5, N, TRUE),#
#'   v2 = sample(1e6, N, TRUE)#
#' )#
#' sum_up(DT)#
#' sum_up(DT, v2, d = T)#
#' sum_up(DT, starts_with("v"), by = v1)#
#' @export#
graph <- function(x, ..., by = NULL reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(winsorize(v, verbose = TRUE))], list(v= as.name(v))))#
              setnames(ans,v)#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = TRUE))], list(group = as.name(group), v= as.name(v))))#
              setnames(ans,c(group,v))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Experimental function to graph a dataset#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which variables should be ploted.#
#' @param reorder Should the value of strings with the most count be printed first?#
#' @param winsorize Should numeric variables winsorized?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   v1 = sample(5, N, TRUE),#
#'   v2 =  sample(round(runif(100,max=100),4), N, TRUE)#
#
#' )#
#' graph(DT)#
#' graph(DT, by = v1)#
#' @export#
graph <- function(x, ..., by = NULL reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(winsorize(v, verbose = TRUE))], list(v= as.name(v))))#
              setnames(ans,v)#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = TRUE))], list(group = as.name(group), v= as.name(v))))#
              setnames(ans,c(group,v))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
N <- 100; K <- 10#
DT <- data.table(#
  v1 = sample(5, N, TRUE),#
  v2 =  sample(round(runif(100,max=100),4), N, TRUE)#
#
)#
graph(DT)#
graph(DT, by = v1)
graph(DT)
N <- 100; K <- 10#
DT <- data.table(#
  v1 = sample(5, N, TRUE),#
  v2 =  sample(round(runif(100,max=100),4), N, TRUE)#
#
)#
graph(DT)#
graph(DT, by = v1)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Experimental function to graph a dataset#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which variables should be ploted.#
#' @param reorder Should the value of strings with the most count be printed first?#
#' @param winsorize Should numeric variables winsorized?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   v1 = sample(5, N, TRUE),#
#'   v2 =  sample(round(runif(100,max=100),4), N, TRUE)#
#
#' )#
#' graph(DT)#
#' graph(DT, by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(winsorize(v, verbose = TRUE))], list(v= as.name(v))))#
              setnames(ans,v)#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = TRUE))], list(group = as.name(group), v= as.name(v))))#
              setnames(ans,c(group,v))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Experimental function to graph a dataset#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param by Groups within which variables should be ploted.#
#' @param reorder Should the value of strings with the most count be printed first?#
#' @param winsorize Should numeric variables winsorized?#
#' @examples#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   v1 = sample(5, N, TRUE),#
#'   v2 =  sample(round(runif(100,max=100),4), N, TRUE)#
#
#' )#
#' graph(DT)#
#' graph(DT, by = v1)#
#' @export#
graph <- function(x, ..., by = NULL, reorder = TRUE, winsorize = TRUE) {#
  graph_(x, .dots = lazy_dots(...) , by = substitute(by), d = d, reorder = reorder, winsorize = winsorize)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots ,by = NULL, d = FALSE, reorder = TRUE, winsorize = winsorize) {#
  stopifnot(is.data.table(x))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), byvars)#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = v]))#
              setkeyv(ans, c("N", v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(winsorize(v, verbose = TRUE))], list(v= as.name(v))))#
              setnames(ans,v)#
            } else{#
              eval(substitute(ans <- x[, list(v)], list(v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density()#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  } else{#
    ans <- x[,c(byvars, vars), with = FALSE]#
    if (length(byvars)>1){#
      group <- tempname("group", x)#
      setkeyv(ans, byvars)#
      ans[, (group) := 0]#
      ans[unique(ans), (group) := 1]#
      eval(substitute(ans[, (group):= cumsum(v)], list(v = as.name(group))))#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
          dummy <- eval(substitute(is.integer(x[,v])+ is.character(x[,v]), list(v = as.name(v))))#
          assign(v,v)#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(x = v)) + geom_bar()+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
            } else{#
              ans <- eval(substitute(x[, list(N = as.integer(rep(.N,.N))), by = c(group,v)]))#
              setkeyv(ans, c(group, "N",v))#
              ans <- eval(substitute(ans[, v := factor(v, levels = unique(v), ordered = TRUE)], list( v= as.name(v))))#
              g[[i]] <-  ggplot(ans, aes_string(x = v)) + geom_bar() + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          } else{ #
            if (winsorize){#
              eval(substitute(ans <- x[, list(group, v = winsorize(v, verbose = TRUE))], list(group = as.name(group), v= as.name(v))))#
              setnames(ans,c(group,v))#
            } else{#
              eval(substitute(ans <- x[, list(group, v)], list(group = as.name(group), v= as.name(v))))#
            }#
            g[[i]] <-  ggplot(ans, aes_string(x = v)) + stat_density() + facet_grid(as.formula(paste0(group, "~.")))#
          }#
      } #
    if (length(g)==1){#
      print(g)#
    } else{#
      do.call(multiplot, g)#
    }#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
