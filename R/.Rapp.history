DT
DT %>% select(v1) %>% mutate_each(funs(mean),inplace=T)
library(dplyr)
library(data.table)#
x <- data.table(a = 11:15, b = 111:115, val1 = rnorm(5), key = c("a", "b"))#
y <- data.table(b = 101:120, val2 = letters[1:20], key = "b")
x
y
N=1e4; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
)
N=1e4; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE)                         # int in range [1,5]#
)
setkey(DT,id)
DT[J(id,v1)]
DT1 <- DT[,list(id,v1)]
DT[DT1]
names(DT[J(id,v1)])
names(DT[DT1])
setkey(DT,id)#
names(DT[DT[,list(id,v1)]])
names(DT[list(id,v1)])
library(data.table)
library(dplyr)
N=1e8; K=100#
set.seed(1)#
DF <- data.frame(#
  id = 1:N,#
  v1 =  sample(round(runif(100,max=100),4), N, TRUE)                       #
)
rm(DF)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
DT1 <- DT[,names(DT),with=FALSE]
copy(DT,DT1)
library(pryr)
object_size(DT,DT1)
DT1 <-DT[5*1e7]
DT1 <-DT[1:(5*1e7)]
object_size(DT,DT1)
object_size(DT)
object_size(DT,DT1)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
library(data.table)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
   id = 1:N,#
   v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
system.time(DT1 <- DT[,c("id","v1")])
object_size(DT,DT1)
system.time(DT1 <- DT[,c("id","v1")])
object_size(DT,DT1)
library(plyr)
system.time(DT1 <- DT[,c("id","v1")])
object_size(DT,DT1)
library(pryr)
object_size(DT,DT1)
object_size(DT)
object_size(DT,DT1)
system.time(DT1 <- DT[,c("id")])
object_size(DT,DT1)
object_size(DT)
system.time(DT1 <- DT[,c("id","v1")])
object_size(DT,DT1)
DT
DT1
system.time(DT1 <- DT[,c("id","v1"),with=FALSE])
object_size(DT, DT1)
system.time(DT1 <- setDT(setDF(DT)[,c("id","v1")]))
object_size(DT, DT1)
library(dplyr)#
library(data.table)
DT1 <- DT %>% mutate(y=mean(v1))
N=1e8; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(round(runif(100,max=100),4), N, TRUE)                        #
)
DT1 <- DT %>% mutate(y=mean(v1))
object_size(DT,DT1)
library(pryr)
object_size(DT,DT1)
DT1 <- DT %>% select(v1)
object_size(DT,DT1)
DF1 <- DF %>% select(v1)#
object_size(DF,DF1)
library(pryr)
library(dplyr)#
library(data.table)#
#
N=1e8; K=100#
set.seed(1)#
DF <- data.frame(#
  id = 1:N,#
  v1 =  sample(round(runif(100,max=100),4), N, TRUE)                       #
)#
object_size(DF)#
1.2 GB#
DF1 <- DF %>% mutate(y=mean(v1))#
object_size(DF,DF1)#
2 GB#
DF1 <- DF %>% select(v1)#
object_size(DF,DF1)#
2 GB
names(DF1)
rm(ls())
rm(list=ls())
N=1e8; K=100#
set.seed(1)#
DF <- data.frame(#
  id = 1:N,#
  v1 =  sample(round(runif(100,max=100),4), N, TRUE)                       #
)#
object_size(DF)
DF1 <- DF %>% select(v1)
object_size(DF,DF1)
DT1<-DT[,list(id)]
setDT(DT)
setDT(DF)
DF1<-DT[,list(id)]
DF1<-DF[,list(id)]
object_size(DF,DF1)
object_size(DF)
library(data.table)
df1 <- data.frame(id = 1:10)#
f <- function(df){eval(substitute(setDT(df)),parent.frame())}#
f(df1)#
df1[, temp := 1]
df1
df <- data.frame(id = 1:10)#
f <- function(df){eval(substitute(setDT(df)),parent.frame())}#
f(df)#
df[, temp := 1]
df
df <- data.frame(id = 1:10)#
f <- function(df){eval(substitute(setDT(df)),parent.frame()); df[, temp := 1]}
f(df)
df
df1 <- data.frame(id = 1:10)#
f <- function(df){eval(substitute(setDT(df)),parent.frame()); df[, temp := 1]}
f(df1)
df1
df1 <- data.frame(id = 1:10)#
f <- function(df){#
      eval(substitute(setDT(df)),parent.frame())#
      df[, temp := 1]#
      }#
f(df1)
df1
library(dplyr)#
library(data.table)#
as.data.table(mtcars) %>% mutate(mean(1))#
mtcars %>% mutate(mean(1))
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
system.time( DT1 <- DT[,c("id","v1","v2"), with = FALSE] )#
object_size(DT,DT1)#
system.time( DT1 <- setDT(setDF(DT)[,c("id","v1","v2")]) ) #
system.time( setDT(DT)  )#
object_size(DT,DT1)
library(data.table)#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
system.time( DT1 <- DT[,c("id","v1","v2"), with = FALSE] )#
object_size(DT,DT1)#
system.time( DT1 <- setDT(setDF(DT)[,c("id","v1","v2")]) ) #
system.time( setDT(DT)  )#
object_size(DT,DT1)
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
system.time( DT1 <- DT[,c("id","v1","v2"), with = FALSE] )#
object_size(DT,DT1)#
system.time( DT1 <- setDT(setDF(DT)[,c("id","v1","v2")]) ) #
system.time( setDT(DT)  )#
object_size(DT,DT1)
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
object_size(DT[1:(.N-1)])
object_size(DT[1:(.N-1)],DT)
object_size(DT[1:.N/2],DT)
object_size(DT)
DT1 <- DT[1:.N/2]
object_size(DT,DT1)
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT1 <- DT[,c("id","v1","v2"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.N/2]#
object_size(DT,DT1)#
400 MB
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.N/2]#
object_size(DT,DT1)
DF1 <- DF[1:1e7/2]
setDF(DT)#
DT1 <- DT[,c("id","v1","v2")]) #
DT1 <- DT[1:1e7/2]
setDF(DT)#
DT1 <- DT[,c("id","v1","v2")]#
DT1 <- DT[1:1e7/2]
DT1 <- DT[1:(1e7/2)]
DT1 <- DT[1:(5e6)]
DT1 <- DT[1:(5e6),]
object_size(DT,DT1)
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
DT1 <- DT[,c("id","v1","v2")]#
object_size(DT,DT1)#
DT1 <- DT[1:(5e6),]#
object_size(DT,DT1)#
#
setDT(DT)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
DT1 <- DT[,c("id","v1","v2")]#
object_size(DT,DT1)#
#> 200#
DT1 <- DT[1:(5e6),]#
object_size(DT,DT1)#
#> 300#
#
setDT(DT)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
#> 400 MB#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)#
#> 210 MB
DT1 <- DT[1:.5e6,]
object_size(DT,DT1)#
210 MB
library(data.table)#
library(pryr)#
#
N=1e7; K=100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
DT1 <- DT[,c("id","v1","v2")]#
object_size(DT,DT1)#
#> 200 MB#
DT1 <- DT[1:(5e6),]#
object_size(DT,DT1)#
#> 300 MB#
#
setDT(DT)#
DT1 <- DT[,c("id","v1","v2","v3"), with = FALSE] #
object_size(DT,DT1)#
#> 400 MB#
DT1 <- DT[1:.5e6]#
object_size(DT,DT1)#
#> 210 MB
DT1
DT1 <- DT[,list(id,v1,v2,v3)] #
object_size(DT,DT1)
library(dplyr)
library(data.table)#
library(pryr)#
N = 1e7; K = 100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT1 <- DT %>% filter(v1>=3)
object_size(DT,DT1)
object_size(DT)
DT[v1==3,lm(v3~v2,.SD),.SDcols=names(DT)]
setDT(DT)
DT[v1==3,lm(v3~v2,.SD),.SDcols=names(DT)]
system.time(DT[v1==3,lm(v3~v2,.SD),.SDcols=names(DT)])
system.time(lm(v3~v2,DT[v1==3]))
system.time(DT[v1==3,lm(v3~v2,.SD),.SDcols=names(DT)])
library(data.table)#
library(pryr)#
N = 1e7; K = 100#
set.seed(1)#
DT <- data.frame(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
DT1 <- DT[1:(5e6),]#
object_size(DT, DT1)#
#> 300 MB#
#
setDT(DT)#
DT1 <- DT[1:.5e6]#
object_size(DT ,DT1)#
#> 210 MB
DT1 <- DT[3:.5e6]
object_size(DT,DT1)
library(dplyr)
?order_by
?lag
?lead
?break
break=function(x){x+2}
break <- function(x){x+2}
?separate
?culster
?cluster
devtools::document("/Users/Matthieu/Dropbox/github/statar-package")
#' lead and lag.#
#'#
#' lead and lag are useful for comparing values for date offset by a constant#
#' @param x a vector of values#
#' @param n a positive integer of length 1, giving the number of positions to lead or lag by#
#' @param order_by override the default ordering to use another vector#
#' @param along_with  compute lag with respect to this vector instead of previous row#
#' @param units computes lag in units of "day", "week", "month", "quarter" or "year" periods. Should be used when \code{along_with} is a date. #
#' @param default value used for non-existant rows. Defaults to \code{NA}.#
#' @examples#
#' # Unbalanced panel#
#' DT <- data.table(#
#'  id    = c(1, 1, 1, 1, 1, 2, 2),#
#'  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#' )#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, order_by = date)) # wrong#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, along_with = date)) # right#
#
#' # Units#
#' DT[, date := as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "08/21/1992"), "%m/%d/%Y")]#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, units = "month", along_with = date)) #
#' @name lead-lag#
NULL#
#
#' @export#
#' @rdname lead-lag#
lead <- function(x, n = 1L, order_by, along_with, units = NULL, default = NA, ...) {#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
#
  if (!is.null(order_by)) {#
       if (!is.null(along_with) | !is.null(units)) stop("order_by cannot be used with along_with or units")#
       return(dplyr::with_order(order_by, lead, x, n = n, default = default))#
  }#
  if (!is.null(units)) {#
    if (is.null(along_with)) stop("units cannot be used without along_with")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    along_with_origin <- as.along_with('0001-01-01')#
    if (unitsc=="day"){#
      return(lead(x = x, n = n, default = default, along_with = along))#
    }#
    if (unitsc == "week"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% weeks(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }  #
    else if (unitsc == "month"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% months(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "quarter"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% 3*months(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "year"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% years(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }#
  }#
#
  if (!is.null(along_with)) {#
    index <- match(along_with - n, along_with, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
  } else{#
    xlen <- length(x)#
    n <- pmin(n, xlen)#
    out <- c(x[-seq_len(n)], rep(default, n))#
  }#
  attributes(out) <- attributes(x)#
  out#
}#
#' @export#
#' @rdname lead-lag#
lag.default <- function(x, n = 1L, order_by, along_with, units = NULL, default = NA, ...) {#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
#
  if (!is.null(order_by)) {#
       if (!is.null(along_with) | !is.null(units)) stop("order_by cannot be used with along_with or units")#
       return(dplyr::with_order(order_by, lag, x, n = n, default = default))#
  }#
  if (!is.null(units)) {#
    if (is.null(along_with)) stop("units cannot be used without along_with")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    along_with_origin <- as.along_with('0001-01-01')#
    if (unitsc=="day"){#
      return(lag(x = x, n = n, default = default, along_with = along))#
    }#
    if (unitsc == "week"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% weeks(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }  #
    else if (unitsc == "month"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% months(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "quarter"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% 3*months(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "year"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% years(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }#
  }#
  if (!is.null(along_with)) {#
    index <- match(along_with + n, along_with, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
  } else{#
    xlen <- length(x)#
    n <- pmin(n, xlen)#
    out <- c(rep(default, n), x[seq_len(xlen - n)])#
  }#
  attributes(out) <- attributes(x)#
  out#
}
date <- as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "08/21/1992"), "%m/%d/%Y")
date
as.Date(c("03/01/1992", "04/03/1992", "07/15/1992", "08/21/1992"), "%m/%d/%Y")
#' lead and lag.#
#'#
#' lead and lag are useful for comparing values for date offset by a constant#
#' @param x a vector of values#
#' @param n a positive integer of length 1, giving the number of positions to lead or lag by#
#' @param order_by override the default ordering to use another vector#
#' @param along_with  compute lag with respect to this vector instead of previous row#
#' @param units computes lag in units of "day", "week", "month", "quarter" or "year" periods. Should be used when \code{along_with} is a date. #
#' @param default value used for non-existant rows. Defaults to \code{NA}.#
#' @examples#
#' # along_with#
#' DT <- data.table(#
#'  id    = c(1, 1, 1, 1, 1, 2, 2),#
#'  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#' )#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, order_by = date)) # wrong#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, along_with = date)) # right#
#
#' # units#
#' value <- c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#' date <- as.Date(c("03/01/1992", "04/03/1992", "07/15/1992", "08/21/1992"), "%m/%d/%Y")#
#' DT %>% group_by(id) %>% mutate(lag(value, 1, along_with = date, units = "month")) #
#' @name lead-lag#
NULL#
#
#' @export#
#' @rdname lead-lag#
lead <- function(x, n = 1L, order_by, along_with, units = NULL, default = NA, ...) {#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
#
  if (!is.null(order_by)) {#
       if (!is.null(along_with) | !is.null(units)) stop("order_by cannot be used with along_with or units")#
       return(dplyr::with_order(order_by, lead, x, n = n, default = default))#
  }#
  if (!is.null(units)) {#
    if (is.null(along_with)) stop("units cannot be used without along_with")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    along_with_origin <- as.along_with("0001-01-01")#
    if (unitsc=="day"){#
      return(lead(x = x, n = n, default = default, along_with = along))#
    }#
    if (unitsc == "week"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% weeks(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }  #
    else if (unitsc == "month"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% months(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "quarter"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% 3*months(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "year"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% years(1)#
      return(lead(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }#
  }#
#
  if (!is.null(along_with)) {#
    index <- match(along_with - n, along_with, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
  } else{#
    xlen <- length(x)#
    n <- pmin(n, xlen)#
    out <- c(x[-seq_len(n)], rep(default, n))#
  }#
  attributes(out) <- attributes(x)#
  out#
}#
#' @export#
#' @rdname lead-lag#
lag.default <- function(x, n = 1L, order_by, along_with, units = NULL, default = NA, ...) {#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
#
  if (!is.null(order_by)) {#
       if (!is.null(along_with) | !is.null(units)) stop("order_by cannot be used with along_with or units")#
       return(dplyr::with_order(order_by, lag, x, n = n, default = default))#
  }#
  if (!is.null(units)) {#
    if (is.null(along_with)) stop("units cannot be used without along_with")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    along_with_origin <- as.along_with("0001-01-01")#
    if (unitsc=="day"){#
      return(lag(x = x, n = n, default = default, along_with = along))#
    }#
    if (unitsc == "week"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% weeks(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }  #
    else if (unitsc == "month"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% months(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "quarter"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% 3*months(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    } else if (unitsc == "year"){#
      along_with_elapsed <- as.period(along_with-along_with_origin)  %/% years(1)#
      return(lag(x = x, n = n, default = default, along_with = along_with_elapsed))#
    }#
  }#
#
  if (!is.null(along_with)) {#
    index <- match(along_with + n, along_with, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
  } else{#
    xlen <- length(x)#
    n <- pmin(n, xlen)#
    out <- c(rep(default, n), x[seq_len(xlen - n)])#
  }#
  attributes(out) <- attributes(x)#
  out#
}
library(dplyr)
library(data.table)
df <- data.frame(#
   date = 1:N,#
   id =  sample(5, N, TRUE),   #
   value =  sample(1e6, N, TRUE)                   #
 )#
# This solution#
system.time(setDT(df)[, lag_value := lag(value, 1, along_with = date), by = id])#
#> user  system elapsed #
#> 0.186   0.007   0.157  #
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#> user  system elapsed #
#> 0.186   0.007   0.200 #
# pure data.table solution#
setDF(df)#
system.time(setkey(setDT(df), id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#> user  system elapsed #
#> 0.113   0.023   0.147 #
#
# pure dplyr solution#
setDF(df)#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#> user  system elapsed #
#> 1.148   0.057   1.197
N <- 2e6#
df <- data.frame(#
   date = 1:N,#
   id =  sample(5, N, TRUE),   #
   value =  sample(1e6, N, TRUE)                   #
 )#
# This solution#
system.time(setDT(df)[, lag_value := lag(value, 1, along_with = date), by = id])#
#> user  system elapsed #
#> 0.186   0.007   0.157  #
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#> user  system elapsed #
#> 0.186   0.007   0.200 #
# pure data.table solution#
setDF(df)#
system.time(setkey(setDT(df), id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#> user  system elapsed #
#> 0.113   0.023   0.147 #
#
# pure dplyr solution#
setDF(df)#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#> user  system elapsed #
#> 1.148   0.057   1.197
library(microbenchmark)
microbenchmark(setDT(df)[, lag_value := lag(value, 1, along_with = date), by = id],times=10L)
N <- 2e6#
    df <- data.frame(#
       date = 1:N,#
       id =  sample(5, N, TRUE),   #
       value =  sample(1e6, N, TRUE)                   #
     )#
    # This solution#
    microbenchmark(setDT(df)[, lag_value := lag(value, 1, along_with = date), by = id])#
    #> user  system elapsed #
    #> 0.186   0.007   0.157  #
    microbenchmark(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
    #> user  system elapsed #
    #> 0.186   0.007   0.200 #
    # pure data.table solution#
    setDF(df)#
    microbenchmark(setkey(setDT(df), id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
    #> user  system elapsed #
    #> 0.113   0.023   0.147 #
#
    # pure dplyr solution#
    setDF(df)#
    microbenchmark(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
    #> user  system elapsed #
    #> 1.148   0.057   1.197
# This solution#
    setDT(df)#
    microbenchmark(df[, lag_value := lag(value, 1, along_with = date), by = id])#
    #> user  system elapsed #
    #> 0.186   0.007   0.157  #
    setDF(df)#
    microbenchmark(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
    #> user  system elapsed #
    #> 0.186   0.007   0.200 #
    # pure data.table solution#
    setDT(df)#
    microbenchmark(setkey(df, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
    #> user  system elapsed #
    #> 0.113   0.023   0.147 #
#
    # pure dplyr solution#
    setDF(df)#
    microbenchmark(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
    #> user  system elapsed #
    #> 1.148   0.057   1.197
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
   }#
# This solution against pure data.table#
setDT(df)#
microbenchmark(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>      min       lq   median       uq      max neval#
#> 39.23331 45.63224 48.26503 51.30011 88.56598   100 #
microbenchmark(setkey(df, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>      min       lq   median       uq      max neval#
#> 162.0913 179.7229 191.2539 230.4258 1663.312   100
setDF(df)#
    microbenchmark(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
    #>      min       lq   median       uq      max neval#
    #> 97.22887 111.8242 121.0254 141.8194 1090.357   100#
#
    microbenchmark(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))
df
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>     min       lq   median       uq      max neval#
#> 98.4322 105.3136 110.1891 116.5764 320.0336   100#
df1 <- copy(df)#
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>      min       lq   median       uq      max neval#
#> 135.2102 145.7594 161.0235 188.1168 390.2336   100#
#
# This solution against pure dplyr#
setDF(df)#
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#>      min       lq   median       uq      max neval#
#> 92.40668 95.37822 99.20339 103.0889 140.8624   100#
#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#>      min       lq   median       uq      max neval#
#> 2.422102 3.071185 3.281669 3.631934 4.818416   100
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>   user  system elapsed #
#>  0.094   0.007   0.103 #
df1 <- copy(df)#
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>   user  system elapsed #
#>  0.201   0.026   0.228 #
#
# This solution against pure dplyr#
setDF(df)#
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#>   user  system elapsed #
#>  0.156   0.028   0.186 #
#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#>   user  system elapsed #
#>  3.301   0.086   3.363
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ]))
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
setDT(df)
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>   user  system elapsed #
#>  0.094   0.007   0.103 #
df1 <- copy(df)#
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>   user  system elapsed #
#>  0.201   0.026   0.228 #
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>   user  system elapsed #
#>  0.094   0.007   0.103 #
df1 <- copy(df)#
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])#
#>   user  system elapsed #
#>  0.201   0.026   0.228
all.equal(df[, lag_value := lag(value, 1, along_with = date), by = id],setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
all.equal(setkey(df),df1)
all.equal(setkey(df,id,date),df1)
all.equal(setkey(df[, lag_value := lag(value, 1, along_with = date), by = id],id,date),setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
df1<- setkey(df[, lag_value := lag(value, 1, along_with = date), by = id],id,date)
df2<- setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
df2<- setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ]
df1
df2
dfdf1[!is.na(value_lagged)]
df1[!is.na(value_lagged)]
df[!is.na(value_lagged)]
lag <- function(x, n = 1L, along_with){#
 index <- match(along_with - n, along_with, incomparable = NA)#
 out <- x[index]#
 attributes(out) <- attributes(x)#
 out#
}
N <- 2e6#
df <- data.frame(#
         date = 1:N,#
           id = sample(100, N, TRUE),   #
        value = sample(1e6, N, TRUE)                   #
      )#
# This solution against pure data.table#
setDT(df)#
system.time(df[, lag_value := lag(value, 1, along_with = date), by = id])#
#>   user  system elapsed #
#>  0.094   0.007   0.103 #
df1 <- copy(df)
system.time(setkey(df1, id, date)[J(id, date + 1, val = value), value_lagged := i.val, ][is.na(date), value_lagged := NA, ])
setDF(df)#
system.time(mutate(group_by(df, id), lag_value = lag(value, 1, along_with = date)))#
#>   user  system elapsed #
#>  0.156   0.028   0.186 #
#
system.time(left_join(df, mutate(filter(df, !is.na(date)),  date = date + 1, lagged_value = value, value = NULL)))#
#>   user  system elapsed #
#>  3.301   0.086   3.363
?biglm
library(biglm)
install.packages("biglm")
?biglm
library(biglm)
?biglm
FALSE && NA
true || NA
TRUE || NA
library(tidyr)
library(statar)
df <- data.frame (id=c(1,1), variable = c("v1","v1"), value = c(1,3))
df
spread(df, variable, value)
dt <- as.data.table(df)
dt <- data.table(df)
library(data.table)
dt <- as.data.table(df)
spread(df, variable, value)
spread(dt, variable, value)
library(tidyr)
?expand
devtools::install_github("hadley/tidyr")
f <-function(){#
on.exit(print("salut"))#
}
f(1)
f()
library(tidyr)
devtools::install_github("hadley/tidyr")
library(tidyr)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Create unique names within environment#
#'#
#' @param prefix A character vector that specifies prefix for new name#
#' @param where A list or an environment#
#' @param inherits  Should the name unique also in the enclosing frames of the environment?#
#' @param n Number of names to generate#
#' @examples#
#' tempname <- tempname("temp", globalenv())#
#' tempname <- tempname("temp", DT )#
#' tempname <- tempname("temp", list = c("temp", "temp1"))#
#
#' @export#
tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
    i <- 0L#
    out <- NULL#
    name <- prefix#
    if (!is.null(list)){#
        while (name %in% l) {#
            i <- i + 1L#
            name <- paste0(prefix, as.character(i))#
            }#
    } else{#
    	while (exists(name, where = where, inherits = inherits)){#
            i <- i + 1L#
    	   name <- paste0(prefix, as.character(i))#
	   }#
    }#
    name#
}#
#
assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
    names <- sapply(lazy_dots(...), function(x){as.character(x$expr)})#
    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
}#
#
assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
    for (name in names){#
        tempname <- tempname(paste("temp",name,sep="_"), where = env, inherits = inherits)#
        assign(name, tempname, env)#
    }#
}#
#
evaldt <- function(x, env = parent.frame()){#
    x <- substitute(x)#
    names <- ls(all.names = TRUE, envir = env)#
    L <- NULL#
    names_l <- NULL#
    for (name in names){#
        if (exists(name, envir = env, inherits = FALSE, mode = "character")){#
            get_name <- get(name, envir = env)#
            if (length(get_name)){#
                L <- c(L, as.name(get_name))#
                names_l <- c(names_l, name)#
            }#
        }#
    }#
    names(L) <- names_l#
    # replace names, even in LHS of list#
    replace_name <- function(x, lenv, env){#
        i <- 0#
        if (is.atomic(x) | is.symbol(x)){#
            if (str_detect(as.character(x),"*\\.")){#
                xx <- str_replace(as.character(x),".","")#
                if (exists(xx, envir = env, inherits = FALSE, mode = "character")){#
                    return(as.name(get(xx, envir = env)))#
                } else{#
                  return(x)#
                }#
            } else{#
                return(x)#
            }#
        }#
        else{#
            out <- NULL#
            for (i in 1:length(x)){#
                if (!is.null(x[[i]])){#
                    x[[i]] <- replace_name(x[[i]], lenv, env)#
                }#
            }#
            names <- NULL#
            if (x[[1]] == quote(list)){#
                for (name in names(x)){#
                    if (str_detect(name,"\\.")) {#
                        namename <- str_replace(as.character(x),".","")#
                        if (exists(namename, envir = env, inherits = FALSE, mode = "character")){#
                            names <- c(names, get(namename, pos = lenv))#
                        } else{#
                            names <- c(names, name)#
                        }#
                    } #
                    else{#
                        names <- c(names, name)#
                    }#
                }#
                names(x) <- names#
            }#
        }#
        x#
    }#
    print(as.list(L))#
    call <- replace_name(x, as.list(L), env = env)#
    print(call)#
    eval(call, env)#
}#
#
#get("id", pos = DT)#
#
#Using data.table x inside a program can be cumbersom, the following steps are needed :#
#- Create a string that does not  exist in names(x) #
#- eval(substitute() at every line, with a list composed of all the temporary variables created#
#- Since `eval(substitute())` does not replace LHS in DT[, list(id = sum(v1)], I have to either #modify the call  or use setnames after the command#
##
#There may be things I do wrongly, but all these steps makes programming cumbersome. So I have #thought of the following convenient functions:#
##
#- a function assign_var (dt,v) that creates a binding from v to a symbol (corresponding to a #name that does not exist in data.table)#
#- A function evaldt, that captures the argument, and replace every name bounded to a symbol by #the symbol. Compared to eval(substitute()) it automatically generates the list constituted #of variables that are binded to symbols, and it also replaces the lhs of a list (for #instance v in list(v="ok")).#
##
#So this is how it works fora function that filter a condition within each group#
#````#
#rm(list =ls())#
#N <- 2e6#
#DT <- data.table(#
#  id = 1:N,#
#  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
#  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
#  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
#)#
#I#
#f <- function(DT,condition, by ){#
# # assignnments#
#  condition = substitute(condition)#
#  by = substitute(by) #
#  assign_var(DT,tag)#
## same command than in interactive mode, except evaldt in front of it#
# evaldt(DT[DT[, list(tag = .I[condition]), by = by ]$tag])#
#}#
##
#I guess my this is neither directly a pull or a feature request, but I was looking for general #opinion on whether this is a good  way to use data.table within a function#
##
#The code of assgn_var is below functions is below #
#````R#
#tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
#    i <- 0L#
#    out <- NULL#
#    name <- prefix#
#    if (!is.null(list)){#
#        while (name %in% l) {#
#            i <- i + 1L#
#            name <- paste0(prefix, as.character(i))#
#            }#
#    } else{#
#        while (exists(name, where = where, inherits = inherits)){#
#            i <- i + 1L#
#           name <- paste0(prefix, as.character(i))#
#       }#
#    }#
#    name#
#}#
##
#assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
#    names <-   as.character(substitute(list(...))[-1])#
#    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
#}#
##
#assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
#    for (name in names){#
#        tempname <- paste("temp",name,sep="_")#
#        assign(name, as.name(tempname), envir = env)#
#    }#
#}#
##
#evaldt <- function(x, env = parent.frame()){#
#    x <- substitute(x)#
#    names <- ls(all.names = TRUE, envir = env)#
#    L <- NULL#
#    names_l <- NULL#
#    for (name in names){#
#        if (exists(name, env, inherits = FALSE, mode = "language") | exists(name, env, inherits #= FALSE, mode = "symbol")) {#
#            L <- c(L, get(name, envir = env))#
#            names_l <- c(names_l, name)#
#        }#
#    }#
#    names(L) <- names_l#
#    # replace names, even in LHS of list#
#    replace_name <- function(x, lenv){#
#        i <- 0#
#        if ((is.atomic(x)) | (is.symbol(x))){#
#            call <- substitute(substitute(y, lenv), list(y = x))#
#            return(eval(call))#
#        }#
#        else{#
#            out <- NULL#
#            for (i in 1:length(x)){#
#                if (!is.null(x[[i]])){#
#                    x[[i]] <- replace_name(x[[i]], lenv)#
#                }#
#            }#
#            names <- NULL#
#            if (x[[1]] == quote(list)){#
#                for (name in names(x)){#
#                    if ((name!="") && (exists(name, lenv))) {#
#                            names <- c(names, as.character(get(name, pos = lenv)))#
#                    } #
#                    else{#
#                        names <- c(names, name)#
#                    }#
#                }#
#                names(x) <- names#
#            }#
#        }#
#        x#
#    }#
#    call <- replace_name(x, as.list(L))#
#    eval(call, env)#
#}#
#````
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Experimental function to graph a dataset#
#' #
#' @param x A data.table.#
#' @param ... Variables to include. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param along_with Replace x axis by this variable (ie estimate regression models instead of density).#
#' @param by Groups within which variables should be ploted.#
#' @param reorder Should the category with the most count be printed first?#
#' @param facet Should different groups graphed in different windows?#
#' @param size Size of points when more than 1000 points by group#
#' @param winsorize Should variables winsorized?#
#' @param method A character for regression model (lm, loess) when along_with is specified#
#' @param verbose Should warnings (regarding missing values, outliers, etc) be printed?#
#' @examples#
#' N <- 10000#
#' DT <- data.table(#
#'   id = sample(c("id1","id2","id3"), N, TRUE),#
#'   v1 = sample(c(1:5), N, TRUE),#
#'   v2 = rnorm(N, sd = 20),#
#'   v3 = sample(runif(100, max=100), N, TRUE)#
#' )#
#' DT[, v4 := v3 + rnorm(N, sd = 20)]#
#' graph(DT)#
#' graph(DT, by = id)#
#' graph(DT, by = id, facet = TRUE)#
#' graph(DT, v3, v4, along_with = v2)#
#' graph(DT, v3, v4, along_with = v2, by = id)#
#' @export#
graph <- function(x, ..., along_with = NULL, by = NULL, w = NULL, reorder = TRUE, winsorize = TRUE, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  graph_(x, .dots = lazy_dots(...) , along_with = substitute(along_with), by = substitute(by), w = substitute(w), d = d, reorder = reorder, winsorize = winsorize, facet = facet, size = size, verbose = verbose, method = method)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots , along_with = NULL, by = NULL, w = NULL, d = FALSE, reorder = TRUE, winsorize = winsorize, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x),w))#
  along_with <- names(select_vars_(names(x), along_with))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = c(byvars,w,along_with)))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars, along_with, w))#
  }#
  if (length(along_with)){#
    nums <- sapply(x, is.numeric)#
    nums_name <- names(nums[nums==TRUE])#
    vars = intersect(vars,nums_name)#
  }#
  name_list <- function(x){#
    if (length(x)){#
      x <- sapply(x, as.name)#
    }#
    unlist(x)#
  }#
#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
  assign_var(x, bin, group)#
#
  x <- x[, c(byvars, vars, along_with, w), with = FALSE]#
  if (!length(w)){#
    assign_var(x, w)#
    evaldt(x[, .w := 1])#
    ww <- NULL#
  } else{#
    ww <- as.name(paste0(w,"/sum(",w,")"))#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
        if (length(along_with)){#
          ans <- x[, list(.along_with, .v, .w)]#
          nums <- sapply(x, is.numeric)#
          nums_name <- names(nums[nums==TRUE])#
          vars=intersect(vars,nums_name)#
          if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
            if (winsorize){#
              evaldt(ans[, .v := winsorize(.v, verbose = verbose)])#
              evaldt(ans[, .along_with:= winsorize(.along_with, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.along_with, breaks = seq(min(.along_with, na.rm = TRUE), max(.along_with, na.rm = TRUE), length = 20))])#
            evaldt(N <- ans[, sum(.w)])#
            ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  w, na.rm = TRUE)), by = bin])#
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + stat_smooth(method = method) + geom_point(data=ans2, aes_string(x = along_with, y = v)) #
        } else{#
        ans <- evaldt(x[, list(.v, .w)])#
        print(ans)#
        dummy <- evaldt(is.integer(ans[,v]) + is.character(ans[,v]))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(weight = ww, x = v)) + geom_point(stat="bin")+ coord_flip()#
            } else{#
              print(ans)#
              ans <- evaldt(ans[, list(.w, N = .N), by = .v])#
              setkeyv(and,"N", v)#
              ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
              print(ans)#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_point(stat="bin") + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans[, .v:= winsorize(.v, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.v, breaks = seq(min(.v, na.rm = TRUE), max(.v, na.rm = TRUE), length = 100))])#
            evaldt(N <- ans[, sum(.w)])#
            ans <- evaldt( ans[, list(.v = mean(.v), count = sum(.w / N, na.rm = TRUE)), by = (bin)])#
            # g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line")#
             g[[i]] <-  ggplot(ans, aes_string(x = v, y= "count")) + geom_point()#
          }#
        }#
      } #
  } else{#
    if (length(byvars)>1){#
      setkeyv(x, byvars)#
      x[, .group := 0]#
      x[unique(x), .group := 1]#
      evaldt(x[, .group:= cumsum(.v)])#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        ans <- x[, c(byvars, v, w, along_with), with = FALSE]#
        i <- i+1#
        if (length(along_with)){#
          if (winsorize){#
            evaldt(ans <- ans[, list(.group, winsorize(.along_with, verbose = verbose), winsorize(.v, verbose = verbose), ,w)])#
            setnames(ans, c(group, along_with, v, w))#
          } else{#
            evaldtdt(ans <- ans[, list(.group, .along_with, .v, .w)])#
          }#
          evaldt(ans[, .bin := .bincode(along_with, breaks = seq(min(along_with, na.rm = TRUE), max(along_with, na.rm = TRUE), length = 20))])#
          evaldt(N <- ans[, sum(w)])#
          ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  .w, na.rm = TRUE), .group), by = list(.group, .bin)])#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans2[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v, color = group)) + geom_point(data = ans2, aes_string(x = along_with, y = v, color = group), alpha = 0.6) + stat_smooth(method = method)#
            } else{#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + geom_point(data = ans2, aes_string(weight = ww, x = along_with, y = v), size = size) + stat_smooth(method = method) + facet_grid(as.formula(paste0(group, "~.")))#
            } #
        } else{#
          dummy <- evaldt(is.integer(ans[,v])+ is.character(ans[,v]))#
          if (dummy) {#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans[, .v:= as.factor(.v)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, fill = group)) + geom_bar(width=.5,position = "dodge")+ coord_flip() #
            } else{#
              if (!reorder){#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5)+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
              } else{#
                  ans <- evaldt(ans[, list(N = as.integer(rep(.N,.N)), .w = as.name(.w)), by = c(.group,.v)])#
                  setkeyv(ans, c(group, "N",v))#
                  ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5) + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))                 #
              }#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans <- ans[, list(.group, .w, .v = winsorize(.v, verbose = verbose))])#
            } #
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, color = group)) + stat_density(geom = "line", position = "identity")#
            } else{            #
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line") + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          }#
        }#
      } #
  }#
  if (length(g)==1){#
    if (verbose){#
      print(g[[1]])#
    } else{#
      suppressWarnings(suppressMessages(print(g[[1]])))#
    }#
  } else{#
    if (verbose){#
      do.call(multiplot, g)#
    }#
    suppressWarnings(suppressMessages(do.call(multiplot, g)))#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT)
library(data.table)
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT)
library(dplyr)
setwd("/Users/Matthieu/Dropbox/Symlink")#
devtools::install_github("matthieugomez/statar")#
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
suppressMessages(library("biglm"))#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))#
assignInNamespace("cedta.override",#
                  c(data.table:::cedta.override,"IRkernel"),#
                  "data.table")
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Create unique names within environment#
#'#
#' @param prefix A character vector that specifies prefix for new name#
#' @param where A list or an environment#
#' @param inherits  Should the name unique also in the enclosing frames of the environment?#
#' @param n Number of names to generate#
#' @examples#
#' tempname <- tempname("temp", globalenv())#
#' tempname <- tempname("temp", DT )#
#' tempname <- tempname("temp", list = c("temp", "temp1"))#
#
#' @export#
tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
    i <- 0L#
    out <- NULL#
    name <- prefix#
    if (!is.null(list)){#
        while (name %in% l) {#
            i <- i + 1L#
            name <- paste0(prefix, as.character(i))#
            }#
    } else{#
    	while (exists(name, where = where, inherits = inherits)){#
            i <- i + 1L#
    	   name <- paste0(prefix, as.character(i))#
	   }#
    }#
    name#
}#
#
assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
    names <- sapply(lazy_dots(...), function(x){as.character(x$expr)})#
    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
}#
#
assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
    for (name in names){#
        tempname <- tempname(paste("temp",name,sep="_"), where = env, inherits = inherits)#
        assign(name, tempname, env)#
    }#
}#
#
evaldt <- function(x, env = parent.frame()){#
    x <- substitute(x)#
    names <- ls(all.names = TRUE, envir = env)#
    L <- NULL#
    names_l <- NULL#
    for (name in names){#
        if (exists(name, envir = env, inherits = FALSE, mode = "character")){#
            get_name <- get(name, envir = env)#
            if (length(get_name)){#
                L <- c(L, as.name(get_name))#
                names_l <- c(names_l, name)#
            }#
        }#
    }#
    names(L) <- names_l#
    # replace names, even in LHS of list#
    replace_name <- function(x, lenv, env){#
        i <- 0#
        if (is.atomic(x) | is.symbol(x)){#
            if (str_detect(as.character(x),"*\\.")){#
                xx <- str_replace(as.character(x),".","")#
                if (exists(xx, envir = env, inherits = FALSE, mode = "character")){#
                    return(as.name(get(xx, envir = env)))#
                } else{#
                  return(x)#
                }#
            } else{#
                return(x)#
            }#
        }#
        else{#
            out <- NULL#
            for (i in 1:length(x)){#
                if (!is.null(x[[i]])){#
                    x[[i]] <- replace_name(x[[i]], lenv, env)#
                }#
            }#
            names <- NULL#
            if (x[[1]] == quote(list)){#
                for (name in names(x)){#
                    if (str_detect(name,"\\.")) {#
                        namename <- str_replace(as.character(x),".","")#
                        if (exists(namename, envir = env, inherits = FALSE, mode = "character")){#
                            names <- c(names, get(namename, pos = lenv))#
                        } else{#
                            names <- c(names, name)#
                        }#
                    } #
                    else{#
                        names <- c(names, name)#
                    }#
                }#
                names(x) <- names#
            }#
        }#
        x#
    }#
    print(as.list(L))#
    call <- replace_name(x, as.list(L), env = env)#
    print(call)#
    eval(call, env)#
}#
#
#get("id", pos = DT)#
#
#Using data.table x inside a program can be cumbersom, the following steps are needed :#
#- Create a string that does not  exist in names(x) #
#- eval(substitute() at every line, with a list composed of all the temporary variables created#
#- Since `eval(substitute())` does not replace LHS in DT[, list(id = sum(v1)], I have to either #modify the call  or use setnames after the command#
##
#There may be things I do wrongly, but all these steps makes programming cumbersome. So I have #thought of the following convenient functions:#
##
#- a function assign_var (dt,v) that creates a binding from v to a symbol (corresponding to a #name that does not exist in data.table)#
#- A function evaldt, that captures the argument, and replace every name bounded to a symbol by #the symbol. Compared to eval(substitute()) it automatically generates the list constituted #of variables that are binded to symbols, and it also replaces the lhs of a list (for #instance v in list(v="ok")).#
##
#So this is how it works fora function that filter a condition within each group#
#````#
#rm(list =ls())#
#N <- 2e6#
#DT <- data.table(#
#  id = 1:N,#
#  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
#  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
#  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
#)#
#I#
#f <- function(DT,condition, by ){#
# # assignnments#
#  condition = substitute(condition)#
#  by = substitute(by) #
#  assign_var(DT,tag)#
## same command than in interactive mode, except evaldt in front of it#
# evaldt(DT[DT[, list(tag = .I[condition]), by = by ]$tag])#
#}#
##
#I guess my this is neither directly a pull or a feature request, but I was looking for general #opinion on whether this is a good  way to use data.table within a function#
##
#The code of assgn_var is below functions is below #
#````R#
#tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
#    i <- 0L#
#    out <- NULL#
#    name <- prefix#
#    if (!is.null(list)){#
#        while (name %in% l) {#
#            i <- i + 1L#
#            name <- paste0(prefix, as.character(i))#
#            }#
#    } else{#
#        while (exists(name, where = where, inherits = inherits)){#
#            i <- i + 1L#
#           name <- paste0(prefix, as.character(i))#
#       }#
#    }#
#    name#
#}#
##
#assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
#    names <-   as.character(substitute(list(...))[-1])#
#    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
#}#
##
#assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
#    for (name in names){#
#        tempname <- paste("temp",name,sep="_")#
#        assign(name, as.name(tempname), envir = env)#
#    }#
#}#
##
#evaldt <- function(x, env = parent.frame()){#
#    x <- substitute(x)#
#    names <- ls(all.names = TRUE, envir = env)#
#    L <- NULL#
#    names_l <- NULL#
#    for (name in names){#
#        if (exists(name, env, inherits = FALSE, mode = "language") | exists(name, env, inherits #= FALSE, mode = "symbol")) {#
#            L <- c(L, get(name, envir = env))#
#            names_l <- c(names_l, name)#
#        }#
#    }#
#    names(L) <- names_l#
#    # replace names, even in LHS of list#
#    replace_name <- function(x, lenv){#
#        i <- 0#
#        if ((is.atomic(x)) | (is.symbol(x))){#
#            call <- substitute(substitute(y, lenv), list(y = x))#
#            return(eval(call))#
#        }#
#        else{#
#            out <- NULL#
#            for (i in 1:length(x)){#
#                if (!is.null(x[[i]])){#
#                    x[[i]] <- replace_name(x[[i]], lenv)#
#                }#
#            }#
#            names <- NULL#
#            if (x[[1]] == quote(list)){#
#                for (name in names(x)){#
#                    if ((name!="") && (exists(name, lenv))) {#
#                            names <- c(names, as.character(get(name, pos = lenv)))#
#                    } #
#                    else{#
#                        names <- c(names, name)#
#                    }#
#                }#
#                names(x) <- names#
#            }#
#        }#
#        x#
#    }#
#    call <- replace_name(x, as.list(L))#
#    eval(call, env)#
#}#
#````
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT,v1)
d<-3
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT,v1)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Experimental function to graph a dataset#
#' #
#' @param x A data.table.#
#' @param ... Variables to include. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param along_with Replace x axis by this variable (ie estimate regression models instead of density).#
#' @param by Groups within which variables should be ploted.#
#' @param reorder Should the category with the most count be printed first?#
#' @param facet Should different groups graphed in different windows?#
#' @param size Size of points when more than 1000 points by group#
#' @param winsorize Should variables winsorized?#
#' @param method A character for regression model (lm, loess) when along_with is specified#
#' @param verbose Should warnings (regarding missing values, outliers, etc) be printed?#
#' @examples#
#' N <- 10000#
#' DT <- data.table(#
#'   id = sample(c("id1","id2","id3"), N, TRUE),#
#'   v1 = sample(c(1:5), N, TRUE),#
#'   v2 = rnorm(N, sd = 20),#
#'   v3 = sample(runif(100, max=100), N, TRUE)#
#' )#
#' DT[, v4 := v3 + rnorm(N, sd = 20)]#
#' graph(DT)#
#' graph(DT, by = id)#
#' graph(DT, by = id, facet = TRUE)#
#' graph(DT, v3, v4, along_with = v2)#
#' graph(DT, v3, v4, along_with = v2, by = id)#
#' @export#
graph <- function(x, ..., along_with = NULL, by = NULL, w = NULL, reorder = TRUE, winsorize = TRUE, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  graph_(x, .dots = lazy_dots(...) , along_with = substitute(along_with), by = substitute(by), w = substitute(w), d = d, reorder = reorder, winsorize = winsorize, facet = facet, size = size, verbose = verbose, method = method)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots , along_with = NULL, by = NULL, w = NULL, d = FALSE, reorder = TRUE, winsorize = winsorize, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x),w))#
  along_with <- names(select_vars_(names(x), along_with))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = c(byvars,w,along_with)))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars, along_with, w))#
  }#
  if (length(along_with)){#
    nums <- sapply(x, is.numeric)#
    nums_name <- names(nums[nums==TRUE])#
    vars = intersect(vars,nums_name)#
  }#
  name_list <- function(x){#
    if (length(x)){#
      x <- sapply(x, as.name)#
    }#
    unlist(x)#
  }#
#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
  assign_var(x, bin, group)#
#
  x <- x[, c(byvars, vars, along_with, w), with = FALSE]#
  if (!length(w)){#
    assign_var(x, w)#
    evaldt(x[, .w := 1])#
    ww <- NULL#
  } else{#
    ww <- as.name(paste0(w,"/sum(",w,")"))#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
        if (length(along_with)){#
          ans <- x[, list(.along_with, .v, .w)]#
          nums <- sapply(x, is.numeric)#
          nums_name <- names(nums[nums==TRUE])#
          vars=intersect(vars,nums_name)#
          if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
            if (winsorize){#
              evaldt(ans[, .v := winsorize(.v, verbose = verbose)])#
              evaldt(ans[, .along_with:= winsorize(.along_with, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.along_with, breaks = seq(min(.along_with, na.rm = TRUE), max(.along_with, na.rm = TRUE), length = 20))])#
            evaldt(N <- ans[, sum(.w)])#
            ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  w, na.rm = TRUE)), by = bin])#
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + stat_smooth(method = method) + geom_point(data=ans2, aes_string(x = along_with, y = v)) #
        } else{#
        ans <- evaldt(x[, list(.v, .w)])#
        print(ans)#
        dummy <- evaldt(is.integer(ans[,v]) + is.character(ans[,v]))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(weight = ww, x = v)) + geom_point(stat="bin")+ coord_flip()#
            } else{#
              print(ans)#
              ans <- evaldt(ans[, list(.w, N = .N), by = .v])#
              setkeyv(ans,"N", v)#
              ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
              print(ans)#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_point(stat="bin") + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans[, .v:= winsorize(.v, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.v, breaks = seq(min(.v, na.rm = TRUE), max(.v, na.rm = TRUE), length = 100))])#
            evaldt(N <- ans[, sum(.w)])#
            ans <- evaldt( ans[, list(.v = mean(.v), count = sum(.w / N, na.rm = TRUE)), by = (bin)])#
            # g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line")#
             g[[i]] <-  ggplot(ans, aes_string(x = v, y= "count")) + geom_point()#
          }#
        }#
      } #
  } else{#
    if (length(byvars)>1){#
      setkeyv(x, byvars)#
      x[, .group := 0]#
      x[unique(x), .group := 1]#
      evaldt(x[, .group:= cumsum(.v)])#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        ans <- x[, c(byvars, v, w, along_with), with = FALSE]#
        i <- i+1#
        if (length(along_with)){#
          if (winsorize){#
            evaldt(ans <- ans[, list(.group, winsorize(.along_with, verbose = verbose), winsorize(.v, verbose = verbose), ,w)])#
            setnames(ans, c(group, along_with, v, w))#
          } else{#
            evaldtdt(ans <- ans[, list(.group, .along_with, .v, .w)])#
          }#
          evaldt(ans[, .bin := .bincode(along_with, breaks = seq(min(along_with, na.rm = TRUE), max(along_with, na.rm = TRUE), length = 20))])#
          evaldt(N <- ans[, sum(w)])#
          ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  .w, na.rm = TRUE), .group), by = list(.group, .bin)])#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans2[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v, color = group)) + geom_point(data = ans2, aes_string(x = along_with, y = v, color = group), alpha = 0.6) + stat_smooth(method = method)#
            } else{#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + geom_point(data = ans2, aes_string(weight = ww, x = along_with, y = v), size = size) + stat_smooth(method = method) + facet_grid(as.formula(paste0(group, "~.")))#
            } #
        } else{#
          dummy <- evaldt(is.integer(ans[,v])+ is.character(ans[,v]))#
          if (dummy) {#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans[, .v:= as.factor(.v)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, fill = group)) + geom_bar(width=.5,position = "dodge")+ coord_flip() #
            } else{#
              if (!reorder){#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5)+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
              } else{#
                  ans <- evaldt(ans[, list(N = as.integer(rep(.N,.N)), .w = as.name(.w)), by = c(.group,.v)])#
                  setkeyv(ans, c(group, "N",v))#
                  ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5) + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))                 #
              }#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans <- ans[, list(.group, .w, .v = winsorize(.v, verbose = verbose))])#
            } #
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, color = group)) + stat_density(geom = "line", position = "identity")#
            } else{            #
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line") + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          }#
        }#
      } #
  }#
  if (length(g)==1){#
    if (verbose){#
      print(g[[1]])#
    } else{#
      suppressWarnings(suppressMessages(print(g[[1]])))#
    }#
  } else{#
    if (verbose){#
      do.call(multiplot, g)#
    }#
    suppressWarnings(suppressMessages(do.call(multiplot, g)))#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT,v1)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Experimental function to graph a dataset#
#' #
#' @param x A data.table.#
#' @param ... Variables to include. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param along_with Replace x axis by this variable (ie estimate regression models instead of density).#
#' @param by Groups within which variables should be ploted.#
#' @param reorder Should the category with the most count be printed first?#
#' @param facet Should different groups graphed in different windows?#
#' @param size Size of points when more than 1000 points by group#
#' @param winsorize Should variables winsorized?#
#' @param method A character for regression model (lm, loess) when along_with is specified#
#' @param verbose Should warnings (regarding missing values, outliers, etc) be printed?#
#' @examples#
#' N <- 10000#
#' DT <- data.table(#
#'   id = sample(c("id1","id2","id3"), N, TRUE),#
#'   v1 = sample(c(1:5), N, TRUE),#
#'   v2 = rnorm(N, sd = 20),#
#'   v3 = sample(runif(100, max=100), N, TRUE)#
#' )#
#' DT[, v4 := v3 + rnorm(N, sd = 20)]#
#' graph(DT)#
#' graph(DT, by = id)#
#' graph(DT, by = id, facet = TRUE)#
#' graph(DT, v3, v4, along_with = v2)#
#' graph(DT, v3, v4, along_with = v2, by = id)#
#' @export#
graph <- function(x, ..., along_with = NULL, by = NULL, w = NULL, reorder = TRUE, winsorize = TRUE, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  graph_(x, .dots = lazy_dots(...) , along_with = substitute(along_with), by = substitute(by), w = substitute(w), d = d, reorder = reorder, winsorize = winsorize, facet = facet, size = size, verbose = verbose, method = method)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots , along_with = NULL, by = NULL, w = NULL, d = FALSE, reorder = TRUE, winsorize = winsorize, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x),w))#
  along_with <- names(select_vars_(names(x), along_with))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = c(byvars,w,along_with)))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars, along_with, w))#
  }#
  if (length(along_with)){#
    nums <- sapply(x, is.numeric)#
    nums_name <- names(nums[nums==TRUE])#
    vars = intersect(vars,nums_name)#
  }#
  name_list <- function(x){#
    if (length(x)){#
      x <- sapply(x, as.name)#
    }#
    unlist(x)#
  }#
#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
  assign_var(x, bin, group)#
#
  x <- x[, c(byvars, vars, along_with, w), with = FALSE]#
  if (!length(w)){#
    assign_var(x, w)#
    evaldt(x[, .w := 1])#
    ww <- NULL#
  } else{#
    ww <- as.name(paste0(w,"/sum(",w,")"))#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
        if (length(along_with)){#
          ans <- x[, list(.along_with, .v, .w)]#
          nums <- sapply(x, is.numeric)#
          nums_name <- names(nums[nums==TRUE])#
          vars=intersect(vars,nums_name)#
          if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
            if (winsorize){#
              evaldt(ans[, .v := winsorize(.v, verbose = verbose)])#
              evaldt(ans[, .along_with:= winsorize(.along_with, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.along_with, breaks = seq(min(.along_with, na.rm = TRUE), max(.along_with, na.rm = TRUE), length = 20))])#
            evaldt(N <- ans[, sum(.w)])#
            ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  w, na.rm = TRUE)), by = bin])#
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + stat_smooth(method = method) + geom_point(data=ans2, aes_string(x = along_with, y = v)) #
        } else{#
        ans <- evaldt(x[, list(.v, .w)])#
        print(ans)#
        dummy <- evaldt(is.integer(ans[,v]) + is.character(ans[,v]))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(weight = ww, x = v)) + geom_point(stat="bin")+ coord_flip()#
            } else{#
              print(ans)#
              ans <- evaldt(ans[, list(.w, N = .N), by = .v])#
              setkeyv(ans,c("N", v))#
              ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
              print(ans)#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_point(stat="bin") + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans[, .v:= winsorize(.v, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.v, breaks = seq(min(.v, na.rm = TRUE), max(.v, na.rm = TRUE), length = 100))])#
            evaldt(N <- ans[, sum(.w)])#
            ans <- evaldt( ans[, list(.v = mean(.v), count = sum(.w / N, na.rm = TRUE)), by = (bin)])#
            # g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line")#
             g[[i]] <-  ggplot(ans, aes_string(x = v, y= "count")) + geom_point()#
          }#
        }#
      } #
  } else{#
    if (length(byvars)>1){#
      setkeyv(x, byvars)#
      x[, .group := 0]#
      x[unique(x), .group := 1]#
      evaldt(x[, .group:= cumsum(.v)])#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        ans <- x[, c(byvars, v, w, along_with), with = FALSE]#
        i <- i+1#
        if (length(along_with)){#
          if (winsorize){#
            evaldt(ans <- ans[, list(.group, winsorize(.along_with, verbose = verbose), winsorize(.v, verbose = verbose), ,w)])#
            setnames(ans, c(group, along_with, v, w))#
          } else{#
            evaldtdt(ans <- ans[, list(.group, .along_with, .v, .w)])#
          }#
          evaldt(ans[, .bin := .bincode(along_with, breaks = seq(min(along_with, na.rm = TRUE), max(along_with, na.rm = TRUE), length = 20))])#
          evaldt(N <- ans[, sum(w)])#
          ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  .w, na.rm = TRUE), .group), by = list(.group, .bin)])#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans2[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v, color = group)) + geom_point(data = ans2, aes_string(x = along_with, y = v, color = group), alpha = 0.6) + stat_smooth(method = method)#
            } else{#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + geom_point(data = ans2, aes_string(weight = ww, x = along_with, y = v), size = size) + stat_smooth(method = method) + facet_grid(as.formula(paste0(group, "~.")))#
            } #
        } else{#
          dummy <- evaldt(is.integer(ans[,v])+ is.character(ans[,v]))#
          if (dummy) {#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans[, .v:= as.factor(.v)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, fill = group)) + geom_bar(width=.5,position = "dodge")+ coord_flip() #
            } else{#
              if (!reorder){#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5)+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
              } else{#
                  ans <- evaldt(ans[, list(N = as.integer(rep(.N,.N)), .w = as.name(.w)), by = c(.group,.v)])#
                  setkeyv(ans, c(group, "N",v))#
                  ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5) + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))                 #
              }#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans <- ans[, list(.group, .w, .v = winsorize(.v, verbose = verbose))])#
            } #
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, color = group)) + stat_density(geom = "line", position = "identity")#
            } else{            #
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line") + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          }#
        }#
      } #
  }#
  if (length(g)==1){#
    if (verbose){#
      print(g[[1]])#
    } else{#
      suppressWarnings(suppressMessages(print(g[[1]])))#
    }#
  } else{#
    if (verbose){#
      do.call(multiplot, g)#
    }#
    suppressWarnings(suppressMessages(do.call(multiplot, g)))#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
traceback()
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT,v1)
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Experimental function to graph a dataset#
#' #
#' @param x A data.table.#
#' @param ... Variables to include. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param along_with Replace x axis by this variable (ie estimate regression models instead of density).#
#' @param by Groups within which variables should be ploted.#
#' @param reorder Should the category with the most count be printed first?#
#' @param facet Should different groups graphed in different windows?#
#' @param size Size of points when more than 1000 points by group#
#' @param winsorize Should variables winsorized?#
#' @param method A character for regression model (lm, loess) when along_with is specified#
#' @param verbose Should warnings (regarding missing values, outliers, etc) be printed?#
#' @examples#
#' N <- 10000#
#' DT <- data.table(#
#'   id = sample(c("id1","id2","id3"), N, TRUE),#
#'   v1 = sample(c(1:5), N, TRUE),#
#'   v2 = rnorm(N, sd = 20),#
#'   v3 = sample(runif(100, max=100), N, TRUE)#
#' )#
#' DT[, v4 := v3 + rnorm(N, sd = 20)]#
#' graph(DT)#
#' graph(DT, by = id)#
#' graph(DT, by = id, facet = TRUE)#
#' graph(DT, v3, v4, along_with = v2)#
#' graph(DT, v3, v4, along_with = v2, by = id)#
#' @export#
graph <- function(x, ..., along_with = NULL, by = NULL, w = NULL, reorder = TRUE, winsorize = TRUE, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  graph_(x, .dots = lazy_dots(...) , along_with = substitute(along_with), by = substitute(by), w = substitute(w), d = d, reorder = reorder, winsorize = winsorize, facet = facet, size = size, verbose = verbose, method = method)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots , along_with = NULL, by = NULL, w = NULL, d = FALSE, reorder = TRUE, winsorize = winsorize, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x),w))#
  along_with <- names(select_vars_(names(x), along_with))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = c(byvars,w,along_with)))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars, along_with, w))#
  }#
  if (length(along_with)){#
    nums <- sapply(x, is.numeric)#
    nums_name <- names(nums[nums==TRUE])#
    vars = intersect(vars,nums_name)#
  }#
  name_list <- function(x){#
    if (length(x)){#
      x <- sapply(x, as.name)#
    }#
    unlist(x)#
  }#
#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
  assign_var(x, bin, group)#
#
  x <- x[, c(byvars, vars, along_with, w), with = FALSE]#
  if (!length(w)){#
    assign_var(x, w)#
    evaldt(x[, .w := 1])#
    ww <- NULL#
  } else{#
    ww <- as.name(paste0(w,"/sum(",w,")"))#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
        if (length(along_with)){#
          ans <- x[, list(.along_with, .v, .w)]#
          nums <- sapply(x, is.numeric)#
          nums_name <- names(nums[nums==TRUE])#
          vars=intersect(vars,nums_name)#
          if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
            if (winsorize){#
              evaldt(ans[, .v := winsorize(.v, verbose = verbose)])#
              evaldt(ans[, .along_with:= winsorize(.along_with, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.along_with, breaks = seq(min(.along_with, na.rm = TRUE), max(.along_with, na.rm = TRUE), length = 20))])#
            evaldt(N <- ans[, sum(.w)])#
            ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  w, na.rm = TRUE)), by = bin])#
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + stat_smooth(method = method) + geom_point(data=ans2, aes_string(x = along_with, y = v)) #
        } else{#
        ans <- evaldt(x[, list(.v, .w)])#
        print(ans)#
        dummy <- evaldt(is.integer(ans[,v]) + is.character(ans[,v]))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(weight = ww, x = v)) + geom_point(stat="bin")+ coord_flip()#
            } else{#
              ans <- evaldt(ans[, list(.w, N = .N), by = .v])#
              setkeyv(ans,c("N", v))#
              ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_point(stat="bin") + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans[, .v:= winsorize(.v, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.v, breaks = seq(min(.v, na.rm = TRUE), max(.v, na.rm = TRUE), length = 100))])#
            evaldt(N <- ans[, sum(.w)])#
            ans <- evaldt(ans[, list(.v = mean(.v, na.rm = TRUE), count = sum(.w / N, na.rm = TRUE)), by = .bin])#
            # g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line")#
             g[[i]] <-  ggplot(ans, aes_string(x = v, y= "count")) + geom_point()#
          }#
        }#
      } #
  } else{#
    if (length(byvars)>1){#
      setkeyv(x, byvars)#
      x[, .group := 0]#
      x[unique(x), .group := 1]#
      evaldt(x[, .group:= cumsum(.v)])#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        ans <- x[, c(byvars, v, w, along_with), with = FALSE]#
        i <- i+1#
        if (length(along_with)){#
          if (winsorize){#
            evaldt(ans <- ans[, list(.group, winsorize(.along_with, verbose = verbose), winsorize(.v, verbose = verbose), ,w)])#
            setnames(ans, c(group, along_with, v, w))#
          } else{#
            evaldtdt(ans <- ans[, list(.group, .along_with, .v, .w)])#
          }#
          evaldt(ans[, .bin := .bincode(along_with, breaks = seq(min(along_with, na.rm = TRUE), max(along_with, na.rm = TRUE), length = 20))])#
          evaldt(N <- ans[, sum(w)])#
          ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  .w, na.rm = TRUE), .group), by = list(.group, .bin)])#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans2[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v, color = group)) + geom_point(data = ans2, aes_string(x = along_with, y = v, color = group), alpha = 0.6) + stat_smooth(method = method)#
            } else{#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + geom_point(data = ans2, aes_string(weight = ww, x = along_with, y = v), size = size) + stat_smooth(method = method) + facet_grid(as.formula(paste0(group, "~.")))#
            } #
        } else{#
          dummy <- evaldt(is.integer(ans[,v])+ is.character(ans[,v]))#
          if (dummy) {#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans[, .v:= as.factor(.v)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, fill = group)) + geom_bar(width=.5,position = "dodge")+ coord_flip() #
            } else{#
              if (!reorder){#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5)+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
              } else{#
                  ans <- evaldt(ans[, list(N = as.integer(rep(.N,.N)), .w = as.name(.w)), by = c(.group,.v)])#
                  setkeyv(ans, c(group, "N",v))#
                  ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5) + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))                 #
              }#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans <- ans[, list(.group, .w, .v = winsorize(.v, verbose = verbose))])#
            } #
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, color = group)) + stat_density(geom = "line", position = "identity")#
            } else{            #
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line") + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          }#
        }#
      } #
  }#
  if (length(g)==1){#
    if (verbose){#
      print(g[[1]])#
    } else{#
      suppressWarnings(suppressMessages(print(g[[1]])))#
    }#
  } else{#
    if (verbose){#
      do.call(multiplot, g)#
    }#
    suppressWarnings(suppressMessages(do.call(multiplot, g)))#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Experimental function to graph a dataset#
#' #
#' @param x A data.table.#
#' @param ... Variables to include. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.#
#' @param along_with Replace x axis by this variable (ie estimate regression models instead of density).#
#' @param by Groups within which variables should be ploted.#
#' @param reorder Should the category with the most count be printed first?#
#' @param facet Should different groups graphed in different windows?#
#' @param size Size of points when more than 1000 points by group#
#' @param winsorize Should variables winsorized?#
#' @param method A character for regression model (lm, loess) when along_with is specified#
#' @param verbose Should warnings (regarding missing values, outliers, etc) be printed?#
#' @examples#
#' N <- 10000#
#' DT <- data.table(#
#'   id = sample(c("id1","id2","id3"), N, TRUE),#
#'   v1 = sample(c(1:5), N, TRUE),#
#'   v2 = rnorm(N, sd = 20),#
#'   v3 = sample(runif(100, max=100), N, TRUE)#
#' )#
#' DT[, v4 := v3 + rnorm(N, sd = 20)]#
#' graph(DT)#
#' graph(DT, by = id)#
#' graph(DT, by = id, facet = TRUE)#
#' graph(DT, v3, v4, along_with = v2)#
#' graph(DT, v3, v4, along_with = v2, by = id)#
#' @export#
graph <- function(x, ..., along_with = NULL, by = NULL, w = NULL, reorder = TRUE, winsorize = TRUE, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  graph_(x, .dots = lazy_dots(...) , along_with = substitute(along_with), by = substitute(by), w = substitute(w), d = d, reorder = reorder, winsorize = winsorize, facet = facet, size = size, verbose = verbose, method = method)#
}#
#
#' @export#
#' @rdname graph#
graph_<- function(x, ..., .dots , along_with = NULL, by = NULL, w = NULL, d = FALSE, reorder = TRUE, winsorize = winsorize, facet = FALSE, size = 1, verbose = FALSE, method = "lm") {#
  stopifnot(is.data.table(x))#
  w <- names(select_vars_(names(x),w))#
  along_with <- names(select_vars_(names(x), along_with))#
  byvars <- names(select_vars_(names(x), by))#
  dots <- all_dots(.dots, ...)#
  vars <- names(select_vars_(names(x), dots, exclude = c(byvars,w,along_with)))#
  if (length(vars) == 0) {#
     vars <- setdiff(names(x), c(byvars, along_with, w))#
  }#
  if (length(along_with)){#
    nums <- sapply(x, is.numeric)#
    nums_name <- names(nums[nums==TRUE])#
    vars = intersect(vars,nums_name)#
  }#
  name_list <- function(x){#
    if (length(x)){#
      x <- sapply(x, as.name)#
    }#
    unlist(x)#
  }#
#
  if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
  assign_var(x, bin, group)#
#
  x <- x[, c(byvars, vars, along_with, w), with = FALSE]#
  if (!length(w)){#
    assign_var(x, w)#
    evaldt(x[, .w := 1])#
    ww <- NULL#
  } else{#
    ww <- as.name(paste0(w,"/sum(",w,")"))#
  }#
#
  if (!length(byvars)){#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        i <- i+1#
        if (length(along_with)){#
          ans <- x[, list(.along_with, .v, .w)]#
          nums <- sapply(x, is.numeric)#
          nums_name <- names(nums[nums==TRUE])#
          vars=intersect(vars,nums_name)#
          if (!length(vars)) stop("Please select at least one non-numeric variable", call. = FALSE)#
            if (winsorize){#
              evaldt(ans[, .v := winsorize(.v, verbose = verbose)])#
              evaldt(ans[, .along_with:= winsorize(.along_with, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.along_with, breaks = seq(min(.along_with, na.rm = TRUE), max(.along_with, na.rm = TRUE), length = 20))])#
            evaldt(N <- ans[, sum(.w)])#
            ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  w, na.rm = TRUE)), by = bin])#
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + stat_smooth(method = method) + geom_point(data=ans2, aes_string(x = along_with, y = v)) #
        } else{#
        ans <- evaldt(x[, list(.v, .w)])#
        print(ans)#
        dummy <- evaldt(is.integer(ans[,.v]) + is.character(ans[,.v]))#
          if (dummy) {#
            if (!reorder){#
              g[[i]] <-  ggplot(x, aes_string(weight = ww, x = v)) + geom_point(stat="bin")+ coord_flip()#
            } else{#
              ans <- evaldt(ans[, list(.w, N = .N), by = .v])#
              setkeyv(ans,c("N", v))#
              ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_point(stat="bin") + coord_flip()#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans[, .v:= winsorize(.v, verbose = verbose)])#
            }#
            evaldt(ans[, .bin := .bincode(.v, breaks = seq(min(.v, na.rm = TRUE), max(.v, na.rm = TRUE), length = 100))])#
            evaldt(N <- ans[, sum(.w)])#
            ans <- evaldt(ans[, list(.v = mean(.v, na.rm = TRUE), count = sum(.w / N, na.rm = TRUE)), by = .bin])#
            # g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line")#
             g[[i]] <-  ggplot(ans, aes_string(x = v, y= "count")) + geom_point()#
          }#
        }#
      } #
  } else{#
    if (length(byvars)>1){#
      setkeyv(x, byvars)#
      x[, .group := 0]#
      x[unique(x), .group := 1]#
      evaldt(x[, .group:= cumsum(.v)])#
    } else{#
      group <- byvars#
    }#
    g <- NULL#
    i <- 0#
      for (v in vars){#
        ans <- x[, c(byvars, v, w, along_with), with = FALSE]#
        i <- i+1#
        if (length(along_with)){#
          if (winsorize){#
            evaldt(ans <- ans[, list(.group, winsorize(.along_with, verbose = verbose), winsorize(.v, verbose = verbose), ,w)])#
            setnames(ans, c(group, along_with, v, w))#
          } else{#
            evaldtdt(ans <- ans[, list(.group, .along_with, .v, .w)])#
          }#
          evaldt(ans[, .bin := .bincode(along_with, breaks = seq(min(along_with, na.rm = TRUE), max(along_with, na.rm = TRUE), length = 20))])#
          evaldt(N <- ans[, sum(w)])#
          ans2 <- evaldt( ans[, list(.along_with = mean(.along_with), .v = weighted.mean(.v,  .w, na.rm = TRUE), .group), by = list(.group, .bin)])#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans2[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v, color = group)) + geom_point(data = ans2, aes_string(x = along_with, y = v, color = group), alpha = 0.6) + stat_smooth(method = method)#
            } else{#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = along_with, y = v)) + geom_point(data = ans2, aes_string(weight = ww, x = along_with, y = v), size = size) + stat_smooth(method = method) + facet_grid(as.formula(paste0(group, "~.")))#
            } #
        } else{#
          dummy <- evaldt(is.integer(ans[,.v])+ is.character(ans[,.v]))#
          if (dummy) {#
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              evaldt(ans[, .v:= as.factor(.v)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, fill = group)) + geom_bar(width=.5,position = "dodge")+ coord_flip() #
            } else{#
              if (!reorder){#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5)+ coord_flip()+ facet_grid(as.formula(paste0(group,"~.")))#
              } else{#
                  ans <- evaldt(ans[, list(N = as.integer(rep(.N,.N)), .w = as.name(.w)), by = c(.group,.v)])#
                  setkeyv(ans, c(group, "N",v))#
                  ans <- evaldt(ans[, .v := factor(.v, levels = unique(.v), ordered = TRUE)])#
                  g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + geom_bar(width=.5) + coord_flip() + facet_grid(as.formula(paste0(group, "~.")))                 #
              }#
            }#
          } else{ #
            if (winsorize){#
              evaldt(ans <- ans[, list(.group, .w, .v = winsorize(.v, verbose = verbose))])#
            } #
            if (!facet){#
              evaldt(ans[, .group:= as.factor(.group)])#
              g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v, color = group)) + stat_density(geom = "line", position = "identity")#
            } else{            #
            g[[i]] <-  ggplot(ans, aes_string(weight = ww, x = v)) + stat_density(geom = "line") + facet_grid(as.formula(paste0(group, "~.")))#
            }#
          }#
        }#
      } #
  }#
  if (length(g)==1){#
    if (verbose){#
      print(g[[1]])#
    } else{#
      suppressWarnings(suppressMessages(print(g[[1]])))#
    }#
  } else{#
    if (verbose){#
      do.call(multiplot, g)#
    }#
    suppressWarnings(suppressMessages(do.call(multiplot, g)))#
  }#
}#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT)
traceback()
DT
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT,v4)
str_replace(".dot",".","")
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Create unique names within environment#
#'#
#' @param prefix A character vector that specifies prefix for new name#
#' @param where A list or an environment#
#' @param inherits  Should the name unique also in the enclosing frames of the environment?#
#' @param n Number of names to generate#
#' @examples#
#' tempname <- tempname("temp", globalenv())#
#' tempname <- tempname("temp", DT )#
#' tempname <- tempname("temp", list = c("temp", "temp1"))#
#
#' @export#
tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
    i <- 0L#
    out <- NULL#
    name <- prefix#
    if (!is.null(list)){#
        while (name %in% l) {#
            i <- i + 1L#
            name <- paste0(prefix, as.character(i))#
            }#
    } else{#
    	while (exists(name, where = where, inherits = inherits)){#
            i <- i + 1L#
    	   name <- paste0(prefix, as.character(i))#
	   }#
    }#
    name#
}#
#
assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
    names <- sapply(lazy_dots(...), function(x){as.character(x$expr)})#
    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
}#
#
assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
    for (name in names){#
        tempname <- tempname(paste("temp",name,sep="_"), where = env, inherits = inherits)#
        assign(name, tempname, env)#
    }#
}#
#
evaldt <- function(x, env = parent.frame()){#
    x <- substitute(x)#
    names <- ls(all.names = TRUE, envir = env)#
    L <- NULL#
    names_l <- NULL#
    for (name in names){#
        if (exists(name, envir = env, inherits = FALSE, mode = "character")){#
            get_name <- get(name, envir = env)#
            if (length(get_name)){#
                L <- c(L, as.name(get_name))#
                names_l <- c(names_l, name)#
            }#
        }#
    }#
    names(L) <- names_l#
    # replace names, even in LHS of list#
    replace_name <- function(x, lenv, env){#
        i <- 0#
        if (is.atomic(x) | is.symbol(x)){#
            if (str_detect(as.character(x),"*\\.")){#
                xx <- str_replace(as.character(x),".","")#
                if (exists(xx, envir = env, inherits = FALSE, mode = "character")){#
                    return(as.name(get(xx, envir = env)))#
                } else{#
                  return(x)#
                }#
            } else{#
                return(x)#
            }#
        }#
        else{#
            out <- NULL#
            for (i in 1:length(x)){#
                if (!is.null(x[[i]])){#
                    x[[i]] <- replace_name(x[[i]], lenv, env)#
                }#
            }#
            names <- NULL#
            if (x[[1]] == quote(list)){#
                for (name in names(x)){#
                    if (str_detect(name,"\\.")) {#
                        namename <- str_replace(as.character(x),".","")#
                        if (exists(namename, envir = env, inherits = FALSE, mode = "character")){#
                            names <- c(names, get(namename, pos = env))#
                        } else{#
                            names <- c(names, name)#
                        }#
                    } #
                    else{#
                        names <- c(names, name)#
                    }#
                }#
                names(x) <- names#
            }#
        }#
        x#
    }#
    print(as.list(L))#
    call <- replace_name(x, as.list(L), env = env)#
    print(call)#
    eval(call, env)#
}#
#
#get("id", pos = DT)#
#
#Using data.table x inside a program can be cumbersom, the following steps are needed :#
#- Create a string that does not  exist in names(x) #
#- eval(substitute() at every line, with a list composed of all the temporary variables created#
#- Since `eval(substitute())` does not replace LHS in DT[, list(id = sum(v1)], I have to either #modify the call  or use setnames after the command#
##
#There may be things I do wrongly, but all these steps makes programming cumbersome. So I have #thought of the following convenient functions:#
##
#- a function assign_var (dt,v) that creates a binding from v to a symbol (corresponding to a #name that does not exist in data.table)#
#- A function evaldt, that captures the argument, and replace every name bounded to a symbol by #the symbol. Compared to eval(substitute()) it automatically generates the list constituted #of variables that are binded to symbols, and it also replaces the lhs of a list (for #instance v in list(v="ok")).#
##
#So this is how it works fora function that filter a condition within each group#
#````#
#rm(list =ls())#
#N <- 2e6#
#DT <- data.table(#
#  id = 1:N,#
#  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
#  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
#  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
#)#
#I#
#f <- function(DT,condition, by ){#
# # assignnments#
#  condition = substitute(condition)#
#  by = substitute(by) #
#  assign_var(DT,tag)#
## same command than in interactive mode, except evaldt in front of it#
# evaldt(DT[DT[, list(tag = .I[condition]), by = by ]$tag])#
#}#
##
#I guess my this is neither directly a pull or a feature request, but I was looking for general #opinion on whether this is a good  way to use data.table within a function#
##
#The code of assgn_var is below functions is below #
#````R#
#tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
#    i <- 0L#
#    out <- NULL#
#    name <- prefix#
#    if (!is.null(list)){#
#        while (name %in% l) {#
#            i <- i + 1L#
#            name <- paste0(prefix, as.character(i))#
#            }#
#    } else{#
#        while (exists(name, where = where, inherits = inherits)){#
#            i <- i + 1L#
#           name <- paste0(prefix, as.character(i))#
#       }#
#    }#
#    name#
#}#
##
#assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
#    names <-   as.character(substitute(list(...))[-1])#
#    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
#}#
##
#assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
#    for (name in names){#
#        tempname <- paste("temp",name,sep="_")#
#        assign(name, as.name(tempname), envir = env)#
#    }#
#}#
##
#evaldt <- function(x, env = parent.frame()){#
#    x <- substitute(x)#
#    names <- ls(all.names = TRUE, envir = env)#
#    L <- NULL#
#    names_l <- NULL#
#    for (name in names){#
#        if (exists(name, env, inherits = FALSE, mode = "language") | exists(name, env, inherits #= FALSE, mode = "symbol")) {#
#            L <- c(L, get(name, envir = env))#
#            names_l <- c(names_l, name)#
#        }#
#    }#
#    names(L) <- names_l#
#    # replace names, even in LHS of list#
#    replace_name <- function(x, lenv){#
#        i <- 0#
#        if ((is.atomic(x)) | (is.symbol(x))){#
#            call <- substitute(substitute(y, lenv), list(y = x))#
#            return(eval(call))#
#        }#
#        else{#
#            out <- NULL#
#            for (i in 1:length(x)){#
#                if (!is.null(x[[i]])){#
#                    x[[i]] <- replace_name(x[[i]], lenv)#
#                }#
#            }#
#            names <- NULL#
#            if (x[[1]] == quote(list)){#
#                for (name in names(x)){#
#                    if ((name!="") && (exists(name, lenv))) {#
#                            names <- c(names, as.character(get(name, pos = lenv)))#
#                    } #
#                    else{#
#                        names <- c(names, name)#
#                    }#
#                }#
#                names(x) <- names#
#            }#
#        }#
#        x#
#    }#
#    call <- replace_name(x, as.list(L))#
#    eval(call, env)#
#}#
#````
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Create unique names within environment#
#'#
#' @param prefix A character vector that specifies prefix for new name#
#' @param where A list or an environment#
#' @param inherits  Should the name unique also in the enclosing frames of the environment?#
#' @param n Number of names to generate#
#' @examples#
#' tempname <- tempname("temp", globalenv())#
#' tempname <- tempname("temp", DT )#
#' tempname <- tempname("temp", list = c("temp", "temp1"))#
#
#' @export#
tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
    i <- 0L#
    out <- NULL#
    name <- prefix#
    if (!is.null(list)){#
        while (name %in% l) {#
            i <- i + 1L#
            name <- paste0(prefix, as.character(i))#
            }#
    } else{#
    	while (exists(name, where = where, inherits = inherits)){#
            i <- i + 1L#
    	   name <- paste0(prefix, as.character(i))#
	   }#
    }#
    name#
}#
#
assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
    names <- sapply(lazy_dots(...), function(x){as.character(x$expr)})#
    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
}#
#
assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
    for (name in names){#
        tempname <- tempname(paste("temp",name,sep="_"), where = env, inherits = inherits)#
        assign(name, tempname, env)#
    }#
}#
#
evaldt <- function(x, env = parent.frame()){#
    x <- substitute(x)#
    names <- ls(all.names = TRUE, envir = env)#
    L <- NULL#
    names_l <- NULL#
    for (name in names){#
        if (exists(name, envir = env, inherits = FALSE, mode = "character")){#
            get_name <- get(name, envir = env)#
            if (length(get_name)){#
                L <- c(L, as.name(get_name))#
                names_l <- c(names_l, name)#
            }#
        }#
    }#
    names(L) <- names_l#
    # replace names, even in LHS of list#
    replace_name <- function(x, lenv, env){#
        i <- 0#
        if (is.atomic(x) | is.symbol(x)){#
            if (str_detect(as.character(x),"*\\.")){#
                xx <- str_replace(as.character(x),".","")#
                if (exists(xx, envir = env, inherits = FALSE, mode = "character")){#
                    return(as.name(get(xx, envir = env)))#
                } else{#
                  return(x)#
                }#
            } else{#
                return(x)#
            }#
        }#
        else{#
            out <- NULL#
            for (i in 1:length(x)){#
                if (!is.null(x[[i]])){#
                    x[[i]] <- replace_name(x[[i]], lenv, env)#
                }#
            }#
            names <- NULL#
            if (x[[1]] == quote(list)){#
                for (name in names(x)){#
                    if (str_detect(name,"\\.")) {#
                        namename <- str_replace(as.character(x),".","")#
                        if (exists(namename, envir = env, inherits = FALSE, mode = "character")){#
                            names <- c(names, get(namename, env = env))#
                        } else{#
                            names <- c(names, name)#
                        }#
                    } #
                    else{#
                        names <- c(names, name)#
                    }#
                }#
                names(x) <- names#
            }#
        }#
        x#
    }#
    print(as.list(L))#
    call <- replace_name(x, as.list(L), env = env)#
    print(call)#
    eval(call, env)#
}#
#
#get("id", pos = DT)#
#
#Using data.table x inside a program can be cumbersom, the following steps are needed :#
#- Create a string that does not  exist in names(x) #
#- eval(substitute() at every line, with a list composed of all the temporary variables created#
#- Since `eval(substitute())` does not replace LHS in DT[, list(id = sum(v1)], I have to either #modify the call  or use setnames after the command#
##
#There may be things I do wrongly, but all these steps makes programming cumbersome. So I have #thought of the following convenient functions:#
##
#- a function assign_var (dt,v) that creates a binding from v to a symbol (corresponding to a #name that does not exist in data.table)#
#- A function evaldt, that captures the argument, and replace every name bounded to a symbol by #the symbol. Compared to eval(substitute()) it automatically generates the list constituted #of variables that are binded to symbols, and it also replaces the lhs of a list (for #instance v in list(v="ok")).#
##
#So this is how it works fora function that filter a condition within each group#
#````#
#rm(list =ls())#
#N <- 2e6#
#DT <- data.table(#
#  id = 1:N,#
#  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
#  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
#  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
#)#
#I#
#f <- function(DT,condition, by ){#
# # assignnments#
#  condition = substitute(condition)#
#  by = substitute(by) #
#  assign_var(DT,tag)#
## same command than in interactive mode, except evaldt in front of it#
# evaldt(DT[DT[, list(tag = .I[condition]), by = by ]$tag])#
#}#
##
#I guess my this is neither directly a pull or a feature request, but I was looking for general #opinion on whether this is a good  way to use data.table within a function#
##
#The code of assgn_var is below functions is below #
#````R#
#tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
#    i <- 0L#
#    out <- NULL#
#    name <- prefix#
#    if (!is.null(list)){#
#        while (name %in% l) {#
#            i <- i + 1L#
#            name <- paste0(prefix, as.character(i))#
#            }#
#    } else{#
#        while (exists(name, where = where, inherits = inherits)){#
#            i <- i + 1L#
#           name <- paste0(prefix, as.character(i))#
#       }#
#    }#
#    name#
#}#
##
#assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
#    names <-   as.character(substitute(list(...))[-1])#
#    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
#}#
##
#assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
#    for (name in names){#
#        tempname <- paste("temp",name,sep="_")#
#        assign(name, as.name(tempname), envir = env)#
#    }#
#}#
##
#evaldt <- function(x, env = parent.frame()){#
#    x <- substitute(x)#
#    names <- ls(all.names = TRUE, envir = env)#
#    L <- NULL#
#    names_l <- NULL#
#    for (name in names){#
#        if (exists(name, env, inherits = FALSE, mode = "language") | exists(name, env, inherits #= FALSE, mode = "symbol")) {#
#            L <- c(L, get(name, envir = env))#
#            names_l <- c(names_l, name)#
#        }#
#    }#
#    names(L) <- names_l#
#    # replace names, even in LHS of list#
#    replace_name <- function(x, lenv){#
#        i <- 0#
#        if ((is.atomic(x)) | (is.symbol(x))){#
#            call <- substitute(substitute(y, lenv), list(y = x))#
#            return(eval(call))#
#        }#
#        else{#
#            out <- NULL#
#            for (i in 1:length(x)){#
#                if (!is.null(x[[i]])){#
#                    x[[i]] <- replace_name(x[[i]], lenv)#
#                }#
#            }#
#            names <- NULL#
#            if (x[[1]] == quote(list)){#
#                for (name in names(x)){#
#                    if ((name!="") && (exists(name, lenv))) {#
#                            names <- c(names, as.character(get(name, pos = lenv)))#
#                    } #
#                    else{#
#                        names <- c(names, name)#
#                    }#
#                }#
#                names(x) <- names#
#            }#
#        }#
#        x#
#    }#
#    call <- replace_name(x, as.list(L))#
#    eval(call, env)#
#}#
#````
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT,v4)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Create unique names within environment#
#'#
#' @param prefix A character vector that specifies prefix for new name#
#' @param where A list or an environment#
#' @param inherits  Should the name unique also in the enclosing frames of the environment?#
#' @param n Number of names to generate#
#' @examples#
#' tempname <- tempname("temp", globalenv())#
#' tempname <- tempname("temp", DT )#
#' tempname <- tempname("temp", list = c("temp", "temp1"))#
#
#' @export#
tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
    i <- 0L#
    out <- NULL#
    name <- prefix#
    if (!is.null(list)){#
        while (name %in% l) {#
            i <- i + 1L#
            name <- paste0(prefix, as.character(i))#
            }#
    } else{#
    	while (exists(name, where = where, inherits = inherits)){#
            i <- i + 1L#
    	   name <- paste0(prefix, as.character(i))#
	   }#
    }#
    name#
}#
#
assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
    names <- sapply(lazy_dots(...), function(x){as.character(x$expr)})#
    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
}#
#
assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
    for (name in names){#
        tempname <- tempname(paste("temp",name,sep="_"), where = env, inherits = inherits)#
        assign(name, tempname, env)#
    }#
}#
#
evaldt <- function(x, env = parent.frame()){#
    x <- substitute(x)#
    names <- ls(all.names = TRUE, envir = env)#
    L <- NULL#
    names_l <- NULL#
    for (name in names){#
        if (exists(name, envir = env, inherits = FALSE, mode = "character")){#
            get_name <- get(name, envir = env)#
            if (length(get_name)){#
                L <- c(L, as.name(get_name))#
                names_l <- c(names_l, name)#
            }#
        }#
    }#
    names(L) <- names_l#
    # replace names, even in LHS of list#
    replace_name <- function(x, lenv, env){#
        i <- 0#
        if (is.atomic(x) | is.symbol(x)){#
            if (str_detect(as.character(x),"*\\.")){#
                xx <- str_replace(as.character(x),".","")#
                if (exists(xx, envir = env, inherits = FALSE, mode = "character")){#
                    return(as.name(get(xx, envir = env)))#
                } else{#
                  return(x)#
                }#
            } else{#
                return(x)#
            }#
        }#
        else{#
            out <- NULL#
            for (i in 1:length(x)){#
                if (!is.null(x[[i]])){#
                    x[[i]] <- replace_name(x[[i]], lenv, env)#
                }#
            }#
            names <- NULL#
            if (x[[1]] == quote(list)){#
                for (name in names(x)){#
                    if (str_detect(name,"\\.")) {#
                        namename <- str_replace(as.character(name),".","")#
                        if (exists(namename, envir = env, inherits = FALSE, mode = "character")){#
                            names <- c(names, get(namename, env = env))#
                        } else{#
                            names <- c(names, name)#
                        }#
                    } #
                    else{#
                        names <- c(names, name)#
                    }#
                }#
                names(x) <- names#
            }#
        }#
        x#
    }#
    print(as.list(L))#
    call <- replace_name(x, as.list(L), env = env)#
    print(call)#
    eval(call, env)#
}#
#
#get("id", pos = DT)#
#
#Using data.table x inside a program can be cumbersom, the following steps are needed :#
#- Create a string that does not  exist in names(x) #
#- eval(substitute() at every line, with a list composed of all the temporary variables created#
#- Since `eval(substitute())` does not replace LHS in DT[, list(id = sum(v1)], I have to either #modify the call  or use setnames after the command#
##
#There may be things I do wrongly, but all these steps makes programming cumbersome. So I have #thought of the following convenient functions:#
##
#- a function assign_var (dt,v) that creates a binding from v to a symbol (corresponding to a #name that does not exist in data.table)#
#- A function evaldt, that captures the argument, and replace every name bounded to a symbol by #the symbol. Compared to eval(substitute()) it automatically generates the list constituted #of variables that are binded to symbols, and it also replaces the lhs of a list (for #instance v in list(v="ok")).#
##
#So this is how it works fora function that filter a condition within each group#
#````#
#rm(list =ls())#
#N <- 2e6#
#DT <- data.table(#
#  id = 1:N,#
#  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
#  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
#  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
#)#
#I#
#f <- function(DT,condition, by ){#
# # assignnments#
#  condition = substitute(condition)#
#  by = substitute(by) #
#  assign_var(DT,tag)#
## same command than in interactive mode, except evaldt in front of it#
# evaldt(DT[DT[, list(tag = .I[condition]), by = by ]$tag])#
#}#
##
#I guess my this is neither directly a pull or a feature request, but I was looking for general #opinion on whether this is a good  way to use data.table within a function#
##
#The code of assgn_var is below functions is below #
#````R#
#tempname=function(prefix = "temp", where = globalenv() , inherits=TRUE, list = NULL) {#
#    i <- 0L#
#    out <- NULL#
#    name <- prefix#
#    if (!is.null(list)){#
#        while (name %in% l) {#
#            i <- i + 1L#
#            name <- paste0(prefix, as.character(i))#
#            }#
#    } else{#
#        while (exists(name, where = where, inherits = inherits)){#
#            i <- i + 1L#
#           name <- paste0(prefix, as.character(i))#
#       }#
#    }#
#    name#
#}#
##
#assign_var <- function(x, ..., env = parent.frame(), inherits = FALSE){#
#    names <-   as.character(substitute(list(...))[-1])#
#    assign_var_(x = x, names = names, inherits = inherits, env = parent.frame())#
#}#
##
#assign_var_ <- function(x, names, env = parent.frame(), inherits=TRUE) {#
#    for (name in names){#
#        tempname <- paste("temp",name,sep="_")#
#        assign(name, as.name(tempname), envir = env)#
#    }#
#}#
##
#evaldt <- function(x, env = parent.frame()){#
#    x <- substitute(x)#
#    names <- ls(all.names = TRUE, envir = env)#
#    L <- NULL#
#    names_l <- NULL#
#    for (name in names){#
#        if (exists(name, env, inherits = FALSE, mode = "language") | exists(name, env, inherits #= FALSE, mode = "symbol")) {#
#            L <- c(L, get(name, envir = env))#
#            names_l <- c(names_l, name)#
#        }#
#    }#
#    names(L) <- names_l#
#    # replace names, even in LHS of list#
#    replace_name <- function(x, lenv){#
#        i <- 0#
#        if ((is.atomic(x)) | (is.symbol(x))){#
#            call <- substitute(substitute(y, lenv), list(y = x))#
#            return(eval(call))#
#        }#
#        else{#
#            out <- NULL#
#            for (i in 1:length(x)){#
#                if (!is.null(x[[i]])){#
#                    x[[i]] <- replace_name(x[[i]], lenv)#
#                }#
#            }#
#            names <- NULL#
#            if (x[[1]] == quote(list)){#
#                for (name in names(x)){#
#                    if ((name!="") && (exists(name, lenv))) {#
#                            names <- c(names, as.character(get(name, pos = lenv)))#
#                    } #
#                    else{#
#                        names <- c(names, name)#
#                    }#
#                }#
#                names(x) <- names#
#            }#
#        }#
#        x#
#    }#
#    call <- replace_name(x, as.list(L))#
#    eval(call, env)#
#}#
#````
N <- 10000#
DT <- data.table(#
  id = sample(c("id1","id2","id3"), N, TRUE),#
  v1 = sample(c(1:5), N, TRUE),#
  v2 = rnorm(N, sd = 20),#
  v3 = sample(runif(100, max=100), N, TRUE)#
)#
DT[, v4 := (id=="id1")* v2 + rnorm(N, sd = 5)]#
graph(DT,v4)
