DT %>% mutate_each(funs(mean), inplace = TRUE)
DT
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT %>% mutate_each(funs(mean), inplace = FALSE)
DT
DT %>% select(v2, inplace = FALSE)
library(dpsuppressMessages(library("tidyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))
suppressMessages(library("tidyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT %>% select(v1)
DT
DT %>% select(v1, inplace = TRUE)
DT
#' Gives summary statistics (Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude in s You can use same specifications as in select. If missing, defaults to all non-grouping variables.#
#' @param inplace Change data.table in place or not#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 =  sample(5, N, TRUE),                          #
#'   v2 =  sample(1e6, N, TRUE),                       #
#'   v3 =  sample(round(runif(100, max = 100), 4), N, TRUE) #
#' )#
#' DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#' @export#
colorder <- function(.data, ..., inplace = FALSE) {#
  colorder_(.data, vars = lazyeval::lazy_dots(...) , inplace = inplace)#
}#
#' @export#
colorder_ <- function(.data, vars, inplace = FALSE ) {#
  if (length(vars) == 0) {#
     vars <- lazyeval::lazy_dots(everything())#
   }#
  vars <- select_vars_(tbl_vars(.data), vars)#
  if (!inplace) .data <- copy(.data)#
  setcolorder(.data,vars,setdiff(names(.data),vars))#
  .data#
}
DT  %>% colorder(starts_with("v"), inplace = TRUE)
#' Gives summary statistics (Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude in s You can use same specifications as in select. If missing, defaults to all non-grouping variables.#
#' @param inplace Change data.table in place or not#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 =  sample(5, N, TRUE),                          #
#'   v2 =  sample(1e6, N, TRUE),                       #
#'   v3 =  sample(round(runif(100, max = 100), 4), N, TRUE) #
#' )#
#' DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#' @export#
colorder <- function(.data, ..., inplace = FALSE) {#
  colorder_(.data, vars = lazyeval::lazy_dots(...) , inplace = inplace)#
}#
#' @export#
colorder_ <- function(.data, vars, inplace = FALSE ) {#
  if (length(vars) == 0) {#
     vars <- lazyeval::lazy_dots(everything())#
   }#
  vars <- select_vars_(tbl_vars(.data), vars)#
  if (!inplace) .data <- copy(.data)#
  setcolorder(.data,c(vars,setdiff(names(.data),vars)))#
  .data#
}
DT  %>% colorder(starts_with("v"), inplace = TRUE)
DT
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT  %>% colorder(starts_with("v"), inplace = TRUE)
DT
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
library(dplyr)#
library(statar)#
#
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
      id = 1:N,#
      v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
      v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
      v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
    )#
#
### quantile category (=Stata xtile)#
DT %>% group_by(v1) %>% mutate(xtile(v2, nq = 3))#
DT %>% group_by(v1) %>% mutate(xtile(v2, cutpoints = c(1e5,5e5) ))
DT %>% group_by(id) %>% mutate(lag(value, order_by = time)) # Balanced dataset#
DT %>% group_by(id) %>% mutate(lag(value, along_with = time)) # Unbalanced dataset
DT %>% group_by(id) %>% mutate(lag(value, order_by = time)) # Balanced dataset
DT %>% group_by(id) %>% mutate(lag(v2, order_by = time)) # Balanced dataset
DT %>% group_by(id) %>% mutate(lag(v2, along_with = time)) # Unbalanced dataset
DT %>% group_by(id) %>% mutate(lag(v2, order_by = v1))
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))
library(data.table)#
#
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
### col_order (= Stata order)#
DT  %>% col_order(starts_with("v"))#
DT  %>% col_order(starts_with("v"), inplace = TRUE)#
#
### sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))#
#
### expand (= Stata tsfill)#
DT <- data.table(#
 id = c(1, 1, 1, 1, 1, 2, 2),#
 date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
 value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% group_by(id) %>% expand(date)#
DT %>% expand(date)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
?spread
?gather
library(tidyr)
?gather
stocks <- data.frame(#
  time = as.Date('2009-01-01') + 0:9,#
  X = rnorm(10, 0, 1),#
  Y = rnorm(10, 0, 2),#
  Z = rnorm(10, 0, 4)#
)
stocks
socks %>% gather(type, price)
library(dplyr)
socks %>% gather(type, price)
stocks %>% gather(type, price)
DT_long <- DT_wide %>% gather(variable, value, -time)
DT_long <- stocks %>% gather(variable, value, -time)
DT_long
DT_long <- DT_wide %>% spread (variable, value, -time)
DT_wide <- DT_long %>% spread (variable, value, -time)
?spread
DT_wide <- DT_long %>% spread(variable, value, -time)
DT_wide <- DT_long %>% spread(variable, value)
DT_wide
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2(4.5,3.0)))
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2(4.5,3.0))
library(data.table)
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2(4.5,3.0))
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2=c(4.5,3.0))
DT_wide
DT_wide %>% gather(variable, value, -i)
DT_long <- DT_wide %>% gather(variable, value, -i)
DT_long %>% spread(variable, value)
assignInNamespace("cedta.override", c(data.table:::cedta.override,"IRkernel#
                                      "), "data.table")
showMethods(expand)
library(matrix)
showMethods(expand)
library(Matrix)
showMethods(expand)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
library(statar)
library(data.table)
?hour
library(matrix)
library(Matrix)
?expand
showMethods(Matrix)
is.object(expand) & !isS4(expand)
is.object(expand
)
!isS4(expand)
isS4(expand)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
library(lubridate)
weeks
months
months(1)
years(1)
years
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
library(biglm)#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))
?expand
?expand_
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
lag
?lag
?lead
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
library(biglm)#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))
?lag
?lead
?expand
?xtile
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
?sum_up
library(statar)
?sum_up
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(statar)
?sum_up
library(statar)
?sum_up
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
lead_along <- function(x, n = 1L, units = NULL, date, default = NA) {#
  if (!is.null(units)) {#
    if (is.null(date)) stop("units cannot be used without order_by")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    date_origin <- as.Date('0001-01-01')#
    if (unitsc=="day"){#
      return(lead_along(x = x, n = n, default = default, date = along))#
    }#
    if (unitsc == "week"){#
      date_elapsed <- as.period(date-date_origin)  %/% weeks(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    }  #
    else if (unitsc == "month"){#
      date_elapsed <- as.period(date-date_origin)  %/% months(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    } else if (unitsc == "quarter"){#
      date_elapsed <- as.period(date-date_origin)  %/% 3*months(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    } else if (unitsc == "year"){#
      date_elapsed <- as.period(date-date_origin)  %/% years(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    }#
  }#
#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
  index <- match(date + n, date, incomparable = NA)#
  out <- x[index]#
  if (!is.na(default)) out[which(is.na(index))] <- default#
  attributes(out) <- attributes(x)#
  out#
}
lag_along <- function(x, n = 1L,  units = NULL, date = NULL, default = NA) {#
    if (!is.null(units)) {#
      if (is.null(date)) stop("units cannot be used without order_by")#
      unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
      date_origin <- as.Date('0001-01-01')#
      if (unitsc=="day"){#
        return(lag_along(x = x, n = n, default = default, date = along))#
      }#
      if (unitsc == "week"){#
        date_elapsed <- as.period(date-date_origin)  %/% weeks(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      }  #
      else if (unitsc == "month"){#
        date_elapsed <- as.period(date-date_origin)  %/% months(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      } else if (unitsc == "quarter"){#
        date_elapsed <- as.period(date-date_origin)  %/% 3*months(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      } else if (unitsc == "year"){#
        date_elapsed <- as.period(date-date_origin)  %/% years(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      }#
    }#
#
    if (n == 0) return(x)#
    if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
    index <- match(date - n, date, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
    attributes(out) <- attributes(x)#
    out#
  }
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
date := as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%y")
date = as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%y")
date+1
date
date = as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%y")
date
?as.Date
date = as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%Y")
date
devtools::install_github("matthieugomez/tidyr")#
devtools::install_github("matthieugomez/lazyeval")#
devtools::install_github("matthieugomez/dplyr")#
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(dplyr)#
library(data.table)#
library(statar)#
#
# partition creates quantile categories (corresponds to Stata xtile)#
v2 <-   sample(1e6, 1e6, TRUE)                   #
v2_categorized <- partition(v2, nq = 3) # 3 groups based on terciles#
v2_categorized <- partition(v2, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
# lag/lead create lag/lead variables (corresponds to Stata L. F.)#
## unbalanced panel#
DT <- data.frame(#
 date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
 value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% mutate(lag(value, 1, order_by = date)) # wrong#
DT %>% mutate(lag(value, 1, along_with = date)) # right#
#
## periods can be used instead of integers#
library(lubridate)#
df <- data.frame(     #
   id = c("id1", "id1", "id1", "id1"),#
   date = mdy(c("03/01/1992", "04/03/1992", "07/15/1992", "08/21/1992")),#
   value = c(4.1, 4.5, 3.3, 5.3)#
)#
df <- df %>% mutate(date = floor_date(date, "month"))#
df %>% group_by(id) %>% mutate(lag(value, months(1), along_with = date))
?data.table::lag
?lag
library(data.table)
library(dplyr)
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }#
#
DT <- data.table(#
   id = c(1, 1, 1, 1, 1, 2, 2),#
   date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
   value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
#
R> DT#
   id date value#
1:  1 1992   4.1#
2:  1 1989   4.5#
3:  1 1991   3.3#
4:  1 1990   5.3#
5:  1 1994   3.0#
6:  2 1992   3.2#
7:  2 1991   5.2#
R> DT %>% group_by(id) %>% mutate( lead_lag(value,1) )#
Source: local data table [7 x 4]#
Groups: id#
#
  id date value lead_lag(value, 1)#
1  1 1992   4.1                4.5#
2  1 1989   4.5                4.5#
3  1 1991   3.3                4.5#
4  1 1990   5.3                4.5#
5  1 1994   3.0                4.5#
6  2 1992   3.2                5.2#
7  2 1991   5.2                5.2#
R>
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }#
#
DT <- data.table(#
   id = c(1, 1, 1, 1, 1, 2, 2),#
   date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
   value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
#
DT#
   id date value#
1:  1 1992   4.1#
2:  1 1989   4.5#
3:  1 1991   3.3#
4:  1 1990   5.3#
5:  1 1994   3.0#
6:  2 1992   3.2#
7:  2 1991   5.2#
DT %>% group_by(id) %>% mutate( lead_lag(value,1) )#
Source: local data table [7 x 4]#
Groups: id#
#
  id date value lead_lag(value, 1)#
1  1 1992   4.1                4.5#
2  1 1989   4.5                4.5#
3  1 1991   3.3                4.5#
4  1 1990   5.3                4.5#
5  1 1994   3.0                4.5#
6  2 1992   3.2                5.2#
7  2 1991   5.2                5.2#
R>
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }#
#
DT <- data.table(#
   id = c(1, 1, 1, 1, 1, 2, 2),#
   date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
   value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)
R> DT %>% group_by(id) %>% mutate( lead_lag(value,1) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1,order_by(date)) )
debug(lead_lag)
DT %>% group_by(id) %>% mutate( lead_lag(value,1,order_by(date)) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1)) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1))
s
n
s
debug(lead_lag)
lead_lag(DT$value,1)
s
f
lead_lag(value,1)
s
f
undebug(lead_lag)
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }
lead_lag(c(1,2),k=1)
lag(c(1,2),n=1)
sign(k){if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}
sign(k){if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}}
lead_lag(k) <- function{if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}}
lead_lag(k) <- function(k){if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}}
lead_lag(k) <- function(k){if (k>0){function(x){lag(x,k)}}else{function(x){lead(x,k)}}
}
lead_lag <- function(k){if (k>0){function(x){lag(x,k)}}else{function(x){lead(x,k)}}}
lea_lag(3)(c(1,2)
_
lea_lag(3)(c(1,2))
lead_lag(3)(c(1,2))
lead_lag(1)(c(1,2))
?ifelse
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100,max=100), 4), N, TRUE)#
  )#
#
# colorder (= Stata order)#
DT  %>% colorder(starts_with("v"))#
DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))
library(statar)
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100,max=100), 4), N, TRUE)#
  )#
#
# colorder (= Stata order)#
DT  %>% colorder(starts_with("v"))#
DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
suppressMessages(library("data.table"))#
suppressMessages(library("biglm"))#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT[, condition := id>100]#
system.time(DT[ id >100, coefficients(biglm(v3 ~ v2 + v1, .SD)), .SDcols = c("v1","v2","v3")])#
system.time(DT[, coefficients(biglm(v3 ~ v2 + v1, .SD)), by = "condition", .SDcols = c("v1","v2","v3")])#
system.time(coefficients(biglm(v3 ~ v2 + v1, DT[id>100, c("v1","v2","v3"), with = FALSE])
)
suppressMessages(library("data.table"))#
suppressMessages(library("biglm"))#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT[, condition := id>100]
system.time(DT[, coefficients(biglm(v3 ~ v2 + v1, .SD)), by = condition, .SDcols = c("v1", "v2", "v3")])
library(Matrix)
?expand
isS4(expand)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
?expand
DT <- data.table(#
    id = c(1, 1, 1, 1, 1, 2, 2),#
    date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
    value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% expand(date)
library(dpryr)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
?lag
lag
devtools::install_github("smbache/magrittr")
library(magrittr)
rnorm(100) %T>%#
  plot(type = "l", col = "firebrick") %>%#
  abs %>%#
  sum
tmp :=#
  subset(Species == "setosa") %>%#
  set_names(LETTERS[1:5])
install.packages("colorout")
download.file("http://www.lepem.ufc.br/jaa/colorout_1.0-3.tar.gz", destfile = "colorout_1.0-3.tar.gz")#
install.packages("colorout_1.0-3.tar.gz", type = "source", repos = NULL)
savehistory
savehistory(ok)
savehistory("ok")
savehistory("~/.R.app.history")
savehistory()
fefe
savehistory()
library(pryr)
N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )
DT
DF
DT <- setDF(DF)
library(data.table)
DT <- setDF(DF)
DT
DT1 <- copy(DT)
object_size(DT,DT1)
object_size(DT)
object_size(DT,DT1)
object_size(DT,DT1, merge(DT,DT1)
)
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2)]#
	object_size(DF, DF1)#
	17.4 kB#
	object_size(DF, DF3)#
	25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	17.4 kB#
	object_size(DF, DF3)#
	25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
}
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	17.4 kB#
	object_size(DF, DF3)#
	25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	#> 17.4 kB#
	object_size(DF, DF3)#
	#> 25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
q
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	#> 17.4 kB#
	object_size(DF, DF3)#
	#> 25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
)
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	#> 17.4 kB#
	object_size(DF, DF2)#
	#> 25.9 kB#
	object_size(DF,DF2, merge(DF,DF2)
)
library(tidyr)
?gather
DTx <- data.table (#
  gvkey = c("2222","2222"), #
  permno = c("20990", "20980"), #
  year_min = c(1991,2000), #
  year_max = c(1999, 2001)#
)
debugdebug(mutate)
debug(mutate)
library(dplyr)
DT <- data.table ( id = 1:10)
mutate(DT, mean(id))
debug(mutate)
DT <- data.table ( id = 1:10)
mutate(DT, mean(id))
s
n
?forder
DT
DT[1, id:= NA]
DT
forder(DT,id)
DT[order(id)]
setorder(DT,id)
DT
?setorder
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
suppressMessages(library("biglm"))#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))#
assignInNamespace("cedta.override",#
                  c(data.table:::cedta.override,"IRkernel"),#
                  "data.table")
N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
result1 <- felm( v4 ~ v2 + v1, DT )#
result2 <- felm( v3 ~ v2 + v1, DT )#
result3 <- felm( v4 ~ v3 + v1 |0| (v3 ~ v2) |0, DT )
ivreg
library(aer)
library(AER)
ivreg(v3~v1,DT)
?ivreg
ivreg(v3~v2 | v1,DT)
ivreg(v3 ~ v2 | v1,D T)
ivreg(v3 ~ v2 | v1, DT)
?ivreg
ivreg(v3 ~ v2 | v1, DT)
ivreg(v3 ~ v2 | v1, date = DT)
ivreg(v3 ~ v2 | v1, data = DT)
library("lfe")#
N <- 1e6#
df <- data.frame(#
   v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
)#
felm(v1~v2|0|(v2~v3)|0, df)
library("lfe")#
N <- 1e6#
df <- data.frame(#
   v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
felm(v1~v2|0|(v2~v3)|0, df)
library("lfe")#
N <- 1e6#
df <- data.frame(#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100, max = 100), 4), N, TRUE) # numeric e.g. 23.5749#
)#
felm(v1 ~ v2 | 0 | (v2 ~ v3) |0, df)
felm(v1 ~ v2 | 0 | (v2 ~ v3) |, df)
felm(v1 ~ v2 |  | (v2 ~ v3) |, df)
felm(v1 ~ v2 |  | (v2 ~ v3) |0, df)
felm(v1 ~ v2 |  | (v2 ~ v3), df)
felm(v1 ~ v2 |0| (v2 ~ v3), df)
l= c("col1","some","col3")
l[c(1,NA)]
l[c(1,NA)] <- c("col11","col12")
l[c(TRUE,NA)] <- c("col11","col12")
l[l=="col1"] <- c("col11","col12")
l=="col1"
l <- c("col1", NA, "col3")#
l[l==col1] <- c("col1")
l <- c("col1", NA, "col3")#
l[l == "col1"] <- c("col1")
l
condition = l== "col1"
condition
l[condition] <- c("col1")
l[c(TRUE,NA,FALSE) <- c("col1")
)
l[c(TRUE,NA,FALSE)] <- c("col1")
l <- c("col1", NA, "col3")#
condition = l== "col1"#
l[condition] <- c("col1")#
l[l == "col1"] <- c("col1")#
l[which(l == "col1")
]
l <- c("col1", NA, "col3")#
condition = l== "col1"#
l[condition] <- c("col1")#
l[l == "col1"] <- c("col1")#
l[which(condition)] <- c("col1")
l
l[NA,1]
l[c(NA,1)]
l <- c("col1", "col2", "col3")#
    l[c(NA,1)]
l[c(TRUE, NA, TRUE)]
l[c(NA, TRUE)]
l <- c("col1", NA, "col3")#
	l[which(l == "col1" | l == "col3")]
l <- c("col1", NA, "col3")#
	l[l == "col1"]
l[which(l == "col1")]
DT
N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
library(data.table)
lm(v2~v1,DT)
N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
lm(v2~v1,DT)
result <- lm(v2~v1,DT)
names(result)
result$coefficients
result$model
result
names(result)
summary(result)
list(summary(result))
names(summary(result))
result <- felm(v2~v1,DT)
library(lfe)
result <- felm(v2~v1,DT)
names(result)
names(result)$se
result$se
result$coefficients
result$robustvcv
summary(result)
names(summary(result))
?summary
object_size(summary(result))
library(pryr)
object_size(summary(result))
object_size(result)
result <- lm(y ~ x)
result <- lm(y ~ x)N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
result <- lm(v3 ~ v2, DT)
pryr::object_size(results)
pryr::object_size(result)
pryr::object_size(summary(results))
pryr::object_size(summary(result))
names(result)
result$coefficients
result <- lm(y ~ x)N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
result <- felm(v3 ~ v2, DT)
vcov(result)
result
result <- lm(y ~ x)N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
result <- felm(v3 ~ v2|||v1, DT)
result <- lm(y ~ x)N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
result <- felm(v3 ~ v2|0|0|v1, DT)
names(result)
vcov(result)
result$vcv
result$robustvcv
object_size(results)
object_size(result)
result <- felm(v3~v2|0|0|v1, DT)
stargazer(result, type = "text")
library(stargazer)
stargazer(result, type = "text")
devtools::install_github("matthieugomez/statar")
lazy(date)
library(lazyeval)
lazy(date0
)
lazy(date)
lazy_eval(lazy(date))
lazy_eval(lazy(date1))
select_vars(names(df),lazy(ok))
library(dplyr)
select_vars(names(df),lazy(ok))
select_vars(names(df), args = lazy(ok))
lazydots
lazy_dots
lazykeep = function(df,x){#
  keep_(df, lazy(x))#
}#
keep_ = function(df,x){#
  df[, lazy_eval(x,df)]#
}(date)
df
df <- data.frame(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(NA, NA, 3, 5.3, 3.0, 3.2, 5.2)#
 )
keep(df,id)
keep = function(df,x){#
  keep_(df, lazy(x))#
}#
keep_ = function(df,x){#
  df[, lazy_eval(x,df)]#
}
keep(df,id)
lazy(date)
lazy(date1)
devtools::load_all("/Users/Matthieu/Dropbox/Symlink/Downloads/data.table-master")
dt <- data.table(id = c(1,2), date = c(1999, 2000))#
setcolorder(dt, "date", 1)#
setcolorder(dt, 2, 1)#
setcolorder(dt, "id", 2)#
setcolorder(dt, 1, 2)
devtools::load_all("/Users/Matthieu/Dropbox/Symlink/Downloads/data.table-master")
library(lfe)
suppressMessages(library("data.table"))
N <- 1e3#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
felm(v3 ~ v2, DT)
felm(v3 ~ 1|0|(v2~v1), DT)
debug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
n
f
felm(v3 ~ 1|0|(v2~v1), DT)
pform
parseformula(formula,data)
knownargs
sc
sc <- names(sys.call())[-1]
sc
named <- knownargs[pmatch(sc, knownargs)]
formula
f
felm::parseformula(v3 ~ 1 | 0 | v2 ~ v1, DT)
lfe:::parseformula(v3 ~ 1 | 0 | v2 ~ v1, DT)
felm = function (formula, data, iv = NULL, clustervar = NULL, exactDOF = FALSE, #
    subset, na.action, contrasts = NULL, ...) #
{#
    knownargs <- c("iv", "clustervar", "cmethod")#
    sc <- names(sys.call())[-1]#
    named <- knownargs[pmatch(sc, knownargs)]#
    for (arg in c("iv", "clustervar")) {#
        if (!is.null(eval(as.name(arg))) && !(arg %in% named)) {#
            warning("Please specify the '", arg, "' argument by name, or use a multi part formula. Its position in the argument list will change in a later version")#
        }#
    }#
    mf <- match.call(expand.dots = FALSE)#
    cmethod <- "cgm"#
    args <- list(...)#
    ka <- knownargs[pmatch(names(args), knownargs, duplicates.ok = FALSE)]#
    names(args)[!is.na(ka)] <- ka[!is.na(ka)]#
    env <- environment()#
    lapply(intersect(knownargs, ka), function(arg) assign(arg, #
        args[[arg]], pos = env))#
    if (!(cmethod %in% c("cgm", "gaure"))) #
        stop("Unknown cmethod: ", cmethod)#
    unk <- setdiff(names(args), knownargs)#
    if (length(unk) > 0) #
        stop("unknown arguments ", paste(unk, collapse = " "))#
    if (missing(data)) #
        data <- environment(formula)#
    pf <- parent.frame()#
    pform <- parseformula(formula, data)#
    print(formula)#
    print(pform)#
}
felm(v3 ~ 1|0|v2~v1, DT)
parseformula <- function (form, data) #
{#
    f <- as.Formula(form)#
    len <- length(f)[[2]]#
    if (len == 1) #
        return(oldparseformula(form, data))#
    opart <- formula(f, lhs = 1, rhs = 1)#
    if (len == 1) #
        return(list(formula = opart, gpart = ~0, ivpart = ~0, #
            cpart = ~0))#
    gpart <- formula(f, lhs = 0, rhs = 2)#
    if (!nopart(gpart)) {#
        tm <- terms(gpart, keep.order = TRUE)#
        parts <- attr(tm, "term.labels")#
        parts <- parts[parts != "0"]#
        nm <- parts#
        glist <- lapply(paste(".G(", parts, ")", sep = ""), function(e) parse(text = e))#
        Gfunc <- function(f) if (is.null(attr(f, "xnam"))) #
            factor(f)#
        else f#
        Ginfunc <- function(x, f) {#
            if (is.factor(x)) {#
                structure(interaction(factor(f), factor(x), drop = TRUE), #
                  xnam = deparse(substitute(x)), fnam = deparse(substitute(f)))#
            }#
            else {#
                structure(factor(f), x = x, xnam = deparse(substitute(x)), #
                  fnam = deparse(substitute(f)))#
            }#
        }#
        if (is.environment(data)) {#
            fl <- lapply(glist, eval, list(.G = Gfunc, `:` = Ginfunc), #
                data)#
        }#
        else {#
            fl <- lapply(glist, eval, data, as.environment(list(.G = Gfunc, #
                `:` = Ginfunc)))#
        }#
        names(fl) <- nm#
    }#
    else {#
        fl <- NULL#
    }#
    if (len == 2) #
        return(list(formula = opart, fl = fl, gpart = gpart, #
            ivpart = ~0, cpart = ~0))#
    ivparts <- formula(f, lhs = 0, rhs = 3, drop = TRUE)#
    if (!nopart(ivparts) && length(ivparts[[2]]) > 1 && ivparts[[2]][[1]] == #
        "(") {#
        ivspec <- as.Formula(ivparts[[2]][[2]])#
        lhs <- formula(ivspec, rhs = 0)#
        ivpart <- lapply(seq_along(all.vars(lhs)), function(i) formula(ivspec, #
            lhs = i))#
    }#
    else {#
        ivpart <- NULL#
    }#
    if (len == 3 && !is.null(ivpart)) #
        return(list(formula = opart, fl = fl, iv = ivpart, gpart = gpart, #
            ivpart = ivparts, cpart = ~0))#
    if (len == 3 && is.null(ivpart)) {#
        cpart <- ivparts#
        ivparts <- NULL#
    }#
    else {#
        cpart <- formula(f, lhs = 0, rhs = 4, drop = TRUE)#
    }#
    if (!nopart(cpart)) {#
        tm <- terms(cpart, keep.order = TRUE)#
        nm <- parts <- attr(tm, "term.labels")#
        clist <- lapply(paste("factor(", parts, ")", sep = ""), #
            function(e) parse(text = e))#
        cluster <- lapply(clist, eval, data)#
        names(cluster) <- nm#
    }#
    else {#
        cluster <- NULL#
    }#
    list(formula = opart, fl = fl, iv = ivpart, cluster = cluster, #
        gpart = gpart, ivpart = ivparts, cpart = cpart)#
}
felm(v3 ~ 1|0|v2~v1, DT)
library(Formula)
felm(v3 ~ 1|0|v2~v1, DT)
oldparseformula = function (formula, data) #
{#
    trm <- terms(formula, specials = c("G"))#
    feidx <- attr(trm, "specials")$G + 1#
    va <- attr(trm, "variables")#
    festr <- paste(sapply(feidx, function(i) deparse(va[[i]])), #
        collapse = "+")#
    if (festr != "") {#
        formula <- update(formula, paste(". ~ . -(", festr, ") - 1"))#
        felist <- parse(text = paste("list(", gsub("+", ",", #
            festr, fixed = TRUE), ")", sep = ""))#
        nm <- eval(felist, list(G = function(arg) deparse(substitute(arg))))#
        Gfunc <- function(f) if (is.null(attr(f, "xnam"))) #
            factor(f)#
        else f#
        Ginfunc <- function(x, f) {#
            if (is.factor(x)) {#
                structure(interaction(factor(f), factor(x), drop = TRUE), #
                  xnam = deparse(substitute(x)), fnam = deparse(substitute(f)))#
            }#
            else {#
                structure(factor(f), x = x, xnam = deparse(substitute(x)), #
                  fnam = deparse(substitute(f)))#
            }#
        }#
        if (is.environment(data)) {#
            fl <- eval(felist, list(G = Gfunc, `:` = Ginfunc), #
                data)#
        }#
        else {#
            fl <- local({#
                eval(felist, data)#
            }, list(G = Gfunc, `:` = Ginfunc))#
        }#
        names(fl) <- nm#
        gpart <- eval(parse(text = paste("~", paste(nm, collapse = "+"))))#
        if (is.null(names(fl))) #
            names(fl) <- paste("fe", 1:length(fl), sep = "")#
    }#
    else {#
        fl <- NULL#
        gpart <- ~0#
    }#
    return(list(formula = formula, fl = fl, gpart = gpart, ivpart = ~0, #
        cpart = ~0))#
}
felm(v3 ~ 1|0|v2~v1, DT)
library(lfe)
suppressMessages(library("data.table"))
N <- 1e3#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
felm(v3 ~ 1|0|v2~v1, DT)
DT
felm(v3 ~ 1|0|v2~v1, DT)
DT
felm(v3 ~ 1|0|(v2~v1), DT)
debug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
formula
pform
f <- as.Formula(formula)
f
felm(v3 ~ 1|0|(v2~v1), DT)
s
n
formula
data
p <- as.Formula(formula)
p
length(f)[[2]]
length(p)[[2]]
length(p)[[1]]
names(length(p))
length(p)
p
length(formula)
length(formula)[[2]]
gpart <-  formula(p, lhs = 0, rhs = 2)
nopart(gpart)
ivparts <- formula(p, lhs = 0, rhs = 3, drop = TRUE)
ivparts
f
as.list(body(felm))
trace(felm, print(mf), at = 40)
trace(felm, quote(print(mf)), at = 40)
felm(v3 ~ 1|0|(v2~v1), DT)
g=function(formula,env){eval(formula,env)}
f=function(x){assign("t1",1:10,envir = parent.frame()); g(y~t1, parent.frame())}
f=function(x){assign("t1",1:10,envir = parent.frame()); g(x~t1, parent.frame())}
f(1:10)
g=function(formula,env){stats::model.frame(formula,env)}
f(1:10)
f=function(){assign("t1",1:10,envir = parent.frame()); g(x~t1, parent.frame())}
x <- 1:10
f(1:10)
f()
ls()
ls(parent.env())
?ls
g=function(formula,env){eval(formula,env)}
g=function(formula,env){stats::model.frame(formula,env)}
f=function(){assign("v2(fit)",1:10,envir = parent.frame()); g(x~t1, parent.frame())}
f()
f=function(){assign("v2(fit)",1:10,envir = parent.frame()); g(x~`v2(fit)`, parent.frame())}
f=function(){assign("v2(fit)",1:10,envir = parent.frame()); g(x~t1, parent.frame())}
f()
f=function(){assign("v2(fit)",1:10,envir = parent.frame()); g(x~`v2(fit)`, parent.frame())}
f()
lfe::project
setwd("/Users/Matthieu/Dropbox/Symlink")#
devtools::install_github("matthieugomez/statar")#
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
suppressMessages(library("biglm"))#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))#
assignInNamespace("cedta.override",#
                  c(data.table:::cedta.override,"IRkernel"),#
                  "data.table")
x <- data.table(a = rep(1:2, each = 3), b=1:6)#
y <- data.table(a = 0:1, bb = 10:11)#
# outer corresponds to Stata joinby keep(master matched using)#
join(x, y, type = "outer")#
# left corresponds to Stata joinby keep(master matched)#
join(x, y, type = "left")#
# right corresponds to Stata joinby keep(mached using)#
join(x, y, type = "right")#
# inner corresponds to Stata joinby keep(matched)#
join(x, y, type = "inner")#
#
join(x, y, type = "semi")#
join(x, y, type = "anti")#
join(x, y, type = "outer", gen = "_merge")#
join(x, y, type = "outer", check = 1~1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors specifying variables to match on. Default to common names between x and y. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi", "anti" and "cross".#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A formula checking for the presence of duplicates. Specifying 1~m (resp m~1, 1~1) checks that joined variables uniquely identify observations in x (resp y, both).#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with .x and .y suffixes. Importantly, if x or y are not keyed, the join may change their row orders.#
#' @examples#
#' x <- data.table(a = rep(1:2, each = 3), b=1:6)#
#' y <- data.table(a = 0:1, bb = 10:11)#
#' join(x, y, type = "outer")#
#' join(x, y, type = "left", gen = "_merge")#
#' join(x, y, type = "right", gen = "_merge")#
#' join(x, y, type = "inner", check = 1~1)#
#' join(x, y, type = "semi")#
#' join(x, y, type = "anti")#
#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , check = m~m,  gen = FALSE){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  if (type == "cross"){#
        k <- NULL # Setting the variables to NULL first for CRAN check NOTE#
        DT_output <- setkey(x[,c(k=1, .SD)],k)[y[, c(k = 1,.SD)], allow.cartesian = TRUE][,k := NULL]#
  }else {#
    # check gen#
    if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
      stop(" The option gen only makes sense for left, right and outer joins", call. = FALSE)#
    }#
#
    # join names#
    vars <- on#
    message(paste0("Join based on : ", paste(vars, collapse = " ")))#
#
    common_names <- setdiff(intersect(names(x),names(y)), vars)#
    if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"), call. = FALSE)#
    if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"), call. = FALSE)#
#
      if (check[[2]] == 1){#
         if (anyDuplicated(x)){ #
           stop(paste0("Variables ",paste(vars, collapse = ","),"don't uniquely identify observations in the master dataset"), call. = FALSE)#
         }#
       }#
#
      if (check[[3]] == 1){#
       if (anyDuplicated(y)){ #
         stop(paste0("Variables ",paste(vars, collapse = ","),"don't uniquely identify observations in the using dataset"), call. = FALSE)#
       }#
      }#
#
    # set keys and check duplicates#
    key_x <- key(x)#
    key_y <- key(y)#
    setkeyv(x, vars)#
    setkeyv(y, vars)#
    on.exit(setkeyv(x, key_x))#
    on.exit(setkeyv(y, key_y), add = TRUE)#
#
    if (check[[2]] == 1){#
       if (anyDuplicated(x)){ #
         stop("Variables don't uniquely identify observations in the master dataset", call. = FALSE)#
       }#
     }#
#
    if (check[[3]] == 1){#
     if (anyDuplicated(y)){ #
       stop("Variables don't uniquely identify observations in the using dataset", call. = FALSE)#
     }#
    }#
    if (length(common_names)>0){#
      setnames(x, common_names, paste0(common_names, ".x"))#
      setnames(y, common_names, paste0(common_names, ".y"))#
      on.exit(setnames(x, paste0(common_names, ".x"), common_names), add = TRUE)#
      on.exit(setnames(y, paste0(common_names, ".y"), common_names), add = TRUE)#
    }#
    if (type %in% c("left", "right", "outer", "inner")){#
      all.x <- FALSE#
      all.y <- FALSE#
      if (type == "left"| type == "outer"){#
        all.x = TRUE#
      }#
      if (type == "right" | type == "outer"){#
        all.y = TRUE#
      }#
      if (!gen == FALSE){#
        if (gen %chin% names(x)){#
          stop(paste0(gen," alreay exists in master"))#
        }#
        if (gen %chin% names(y)){#
          stop(paste0(gen," alreay exists in using"))#
        }#
        idm <- tempname_list("temp", c(names(x),names(y),gen))#
        x[, c(idm) := 1L]#
        idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
        y[, c(idu) := 1L]#
        on.exit(x[, c(idm) := NULL], add = TRUE)#
        on.exit(y[, c(idu) := NULL], add = TRUE) #
      }#
#
      DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
      if (gen != FALSE){#
        DT_output[, c(gen) := 3L]#
        eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
        eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
        DT_output[, c(idm) := NULL]#
        DT_output[, c(idu) := NULL]#
      }#
    } else if (type == "semi"){#
      w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
      w <- w[!is.na(w)]#
      DT_output <- x[w]#
    } else if (type == "anti"){#
      DT_output <- x[!y, allow.cartesian = TRUE]#
    } #
  }#
  DT_output#
}
x <- data.table(a = rep(1:2, each = 3), b=1:6)#
y <- data.table(a = 0:1, bb = 10:11)#
# outer corresponds to Stata joinby keep(master matched using)#
join(x, y, type = "outer")#
# left corresponds to Stata joinby keep(master matched)#
join(x, y, type = "left")#
# right corresponds to Stata joinby keep(mached using)#
join(x, y, type = "right")#
# inner corresponds to Stata joinby keep(matched)#
join(x, y, type = "inner")#
#
join(x, y, type = "semi")#
join(x, y, type = "anti")#
join(x, y, type = "outer", gen = "_merge")#
join(x, y, type = "outer", check = 1~1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors specifying variables to match on. Default to common names between x and y. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi", "anti" and "cross".#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A formula checking for the presence of duplicates. Specifying 1~m (resp m~1, 1~1) checks that joined variables uniquely identify observations in x (resp y, both).#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with .x and .y suffixes. Importantly, if x or y are not keyed, the join may change their row orders.#
#' @examples#
#' x <- data.table(a = rep(1:2, each = 3), b=1:6)#
#' y <- data.table(a = 0:1, bb = 10:11)#
#' join(x, y, type = "outer")#
#' join(x, y, type = "left", gen = "_merge")#
#' join(x, y, type = "right", gen = "_merge")#
#' join(x, y, type = "inner", check = 1~1)#
#' join(x, y, type = "semi")#
#' join(x, y, type = "anti")#
#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , check = m~m,  gen = FALSE){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  if (type == "cross"){#
        k <- NULL # Setting the variables to NULL first for CRAN check NOTE#
        DT_output <- setkey(x[,c(k=1, .SD)],k)[y[, c(k = 1,.SD)], allow.cartesian = TRUE][,k := NULL]#
  }else {#
    # check gen#
    if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
      stop(" The option gen only makes sense for left, right and outer joins", call. = FALSE)#
    }#
#
    # join names#
    vars <- on#
    message(paste0("Join based on : ", paste(vars, collapse = " ")))#
#
    common_names <- setdiff(intersect(names(x),names(y)), vars)#
    if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"), call. = FALSE)#
    if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"), call. = FALSE)#
#
      if (check[[2]] == 1){#
         if (anyDuplicated(x)){ #
           stop(paste0("Variables ",paste(vars, collapse = " "),"don't uniquely identify observations in the master dataset"), call. = FALSE)#
         }#
       }#
#
      if (check[[3]] == 1){#
       if (anyDuplicated(y)){ #
         stop(paste0("Variables ",paste(vars, collapse = " "),"don't uniquely identify observations in the using dataset"), call. = FALSE)#
       }#
      }#
#
    # set keys and check duplicates#
    key_x <- key(x)#
    key_y <- key(y)#
    setkeyv(x, vars)#
    setkeyv(y, vars)#
    on.exit(setkeyv(x, key_x))#
    on.exit(setkeyv(y, key_y), add = TRUE)#
#
    if (check[[2]] == 1){#
       if (anyDuplicated(x)){ #
         stop("Variables don't uniquely identify observations in the master dataset", call. = FALSE)#
       }#
     }#
#
    if (check[[3]] == 1){#
     if (anyDuplicated(y)){ #
       stop("Variables don't uniquely identify observations in the using dataset", call. = FALSE)#
     }#
    }#
    if (length(common_names)>0){#
      setnames(x, common_names, paste0(common_names, ".x"))#
      setnames(y, common_names, paste0(common_names, ".y"))#
      on.exit(setnames(x, paste0(common_names, ".x"), common_names), add = TRUE)#
      on.exit(setnames(y, paste0(common_names, ".y"), common_names), add = TRUE)#
    }#
    if (type %in% c("left", "right", "outer", "inner")){#
      all.x <- FALSE#
      all.y <- FALSE#
      if (type == "left"| type == "outer"){#
        all.x = TRUE#
      }#
      if (type == "right" | type == "outer"){#
        all.y = TRUE#
      }#
      if (!gen == FALSE){#
        if (gen %chin% names(x)){#
          stop(paste0(gen," alreay exists in master"))#
        }#
        if (gen %chin% names(y)){#
          stop(paste0(gen," alreay exists in using"))#
        }#
        idm <- tempname_list("temp", c(names(x),names(y),gen))#
        x[, c(idm) := 1L]#
        idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
        y[, c(idu) := 1L]#
        on.exit(x[, c(idm) := NULL], add = TRUE)#
        on.exit(y[, c(idu) := NULL], add = TRUE) #
      }#
#
      DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
      if (gen != FALSE){#
        DT_output[, c(gen) := 3L]#
        eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
        eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
        DT_output[, c(idm) := NULL]#
        DT_output[, c(idu) := NULL]#
      }#
    } else if (type == "semi"){#
      w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
      w <- w[!is.na(w)]#
      DT_output <- x[w]#
    } else if (type == "anti"){#
      DT_output <- x[!y, allow.cartesian = TRUE]#
    } #
  }#
  DT_output#
}
x <- data.table(a = rep(1:2, each = 3), b=1:6)#
y <- data.table(a = 0:1, bb = 10:11)#
# outer corresponds to Stata joinby keep(master matched using)#
join(x, y, type = "outer")#
# left corresponds to Stata joinby keep(master matched)#
join(x, y, type = "left")#
# right corresponds to Stata joinby keep(mached using)#
join(x, y, type = "right")#
# inner corresponds to Stata joinby keep(matched)#
join(x, y, type = "inner")#
#
join(x, y, type = "semi")#
join(x, y, type = "anti")#
join(x, y, type = "outer", gen = "_merge")#
join(x, y, type = "outer", check = 1~1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors specifying variables to match on. Default to common names between x and y. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi", "anti" and "cross".#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A formula checking for the presence of duplicates. Specifying 1~m (resp m~1, 1~1) checks that joined variables uniquely identify observations in x (resp y, both).#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with .x and .y suffixes. Importantly, if x or y are not keyed, the join may change their row orders.#
#' @examples#
#' x <- data.table(a = rep(1:2, each = 3), b=1:6)#
#' y <- data.table(a = 0:1, bb = 10:11)#
#' join(x, y, type = "outer")#
#' join(x, y, type = "left", gen = "_merge")#
#' join(x, y, type = "right", gen = "_merge")#
#' join(x, y, type = "inner", check = 1~1)#
#' join(x, y, type = "semi")#
#' join(x, y, type = "anti")#
#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , check = m~m,  gen = FALSE){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  if (type == "cross"){#
        k <- NULL # Setting the variables to NULL first for CRAN check NOTE#
        DT_output <- setkey(x[,c(k=1, .SD)],k)[y[, c(k = 1,.SD)], allow.cartesian = TRUE][,k := NULL]#
  }else {#
    # check gen#
    if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
      stop(" The option gen only makes sense for left, right and outer joins", call. = FALSE)#
    }#
#
    # join names#
    vars <- on#
    message(paste0("Join based on : ", paste(vars, collapse = " ")))#
#
    common_names <- setdiff(intersect(names(x),names(y)), vars)#
    if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"), call. = FALSE)#
    if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"), call. = FALSE)#
#
      if (check[[2]] == 1){#
         if (anyDuplicated(x)){ #
           stop(paste0("Variables ",paste(vars, collapse = " ")," don't uniquely identify observations in the master dataset"), call. = FALSE)#
         }#
       }#
#
      if (check[[3]] == 1){#
       if (anyDuplicated(y)){ #
         stop(paste0("Variables ",paste(vars, collapse = " ")," don't uniquely identify observations in the using dataset"), call. = FALSE)#
       }#
      }#
#
    # set keys and check duplicates#
    key_x <- key(x)#
    key_y <- key(y)#
    setkeyv(x, vars)#
    setkeyv(y, vars)#
    on.exit(setkeyv(x, key_x))#
    on.exit(setkeyv(y, key_y), add = TRUE)#
#
    if (check[[2]] == 1){#
       if (anyDuplicated(x)){ #
         stop("Variables don't uniquely identify observations in the master dataset", call. = FALSE)#
       }#
     }#
#
    if (check[[3]] == 1){#
     if (anyDuplicated(y)){ #
       stop("Variables don't uniquely identify observations in the using dataset", call. = FALSE)#
     }#
    }#
    if (length(common_names)>0){#
      setnames(x, common_names, paste0(common_names, ".x"))#
      setnames(y, common_names, paste0(common_names, ".y"))#
      on.exit(setnames(x, paste0(common_names, ".x"), common_names), add = TRUE)#
      on.exit(setnames(y, paste0(common_names, ".y"), common_names), add = TRUE)#
    }#
    if (type %in% c("left", "right", "outer", "inner")){#
      all.x <- FALSE#
      all.y <- FALSE#
      if (type == "left"| type == "outer"){#
        all.x = TRUE#
      }#
      if (type == "right" | type == "outer"){#
        all.y = TRUE#
      }#
      if (!gen == FALSE){#
        if (gen %chin% names(x)){#
          stop(paste0(gen," alreay exists in master"))#
        }#
        if (gen %chin% names(y)){#
          stop(paste0(gen," alreay exists in using"))#
        }#
        idm <- tempname_list("temp", c(names(x),names(y),gen))#
        x[, c(idm) := 1L]#
        idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
        y[, c(idu) := 1L]#
        on.exit(x[, c(idm) := NULL], add = TRUE)#
        on.exit(y[, c(idu) := NULL], add = TRUE) #
      }#
#
      DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
      if (gen != FALSE){#
        DT_output[, c(gen) := 3L]#
        eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
        eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
        DT_output[, c(idm) := NULL]#
        DT_output[, c(idu) := NULL]#
      }#
    } else if (type == "semi"){#
      w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
      w <- w[!is.na(w)]#
      DT_output <- x[w]#
    } else if (type == "anti"){#
      DT_output <- x[!y, allow.cartesian = TRUE]#
    } #
  }#
  DT_output#
}
x <- data.table(a = rep(1:2, each = 3), b=1:6)#
y <- data.table(a = 0:1, bb = 10:11)#
# outer corresponds to Stata joinby keep(master matched using)#
join(x, y, type = "outer")#
# left corresponds to Stata joinby keep(master matched)#
join(x, y, type = "left")#
# right corresponds to Stata joinby keep(mached using)#
join(x, y, type = "right")#
# inner corresponds to Stata joinby keep(matched)#
join(x, y, type = "inner")#
#
join(x, y, type = "semi")#
join(x, y, type = "anti")#
join(x, y, type = "outer", gen = "_merge")#
join(x, y, type = "outer", check = 1~1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
tempname_list=function(prefix, l) {#
    i <- 0L#
    name <- prefix#
    while (name %in% l) {#
        i <- i + 1L#
        name <- paste0(prefix, as.character(i))#
    }#
    name#
}
x <- data.table(a = rep(1:2, each = 3), b=1:6)#
y <- data.table(a = 0:1, bb = 10:11)#
# outer corresponds to Stata joinby keep(master matched using)#
join(x, y, type = "outer")#
# left corresponds to Stata joinby keep(master matched)#
join(x, y, type = "left")#
# right corresponds to Stata joinby keep(mached using)#
join(x, y, type = "right")#
# inner corresponds to Stata joinby keep(matched)#
join(x, y, type = "inner")#
#
join(x, y, type = "semi")#
join(x, y, type = "anti")#
join(x, y, type = "outer", gen = "_merge")#
join(x, y, type = "outer", check = 1~1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors specifying variables to match on. Default to common names between x and y. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi", "anti" and "cross".#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A formula checking for the presence of duplicates. Specifying 1~m (resp m~1, 1~1) checks that joined variables uniquely identify observations in x (resp y, both).#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with .x and .y suffixes. Importantly, if x or y are not keyed, the join may change their row orders.#
#' @examples#
#' x <- data.table(a = rep(1:2, each = 3), b=1:6)#
#' y <- data.table(a = 0:1, bb = 10:11)#
#' join(x, y, type = "outer")#
#' join(x, y, type = "left", gen = "_merge")#
#' join(x, y, type = "right", gen = "_merge")#
#' join(x, y, type = "inner", check = 1~1)#
#' join(x, y, type = "semi")#
#' join(x, y, type = "anti")#
#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , check = m~m,  gen = FALSE){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  if (type == "cross"){#
        k <- NULL # Setting the variables to NULL first for CRAN check NOTE#
        DT_output <- setkey(x[,c(k=1, .SD)],k)[y[, c(k = 1,.SD)], allow.cartesian = TRUE][,k := NULL]#
  }else {#
    # check gen#
    if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
      stop(" The option gen only makes sense for left, right and outer joins", call. = FALSE)#
    }#
#
    # join names#
    vars <- on#
    message(paste0("Join based on : ", paste(vars, collapse = " ")))#
#
    common_names <- setdiff(intersect(names(x),names(y)), vars)#
    if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"), call. = FALSE)#
    if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"), call. = FALSE)#
    # set keys and check duplicates#
    key_x <- key(x)#
    key_y <- key(y)#
    setkeyv(x, vars)#
    setkeyv(y, vars)#
    on.exit(setkeyv(x, key_x))#
    on.exit(setkeyv(y, key_y), add = TRUE)#
#
    if (check[[2]] == 1){#
       if (anyDuplicated(x)){ #
         stop(paste0("Variables ",paste(vars, collapse = " ")," don't uniquely identify observations in the master dataset"), call. = FALSE)#
       }#
     }#
#
    if (check[[3]] == 1){#
     if (anyDuplicated(y)){ #
       stop(paste0("Variables ",paste(vars, collapse = " ")," don't uniquely identify observations in the using dataset"), call. = FALSE)#
     }#
    }#
#
    if (length(common_names)>0){#
      setnames(x, common_names, paste0(common_names, ".x"))#
      setnames(y, common_names, paste0(common_names, ".y"))#
      on.exit(setnames(x, paste0(common_names, ".x"), common_names), add = TRUE)#
      on.exit(setnames(y, paste0(common_names, ".y"), common_names), add = TRUE)#
    }#
    if (type %in% c("left", "right", "outer", "inner")){#
      all.x <- FALSE#
      all.y <- FALSE#
      if (type == "left"| type == "outer"){#
        all.x = TRUE#
      }#
      if (type == "right" | type == "outer"){#
        all.y = TRUE#
      }#
      if (!gen == FALSE){#
        if (gen %chin% names(x)){#
          stop(paste0(gen," alreay exists in master"))#
        }#
        if (gen %chin% names(y)){#
          stop(paste0(gen," alreay exists in using"))#
        }#
        idm <- tempname_list("temp", c(names(x),names(y),gen))#
        x[, c(idm) := 1L]#
        idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
        y[, c(idu) := 1L]#
        on.exit(x[, c(idm) := NULL], add = TRUE)#
        on.exit(y[, c(idu) := NULL], add = TRUE) #
      }#
#
      DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
      if (gen != FALSE){#
        DT_output[, c(gen) := 3L]#
        eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
        eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
        DT_output[, c(idm) := NULL]#
        DT_output[, c(idu) := NULL]#
      }#
    } else if (type == "semi"){#
      w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
      w <- w[!is.na(w)]#
      DT_output <- x[w]#
    } else if (type == "anti"){#
      DT_output <- x[!y, allow.cartesian = TRUE]#
    } #
  }#
  DT_output#
}
x <- data.table(a = rep(1:2, each = 3), b=1:6)#
y <- data.table(a = 0:1, bb = 10:11)#
# outer corresponds to Stata joinby keep(master matched using)#
join(x, y, type = "outer")#
# left corresponds to Stata joinby keep(master matched)#
join(x, y, type = "left")#
# right corresponds to Stata joinby keep(mached using)#
join(x, y, type = "right")#
# inner corresponds to Stata joinby keep(matched)#
join(x, y, type = "inner")#
#
join(x, y, type = "semi")#
join(x, y, type = "anti")#
join(x, y, type = "outer", gen = "_merge")#
join(x, y, type = "outer", check = 1~1)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors specifying variables to match on. Default to common names between x and y. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi", "anti" and "cross".#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A formula checking for the presence of duplicates. Specifying 1~m (resp m~1, 1~1) checks that joined variables uniquely identify observations in x (resp y, both).#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with .x and .y suffixes. Importantly, if x or y are not keyed, the join may change their row orders.#
#' @examples#
#' x <- data.table(a = rep(1:2, each = 3), b=1:6)#
#' y <- data.table(a = 0:1, bb = 10:11)#
#' join(x, y, type = "outer")#
#' join(x, y, type = "left", gen = "_merge")#
#' join(x, y, type = "right", gen = "_merge")#
#' join(x, y, type = "inner", check = 1~1)#
#' join(x, y, type = "semi")#
#' join(x, y, type = "anti")#
#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , check = m~m,  gen = FALSE){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  if (type == "cross"){#
        k <- NULL # Setting the variables to NULL first for CRAN check NOTE#
        DT_output <- setkey(x[,c(k=1, .SD)],k)[y[, c(k = 1,.SD)], allow.cartesian = TRUE][,k := NULL]#
  }else {#
    # check gen#
    if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
      stop(" The option gen only makes sense for left, right and outer joins", call. = FALSE)#
    }#
#
    # join names#
    vars <- on#
    message(paste0("Join based on : ", paste(vars, collapse = " ")))#
#
    common_names <- setdiff(intersect(names(x),names(y)), vars)#
    if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"), call. = FALSE)#
    if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"), call. = FALSE)#
    # set keys and check duplicates#
    key_x <- key(x)#
    key_y <- key(y)#
    setkeyv(x, vars)#
    setkeyv(y, vars)#
    on.exit(setkeyv(x, key_x))#
    on.exit(setkeyv(y, key_y), add = TRUE)#
#
    if (check[[2]] == 1){#
       if (anyDuplicated(x)){ #
         stop(paste0("Variable(s) ",paste(vars, collapse = " ")," don't uniquely identify observations in the master dataset"), call. = FALSE)#
       }#
     }#
#
    if (check[[3]] == 1){#
     if (anyDuplicated(y)){ #
       stop(paste0("Variable(s) ",paste(vars, collapse = " ")," don't uniquely identify observations in the using dataset"), call. = FALSE)#
     }#
    }#
#
    if (length(common_names)>0){#
      setnames(x, common_names, paste0(common_names, ".x"))#
      setnames(y, common_names, paste0(common_names, ".y"))#
      on.exit(setnames(x, paste0(common_names, ".x"), common_names), add = TRUE)#
      on.exit(setnames(y, paste0(common_names, ".y"), common_names), add = TRUE)#
    }#
    if (type %in% c("left", "right", "outer", "inner")){#
      all.x <- FALSE#
      all.y <- FALSE#
      if (type == "left"| type == "outer"){#
        all.x = TRUE#
      }#
      if (type == "right" | type == "outer"){#
        all.y = TRUE#
      }#
      if (!gen == FALSE){#
        if (gen %chin% names(x)){#
          stop(paste0(gen," alreay exists in master"))#
        }#
        if (gen %chin% names(y)){#
          stop(paste0(gen," alreay exists in using"))#
        }#
        idm <- tempname_list("temp", c(names(x),names(y),gen))#
        x[, c(idm) := 1L]#
        idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
        y[, c(idu) := 1L]#
        on.exit(x[, c(idm) := NULL], add = TRUE)#
        on.exit(y[, c(idu) := NULL], add = TRUE) #
      }#
#
      DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
      if (gen != FALSE){#
        DT_output[, c(gen) := 3L]#
        eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
        eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
        DT_output[, c(idm) := NULL]#
        DT_output[, c(idu) := NULL]#
      }#
    } else if (type == "semi"){#
      w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
      w <- w[!is.na(w)]#
      DT_output <- x[w]#
    } else if (type == "anti"){#
      DT_output <- x[!y, allow.cartesian = TRUE]#
    } #
  }#
  DT_output#
}
x <- data.table(a = rep(1:2, each = 3), b=1:6)#
y <- data.table(a = 0:1, bb = 10:11)#
# outer corresponds to Stata joinby keep(master matched using)#
join(x, y, type = "outer")#
# left corresponds to Stata joinby keep(master matched)#
join(x, y, type = "left")#
# right corresponds to Stata joinby keep(mached using)#
join(x, y, type = "right")#
# inner corresponds to Stata joinby keep(matched)#
join(x, y, type = "inner")#
#
join(x, y, type = "semi")#
join(x, y, type = "anti")#
join(x, y, type = "outer", gen = "_merge")#
join(x, y, type = "outer", check = 1~1)
x
y
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors specifying variables to match on. Default to common names between x and y. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi", "anti" and "cross".#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A formula checking for the presence of duplicates. Specifying 1~m (resp m~1, 1~1) checks that joined variables uniquely identify observations in x (resp y, both).#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with .x and .y suffixes. Importantly, if x or y are not keyed, the join may change their row orders.#
#' @examples#
#' x <- data.table(a = rep(1:2, each = 3), b=1:6)#
#' y <- data.table(a = 0:1, bb = 10:11)#
#' join(x, y, type = "outer")#
#' join(x, y, type = "left", gen = "_merge")#
#' join(x, y, type = "right", gen = "_merge")#
#' join(x, y, type = "inner", check = 1~1)#
#' join(x, y, type = "semi")#
#' join(x, y, type = "anti")#
#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , check = m~m,  gen = FALSE){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  if (type == "cross"){#
        k <- NULL # Setting the variables to NULL first for CRAN check NOTE#
        DT_output <- setkey(x[,c(k=1, .SD)],k)[y[, c(k = 1,.SD)], allow.cartesian = TRUE][,k := NULL]#
  }else {#
    # check gen#
    if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
      stop(" The option gen only makes sense for left, right and outer joins", call. = FALSE)#
    }#
#
    # find names and  check no common names#
    vars <- on#
    message(paste0("Join based on : ", paste(vars, collapse = " ")))#
    common_names <- setdiff(intersect(names(x),names(y)), vars)#
    if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"), call. = FALSE)#
    if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"), call. = FALSE)#
    if (length(common_names)>0){#
      setnames(x, common_names, paste0(common_names, ".x"))#
      setnames(y, common_names, paste0(common_names, ".y"))#
      on.exit(setnames(x, paste0(common_names, ".x"), common_names))#
      on.exit(setnames(y, paste0(common_names, ".y"), common_names), add = TRUE)#
    }#
    # set keys and check duplicates#
    key_x <- key(x)#
    key_y <- key(y)#
    setkeyv(x, vars)#
    setkeyv(y, vars)#
    on.exit(setkeyv(x, key_x), add = TRUE)#
    on.exit(setkeyv(y, key_y), add = TRUE)#
#
    if (check[[2]] == 1){#
       if (anyDuplicated(x)){ #
         stop(paste0("Variable(s) ",paste(vars, collapse = " ")," don't uniquely identify observations in the master dataset"), call. = FALSE)#
       }#
     }#
#
    if (check[[3]] == 1){#
     if (anyDuplicated(y)){ #
       stop(paste0("Variable(s) ",paste(vars, collapse = " ")," don't uniquely identify observations in the using dataset"), call. = FALSE)#
     }#
    }#
    if (type %in% c("left", "right", "outer", "inner")){#
      all.x <- FALSE#
      all.y <- FALSE#
      if (type == "left"| type == "outer"){#
        all.x = TRUE#
      }#
      if (type == "right" | type == "outer"){#
        all.y = TRUE#
      }#
      if (!gen == FALSE){#
        if (gen %chin% names(x)){#
          stop(paste0(gen," alreay exists in master"))#
        }#
        if (gen %chin% names(y)){#
          stop(paste0(gen," alreay exists in using"))#
        }#
        idm <- tempname_list("temp", c(names(x),names(y),gen))#
        x[, c(idm) := 1L]#
        idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
        y[, c(idu) := 1L]#
        on.exit(x[, c(idm) := NULL], add = TRUE)#
        on.exit(y[, c(idu) := NULL], add = TRUE) #
      }#
#
      DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
      if (gen != FALSE){#
        DT_output[, c(gen) := 3L]#
        eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
        eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
        DT_output[, c(idm) := NULL]#
        DT_output[, c(idu) := NULL]#
      }#
    } else if (type == "semi"){#
      w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
      w <- w[!is.na(w)]#
      DT_output <- x[w]#
    } else if (type == "anti"){#
      DT_output <- x[!y, allow.cartesian = TRUE]#
    } #
  }#
  DT_output#
}
x <- data.table(a = rep(1:2, each = 3), b=1:6)#
y <- data.table(a = 0:1, bb = 10:11)#
# outer corresponds to Stata joinby keep(master matched using)#
join(x, y, type = "outer")#
# left corresponds to Stata joinby keep(master matched)#
join(x, y, type = "left")#
# right corresponds to Stata joinby keep(mached using)#
join(x, y, type = "right")#
# inner corresponds to Stata joinby keep(matched)#
join(x, y, type = "inner")#
#
join(x, y, type = "semi")#
join(x, y, type = "anti")#
join(x, y, type = "outer", gen = "_merge")#
join(x, y, type = "outer", check = 1~1)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
?setcols
