?biglm
FALSE && NA
true || NA
TRUE || NA
library(tidyr)
library(statar)
df <- data.frame (id=c(1,1), variable = c("v1","v1"), value = c(1,3))
df
spread(df, variable, value)
dt <- as.data.table(df)
dt <- data.table(df)
library(data.table)
dt <- as.data.table(df)
spread(df, variable, value)
spread(dt, variable, value)
library(tidyr)
?expand
devtools::install_github("hadley/tidyr")
f <-function(){#
on.exit(print("salut"))#
}
f(1)
f()
library(tidyr)
devtools::install_github("hadley/tidyr")
library(tidyr)
library(tidyr)
?expand
df <- data.frame(a = c(1, 2, 5), b = c(3, 5, 3), c = c(1, 2, 3))#
expand(df)#
expand(df, a, b)
df
df <- data.frame(a = c(1, 2, 5), b = c(3, 5, 3), c = c(1, 2, 3))#
expand(df)#
expand(df, a, b)
expand(df,a)
expand(df,a,b)
anyDuploicated(data, by = a)
anyDuplicated(setDT(data), by = a)
library(data.table)
anyDuplicated(setDT(data), by = a)
setDT(data)
setDT(df)
anyDuplicated(df, by = a)
anyDuplicated(df, by = c(a))
df
anyDuplicated(df, by = a)
anyDuplicated(df, by = "a")
dt <- expand(df,a,b)
dt
setDT(dt)
dt <- expand(df,a,b)
setDT(dt)
anyDuplicated(df, by = "a")
anyDuplicated(dt, by = "a")
?anyDuplicated
setDF(dt)
dt
dt[, c:=1]
dt[, "c" := 1]
dt[, c := 1]
setDT(dt)
dt[, c := 1]
dt
setDF(dt)
spread(dt,b,c)
setDF(dt)
spread(dt,c,b)
expand(dt,a)
expand(dt,a,b)
expand(dt,a)
rollends
?data.table
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to expand#
#' @param type "within" means that dates are expanded with respect to min and max of \code{...} within groups. "across" means that rows are expanded with respect to min and max of \code{...} across groups.#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date,"across")#
#' DT %>% group_by(id) %>% expand(date)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t), max(t))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  env <- dt_env(.data, common_env(dots))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    call <- substitute(.data[, list(seq.int(t[1], t[.N]))], list(t = as.name(t)))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT <- data.table(#
  id = c(1, 1, 1, 1, 1, 2, 2), #
  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)
DT %>% expand(date)
library(dplyr)
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to expand#
#' @param type "within" means that dates are expanded with respect to min and max of \code{...} within groups. "across" means that rows are expanded with respect to min and max of \code{...} across groups.#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date,"across")#
#' DT %>% group_by(id) %>% expand(date)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t), max(t))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  env <- dt_env(.data, common_env(dots))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    call <- substitute(.data[, list(seq.int(t[1], t[.N]))], list(t = as.name(t)))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to expand#
#' @param type "within" means that dates are expanded with respect to min and max of \code{...} within groups. "across" means that rows are expanded with respect to min and max of \code{...} across groups.#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date,"across")#
#' DT %>% group_by(id) %>% expand(date)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t), max(t))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    call <- substitute(.data[, list(seq.int(t[1], t[.N]))], list(t = as.name(t)))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(date)
DT %>% group_by(id) %>% expand(date,"across")
DT %>% group_by(id) %>% expand(date, type ="across")
DT %>% group_by(id) %>% expand(date, type ="across", roll = TRUE)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to expand#
#' @param type "within" means that dates are expanded with respect to min and max of \code{...} within groups. "across" means that rows are expanded with respect to min and max of \code{...} across groups.#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date,"across")#
#' DT %>% group_by(id) %>% expand(date)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t), max(t))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    call <- substitute(.data[, list(seq.int(t[1], t[.N]))], list(t = as.name(t)))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% group_by(id) %>% expand(date, type ="across", roll = TRUE)
DT
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to expand#
#' @param type  "within" means that rows are expanded with respect to min and max of \code{...} across groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} within groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t), max(t))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    call <- substitute(.data[, list(seq.int(t[1], t[.N]))], list(t = as.name(t)))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% group_by(id) %>% expand(date, type ="across", roll = TRUE)
DT %>% group_by(id) %>% expand(date, type ="across")
DT %>% group_by(id) %>% expand(date,)
DT %>% group_by(id) %>% expand(date)
DT %>% group_by(id) %>% expand(date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to expand#
#' @param type  "within" means that rows are expanded with respect to min and max of \code{...} across groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} within groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t), max(t))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    call <- substitute(.data[, list(seq.int(t[1], t[.N]))], list(t = as.name(t)))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% group_by(id) %>% expand(date)
DT %>% group_by(id) %>% expand(date, roll = TRUE)
DT %>% group_by(id) %>% expand(date, roll = TRUE)
DT %>% expand(id)
DT %>% group_by(id) %>% expand(date, roll = TRUE)
DT %>% expand(date, date)
DT %>% expand(date, id)
DT %>% expand(date, id)
DT %>% expand(date, id)
DT %>% expand(date, value)
DT %>% expand(date)
DT
DT %>% expand(value)
DT %>% expand(value,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t), max(t))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(value,id)
DT %>% expand(id)
DT %>% expand(date,id)
max(c(NA,1))
max(c(NA,1), na.rm = TRUE)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
max(c(NA,1), na.rm = TRUE)
DT %>% expand(date,id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(date,id)
DT
DT[1,id:=NA]
DT %>% expand(id)
DT
DT %>% expand(id)
DT
DT %>% expand(id)
DT %>% expand(id)
DT
?data.table
is.na(DT)
colSum(is.na(DT))
colsum(is.na(DT))
colSum(is.na(DT))
colsSum(is.na(DT))
colSums(is.na(DT))
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[is.na>0]#
  if (length(isna)) stop(paste(isna,"have missing values"))#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  if (length(isna)) stop(paste(isna,"have missing values"))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
colSums(is.na(DT))
DT %>% expand(id)
?data.table
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[is.na>0]#
  if (length(isna)) stop(paste(isna,"have missing values"))#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[is.na>0] #
  if (length(isna)) stop(paste(isna,"have missing values"))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
?data.table
DT %>% expand(id)
isna <- colSums(is.na(DT[,var_name, with = FALSE]))
isna <- colSums(is.na(DT))
isna
is.vector(isna)
is.atomic(isna)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[isna>0]#
  if (length(isna)) stop(paste(isna,"have missing values"))#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[isna>0] #
  if (length(isna)) stop(paste(isna,"have missing values"))#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
is.atomic(isna)
DT %>% expand(id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-names(isna[isna>0])#
  if (length(isna)) stop(paste(isna,"have missing values"),.call= FALSE)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[isna>0] #
  if (length(isna)) stop(paste(isna,"have missing values"),.call= FALSE)#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <- names(isna[isna>0])#
  if (length(isna)) stop(paste(isna,"have missing values"),.call= FALSE)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[isna>0] #
  if (length(isna)) stop(paste(isna,"have missing values"),.call= FALSE)#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <- names(isna[isna>0])#
  if (length(isna)) stop(paste(isna,"have missing values"),call. = FALSE)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[isna>0] #
  if (length(isna)) stop(paste(isna,"have missing values"),call. = FALSE)#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(id)
isna
names(isna)
names(isna[isna>0])
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <- names(isna[isna>0])#
  if (length(isna)) stop(paste(isna,"have missing values"),call. = FALSE)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[isna>0] #
  if (length(isna)) stop(paste(isna,"have missing values"),call. = FALSE)#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
names(isna[isna>0])
DT %>% expand(id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <- names(isna[isna>0])#
  if (length(isna)) stop(paste("Variables",isna,"have missing values"),call. = FALSE)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <-isna[isna>0] #
  if (length(isna)) stop(paste("Variables",isna,"have missing values"),call. = FALSE)#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date)#
#' DT %>% group_by(id) %>% expand(date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ...,type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <- names(isna[isna>0])#
  if (length(isna)) stop(paste("Variables",isna,"have missing values"),call. = FALSE)#
  for (t in var_name) {#
    if (type=="within"){#
      call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(t)))#
    } else{#
      a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
      b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
      call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
    }#
    ans  <- eval(call)#
    setnames(ans, c(byvars, t))#
    setkeyv(ans, c(byvars, t))#
    .data <- copy(.data)#
    setkeyv(.data, c(byvars,t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#
#' @export#
expand_.data.table <- function(.data,...,.dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  isna <- colSums(is.na(DT[,var_name, with = FALSE]))#
  isna <- names(isna[isna>0])#
  if (length(isna)) stop(paste("Variables",isna,"have missing values"),call. = FALSE)#
  for (t in var_name) {#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(t))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(t))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  }#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with = date, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(DT[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (length(isna)) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, t))#
  setkeyv(ans, c(byvars, t))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,t))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  var_name <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(DT[,sum(is.na(t))], list(t = as.name(along_with))))#
  isna <- names(isna[isna>0])#
  if (length(isna)) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(id)
DT %>% expand(along_with =id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with = date, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(DT[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (length(isna)) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, t))#
  setkeyv(ans, c(byvars, t))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,t))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(DT[,sum(is.na(t))], list(t = as.name(along_with))))#
  isna <- names(isna[isna>0])#
  if (length(isna)) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(along_with =id)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with = date, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (length(isna)) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, t))#
  setkeyv(ans, c(byvars, t))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,t))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  isna <- names(isna[isna>0])#
  if (length(isna)) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
traceback()
DT %>% expand(along_with =id)
DT[, sum(is.na(id))]
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with = date, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, t))#
  setkeyv(ans, c(byvars, t))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,t))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with = date, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT[, sum(is.na(id))]
DT %>% expand(along_with =id)
traceback()
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, t))#
  setkeyv(ans, c(byvars, t))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,t))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(along_with =id)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = along_with, type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, t))#
  setkeyv(ans, c(byvars, t))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,t))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(along_with =id)
traceback()
debug(expand)
DT %>% expand(along_with =id)
s
n
along_with
along_with
dplyr::along_with
dplyr:::along_with
DT %>% expand(along_with =id)
along_with
id
DT
lazy(along_with)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = lazy(along_with), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <- lazy_eval(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, t))#
  setkeyv(ans, c(byvars, t))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,t))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
lazy(along_with)
DT %>% expand(along_with =id)
library(lazyeval)
DT %>% expand(along_with =id)
lazy(id)
id
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = substitute(along_with), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <- lazy_eval(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, t))#
  setkeyv(ans, c(byvars, t))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,t))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(along_with =id)
DT %>% expand(along_with = date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = substitute(along_with), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <- lazy_eval(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, along_with))#
  setkeyv(ans, c(byvars, along_with))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,along_with))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(t))#
    setkeyv(ans, c(t))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(along_with = date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = substitute(along_with), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <- lazy_eval(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, along_with))#
  setkeyv(ans, c(byvars, along_with))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,along_with))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(t))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(along_with))#
    setkeyv(ans, c(along_with))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(along_with = date)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = substitute(along_with), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <- lazy_eval(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, along_with))#
  setkeyv(ans, c(byvars, along_with))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,along_with))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(along_with))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(along_with))#
    setkeyv(ans, c(along_with))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% expand(along_with = date)
lazy_eval(along_with)
lazy_eval(quote(along_with))
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = substitute(along_with), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <-names(select_vars_(names(.data), lazy_eval(along_with)))#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, along_with))#
  setkeyv(ans, c(byvars, along_with))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,along_with))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <-names(select_vars_(names(.data), lazy_eval(along_with)))#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(along_with))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(along_with))#
    setkeyv(ans, c(along_with))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
lazy_eval(quote(along_with))
DT %>% expand(along_with = date)
traceback()
lazy_eval(along_with)
lazy_eval(quote(id))
lazy_eval(quote(id))
as.character(quote(id)))
as.character(quote(id))
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Integer variables to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% expand(date)#
#' DT %>% group_by(id) %>% expand(..., along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = substitute(along_with), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <-as.character(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  byvars <- as.character(groups(.data))#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, along_with))#
  setkeyv(ans, c(byvars, along_with))#
  .data <- copy(.data)#
  setkeyv(.data, c(byvars,along_with))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <-as.character(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(along_with))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(along_with))#
    setkeyv(ans, c(along_with))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
as.character(quote(id))
DT %>% expand(along_with = date)
DT
DT %>% group_by(id) %>% expand(along_with = date)
DT %>% group_by(id) %>% expand(along_with = date, roll = TRUE)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to keep#
#' @param along_with integer variable to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% group_by(id) %>% expand(along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = substitute(along_with), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <-as.character(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  byvars <- as.character(groups(.data))#
  vars <- names(select_vars_(names(.data), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, along_with))#
  setkeyv(ans, c(byvars, along_with))#
  .data <- data[, c(byvars,vars) with = FALSE]#
  setkeyv(.data, c(byvars,along_with))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <-as.character(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(along_with))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(along_with))#
    setkeyv(ans, c(along_with))#
    .data <- data[, vars, with = FALSE]#
    setkeyv(.data, c(along_with))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod(), copy = FALSE)#
}
DT %>% group_by(id) %>% expand(along_with = date, roll = TRUE)
DT
DT %>% group_by(id) %>% expand(along_with = date, type = "accross", roll = TRUE)
DT %>% group_by(id) %>% expand(along_with = date, type = "across", roll = TRUE)
DT %>% group_by(id) %>% expand(along_with = date, type = "across")
DT %>% group_by(id) %>% expand(value, along_with = date, type = "across")
DT %>% group_by(id) %>% expand(date, along_with = date, type = "across")
DT %>% group_by(id) %>% expand(id, along_with = date, type = "across")
DT %>% group_by(id) %>% expand(date, along_with = date, type = "across")
DT
debug(expand)
DT %>% group_by(id) %>% expand(date, along_with = date, type = "across")
s
n
vars
ans
ans
ans
q
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#'  Fill in gaps in variable#
#'#
#' @param .data A tbl_dt, grouped or not#
#' @param ... Variables to keep#
#' @param along_with integer variable to expand#
#' @param type  "within"  means that rows are expanded with respect to min and max of \code{...} within groups (default) while "default" means that dates are expanded with respect to min and max of \code{...} across groups. #
#' @param roll see ?data.table#
#' @param rollends see ?data.table#
#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' DT <- data.table(#
#'  id = c(1, 1, 1, 1, 1, 2, 2), #
#'  date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
#'  value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
#')#
#' DT %>% group_by(id) %>% expand(along_with = date)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, roll = TRUE)#
#' DT %>% group_by(id) %>% expand(..., along_with =date, type == "across", roll = TRUE)#
#' @name expand#
NULL#
#
#' @export#
#' @rdname expand#
expand <- function(.data, ..., along_with, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  expand_(.data, .dots = lazyeval::lazy_dots(...), along_with = substitute(along_with), type = type, roll = roll, rollends = rollends)#
}#
#
#' @export#
#' @rdname expand#
expand_ <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ) {#
  UseMethod("expand_")#
}#
#
#' @export#
expand_.grouped_dt <- function(.data,...,along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <-as.character(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  byvars <- as.character(groups(.data))#
  vars <- names(select_vars_(names(.data), dots, exclude = byvars))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  type <- match.arg(type)#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
  if (type=="within"){#
    call <- substitute(.data[, list(seq.int(min(t, na.rm = TRUE), max(t, na.rm = TRUE))), by = c(byvars)], list(t = as.name(along_with)))#
  } else{#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b)), by = c(byvars)], list(a = a, b=b))#
  }#
  ans  <- eval(call)#
  setnames(ans, c(byvars, along_with))#
  setkeyv(ans, c(byvars, along_with))#
  .data <- data[, c(byvars,vars) with = FALSE]#
  setkeyv(.data, c(byvars,along_with))#
  .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
    .data#
}#
#
#' @export#
expand_.data.table <- function(.data,..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE) ){#
  along_with <-as.character(along_with)#
  dots <- lazyeval::all_dots(.dots, ...)#
  vars <- names(select_vars_(names(.data), dots))#
  if (length(vars) == 0) {#
     vars <- names(.data)#
  }#
  isna <- eval(substitute(.data[,sum(is.na(t))], list(t = as.name(along_with))))#
  if (isna>0) stop(paste("Variable",along_with,"have missing values"),call. = FALSE)#
    setkeyv(.data,c(along_with))#
    a <- eval(substitute(.data[,min(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    b <- eval(substitute(.data[,max(t, na.rm = TRUE)], list(t = as.name(along_with))))#
    call <- substitute(.data[, list(seq.int(a, b))], list(a = a, b=b))#
    ans  <- eval(call)#
    setnames(ans, c(along_with))#
    setkeyv(ans, c(along_with))#
    .data <- data[, vars, with = FALSE]#
    setkeyv(.data, c(along_with))#
    .data <- .data[ans,allow.cartesian=TRUE, roll = roll, rollends = rollends]#
  .data#
}#
#' @export#
expand_.tbl_dt <- function(.data, ..., along_with, .dots, type = c("within", "across"), roll = FALSE, rollends = if (roll=="nearest") c(TRUE,TRUE)#
             else if (roll>=0) c(FALSE,TRUE)#
             else c(TRUE,FALSE)) {#
  tbl_dt(NextMethod())#
}
DT %>% group_by(id) %>% expand(date, along_with = date, type = "across")
debug(expand)
DT %>% group_by(id) %>% expand(date, along_with = date, type = "across")
s
