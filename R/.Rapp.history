install.packages("/Users/Matthieu/Dropbox/Github/dplyr", repos = NULL, type="source")
DT
DT %>% select(v1)
library(dplyr)
DT %>% select(v1)
DT
DT %>% select(v1,inplace = TRUE)
mutate
select
debug(select)
DT %>% select(v1,inplace = TRUE)
s
n
inplace
DT %>% mutate(mean(v1),inplace = TRUE)
debug(mutate)
DT %>% mutate(mean(v1),inplace = TRUE)
s
inplace
q
f
?lazy_eval::all_dots
?lazyeval::all_dots
DT %>% mutate(mean(v1),inplace = TRUE)
s
n
dots
inplace
DT %>% mutate(mean(v1),inplace = TRUE)
DT
f
setdiff
DT %>% mutate_each(mean,inplace = TRUE)
DT %>% mutate_each(funs(mean),inplace = TRUE)
?select
DT %>% select(v1,inplace = TRUE)
s
n
vars
setdiff(vars,names(.data))
names(.data)
setdiff(names(.data),vars)
DT %>% select(v1,inplace = TRUE)
s
n
dots
dots$inplace
dots$inplace==TRUE
dots$inplace$code==TRUE
dots$inplace$code
dots$inplace
ls(dots$inplace)
names(dots$inplace)
is.env(dots$inplace)
dots$inplace
attr(dots$inplace)
attributes(dots$inplace)
dots$inplace$expr
names(dots)
dots$inplace <- NULL
dots$inplace
dots[[2]] <- NULL
dots
DT %>% select(v1,inplace = TRUE)
s
dots
n
dots
match("inplace",dots)
match("inplace",names(dots))
install.packages("/Users/Matthieu/Dropbox/Github/dplyr", repos = NULL, type="source")
DT %>% select(v1,inplace = TRUE)
library(dplyr)
DT %>% select(v1,inplace = TRUE)
s
]]]]]
f
ff
install.packages("/Users/Matthieu/Dropbox/Github/dplyr", repos = NULL, type="source")
library(dplyr)
DT %>% select(v1,inplace = TRUE)
DT
DT %>% select(v1,inplace = TRUE)
s
f
library(plyr)
suppressMessages(library("data.table"))
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT %>% select(v1,inplace = TRUE)
DT
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT %>% select(v1)
DT
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT %>% mutate_each(mean, inplace = TRUE)
DT %>% mutate_each(funs(mean), inplace = TRUE)
DT %>% mutate_each(funs(mean))
DT
DT %>% mutate(mean(v1),inplace=TRUE)
DT
debug(mutate_each)
DT %>% mutate_each(funs(mean))
s
f
n
s
n
dots
f
DT %>% mutate_each(funs(mean),inplace=TRUE)
s
n
DT %>% mutate_each(funs(mean),inplace=TRUE)
s
n
DT %>% mutate_each(funs(mean),inplace=TRUE)
s
n
s
n
vars
vars$inplace
install.packages("/Users/Matthieu/Dropbox/Github/dplyr", repos = NULL, type="source")
library(dplyr)
DT %>% mutate_each(funs(mean),inplace=TRUE)
n
library(dplyr)
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
suppressMessages(library("dplyr"))
suppressMessages(library("data.table"))
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
#sink.reset
DT %>% mutate_each(funs(mean), inplace = TRUE)
DT
vars
DT %>% mutate_each(funs(mean), inplace = TRUE)
debug(mutate_each)
DT %>% mutate_each(funs(mean), inplace = TRUE)
s
f
n
vars
length(TRUE)
is.atomic(TRUE)
is.atomic(c(TRUE.TRUE))
is.atomic(c(TRUE,TRUE))
dots
l=llist(1="ok")
l=list(1="ok")
l=list(ok = "ok")
l$NA
install.packages("/Users/Matthieu/Dropbox/Github/dplyr", repos = NULL, type="source")
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
suppressMessages(library("data.table"))
suppressMessages(library("dplyr"))
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT %>% mutate_each(funs(mean))
DT
DT %>% mutate_each(funs(mean), inplace = TRUE)
DT
install.packages("/Users/Matthieu/Dropbox/Github/dplyr", repos = NULL, type="source")
suppressMessages(library("tidyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT %>% mutate_each(funs(mean), inplace = TRUE)
DT
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT %>% mutate_each(funs(mean), inplace = FALSE)
DT
DT %>% select(v2, inplace = FALSE)
library(dpsuppressMessages(library("tidyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))
suppressMessages(library("tidyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT %>% select(v1)
DT
DT %>% select(v1, inplace = TRUE)
DT
#' Gives summary statistics (Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude in s You can use same specifications as in select. If missing, defaults to all non-grouping variables.#
#' @param inplace Change data.table in place or not#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 =  sample(5, N, TRUE),                          #
#'   v2 =  sample(1e6, N, TRUE),                       #
#'   v3 =  sample(round(runif(100, max = 100), 4), N, TRUE) #
#' )#
#' DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#' @export#
colorder <- function(.data, ..., inplace = FALSE) {#
  colorder_(.data, vars = lazyeval::lazy_dots(...) , inplace = inplace)#
}#
#' @export#
colorder_ <- function(.data, vars, inplace = FALSE ) {#
  if (length(vars) == 0) {#
     vars <- lazyeval::lazy_dots(everything())#
   }#
  vars <- select_vars_(tbl_vars(.data), vars)#
  if (!inplace) .data <- copy(.data)#
  setcolorder(.data,vars,setdiff(names(.data),vars))#
  .data#
}
DT  %>% colorder(starts_with("v"), inplace = TRUE)
#' Gives summary statistics (Stata command summarize)#
#' #
#' @param DT A tbl_dt or tbl_grouped_dt.#
#' @param ... Variables to include/exclude in s You can use same specifications as in select. If missing, defaults to all non-grouping variables.#
#' @param inplace Change data.table in place or not#
#' @examples#
#' library(data.table)#
#' library(dplyr)#
#' N <- 100; K <- 10#
#' DT <- data.table(#
#'   id = 1:N,#
#'   v1 =  sample(5, N, TRUE),                          #
#'   v2 =  sample(1e6, N, TRUE),                       #
#'   v3 =  sample(round(runif(100, max = 100), 4), N, TRUE) #
#' )#
#' DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#' @export#
colorder <- function(.data, ..., inplace = FALSE) {#
  colorder_(.data, vars = lazyeval::lazy_dots(...) , inplace = inplace)#
}#
#' @export#
colorder_ <- function(.data, vars, inplace = FALSE ) {#
  if (length(vars) == 0) {#
     vars <- lazyeval::lazy_dots(everything())#
   }#
  vars <- select_vars_(tbl_vars(.data), vars)#
  if (!inplace) .data <- copy(.data)#
  setcolorder(.data,c(vars,setdiff(names(.data),vars)))#
  .data#
}
DT  %>% colorder(starts_with("v"), inplace = TRUE)
DT
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
DT  %>% colorder(starts_with("v"), inplace = TRUE)
DT
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
library(dplyr)#
library(statar)#
#
N=1e6; K=100#
set.seed(1)#
DT <- data.table(#
      id = 1:N,#
      v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
      v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
      v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
    )#
#
### quantile category (=Stata xtile)#
DT %>% group_by(v1) %>% mutate(xtile(v2, nq = 3))#
DT %>% group_by(v1) %>% mutate(xtile(v2, cutpoints = c(1e5,5e5) ))
DT %>% group_by(id) %>% mutate(lag(value, order_by = time)) # Balanced dataset#
DT %>% group_by(id) %>% mutate(lag(value, along_with = time)) # Unbalanced dataset
DT %>% group_by(id) %>% mutate(lag(value, order_by = time)) # Balanced dataset
DT %>% group_by(id) %>% mutate(lag(v2, order_by = time)) # Balanced dataset
DT %>% group_by(id) %>% mutate(lag(v2, along_with = time)) # Unbalanced dataset
DT %>% group_by(id) %>% mutate(lag(v2, order_by = v1))
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))
library(data.table)#
#
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
### col_order (= Stata order)#
DT  %>% col_order(starts_with("v"))#
DT  %>% col_order(starts_with("v"), inplace = TRUE)#
#
### sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))#
#
### expand (= Stata tsfill)#
DT <- data.table(#
 id = c(1, 1, 1, 1, 1, 2, 2),#
 date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
 value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% group_by(id) %>% expand(date)#
DT %>% expand(date)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
?spread
?gather
library(tidyr)
?gather
stocks <- data.frame(#
  time = as.Date('2009-01-01') + 0:9,#
  X = rnorm(10, 0, 1),#
  Y = rnorm(10, 0, 2),#
  Z = rnorm(10, 0, 4)#
)
stocks
socks %>% gather(type, price)
library(dplyr)
socks %>% gather(type, price)
stocks %>% gather(type, price)
DT_long <- DT_wide %>% gather(variable, value, -time)
DT_long <- stocks %>% gather(variable, value, -time)
DT_long
DT_long <- DT_wide %>% spread (variable, value, -time)
DT_wide <- DT_long %>% spread (variable, value, -time)
?spread
DT_wide <- DT_long %>% spread(variable, value, -time)
DT_wide <- DT_long %>% spread(variable, value)
DT_wide
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2(4.5,3.0)))
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2(4.5,3.0))
library(data.table)
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2(4.5,3.0))
DT_wide <- data.table (i=c(1,2), stub1=c(4.1,4.5), stub2=c(4.5,3.0))
DT_wide
DT_wide %>% gather(variable, value, -i)
DT_long <- DT_wide %>% gather(variable, value, -i)
DT_long %>% spread(variable, value)
assignInNamespace("cedta.override", c(data.table:::cedta.override,"IRkernel#
                                      "), "data.table")
showMethods(expand)
library(matrix)
showMethods(expand)
library(Matrix)
showMethods(expand)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
library(statar)
library(data.table)
?hour
library(matrix)
library(Matrix)
?expand
showMethods(Matrix)
is.object(expand) & !isS4(expand)
is.object(expand
)
!isS4(expand)
isS4(expand)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
library(lubridate)
weeks
months
months(1)
years(1)
years
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
library(biglm)#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))
?expand
?expand_
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
lag
?lag
?lead
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
library(biglm)#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))
?lag
?lead
?expand
?xtile
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
?sum_up
library(statar)
?sum_up
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(statar)
?sum_up
library(statar)
?sum_up
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
lead_along <- function(x, n = 1L, units = NULL, date, default = NA) {#
  if (!is.null(units)) {#
    if (is.null(date)) stop("units cannot be used without order_by")#
    unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
    date_origin <- as.Date('0001-01-01')#
    if (unitsc=="day"){#
      return(lead_along(x = x, n = n, default = default, date = along))#
    }#
    if (unitsc == "week"){#
      date_elapsed <- as.period(date-date_origin)  %/% weeks(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    }  #
    else if (unitsc == "month"){#
      date_elapsed <- as.period(date-date_origin)  %/% months(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    } else if (unitsc == "quarter"){#
      date_elapsed <- as.period(date-date_origin)  %/% 3*months(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    } else if (unitsc == "year"){#
      date_elapsed <- as.period(date-date_origin)  %/% years(1)#
      return(lead_along(x = x, n = n, default = default, date = date_elapsed))#
    }#
  }#
#
  if (n == 0) return(x)#
  if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
  index <- match(date + n, date, incomparable = NA)#
  out <- x[index]#
  if (!is.na(default)) out[which(is.na(index))] <- default#
  attributes(out) <- attributes(x)#
  out#
}
lag_along <- function(x, n = 1L,  units = NULL, date = NULL, default = NA) {#
    if (!is.null(units)) {#
      if (is.null(date)) stop("units cannot be used without order_by")#
      unitsc <-match.arg(units,c("day","week","month","quarter","year"))#
      date_origin <- as.Date('0001-01-01')#
      if (unitsc=="day"){#
        return(lag_along(x = x, n = n, default = default, date = along))#
      }#
      if (unitsc == "week"){#
        date_elapsed <- as.period(date-date_origin)  %/% weeks(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      }  #
      else if (unitsc == "month"){#
        date_elapsed <- as.period(date-date_origin)  %/% months(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      } else if (unitsc == "quarter"){#
        date_elapsed <- as.period(date-date_origin)  %/% 3*months(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      } else if (unitsc == "year"){#
        date_elapsed <- as.period(date-date_origin)  %/% years(1)#
        return(lag_along(x = x, n = n, default = default, date = date_elapsed))#
      }#
    }#
#
    if (n == 0) return(x)#
    if (n < 0 || length(n) > 1) stop("n must be a single positive integer")#
    index <- match(date - n, date, incomparable = NA)#
    out <- x[index]#
    if (!is.na(default)) out[which(is.na(index))] <- default#
    attributes(out) <- attributes(x)#
    out#
  }
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
date := as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%y")
date = as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%y")
date+1
date
date = as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%y")
date
?as.Date
date = as.Date(c("01/03/1992", "03/04/1992", "05/05/1992", "21/08/1992"), "%m/%d/%Y")
date
devtools::install_github("matthieugomez/tidyr")#
devtools::install_github("matthieugomez/lazyeval")#
devtools::install_github("matthieugomez/dplyr")#
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(dplyr)#
library(data.table)#
library(statar)#
#
# partition creates quantile categories (corresponds to Stata xtile)#
v2 <-   sample(1e6, 1e6, TRUE)                   #
v2_categorized <- partition(v2, nq = 3) # 3 groups based on terciles#
v2_categorized <- partition(v2, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
# lag/lead create lag/lead variables (corresponds to Stata L. F.)#
## unbalanced panel#
DT <- data.frame(#
 date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
 value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% mutate(lag(value, 1, order_by = date)) # wrong#
DT %>% mutate(lag(value, 1, along_with = date)) # right#
#
## periods can be used instead of integers#
library(lubridate)#
df <- data.frame(     #
   id = c("id1", "id1", "id1", "id1"),#
   date = mdy(c("03/01/1992", "04/03/1992", "07/15/1992", "08/21/1992")),#
   value = c(4.1, 4.5, 3.3, 5.3)#
)#
df <- df %>% mutate(date = floor_date(date, "month"))#
df %>% group_by(id) %>% mutate(lag(value, months(1), along_with = date))
?data.table::lag
?lag
library(data.table)
library(dplyr)
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }#
#
DT <- data.table(#
   id = c(1, 1, 1, 1, 1, 2, 2),#
   date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
   value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
#
R> DT#
   id date value#
1:  1 1992   4.1#
2:  1 1989   4.5#
3:  1 1991   3.3#
4:  1 1990   5.3#
5:  1 1994   3.0#
6:  2 1992   3.2#
7:  2 1991   5.2#
R> DT %>% group_by(id) %>% mutate( lead_lag(value,1) )#
Source: local data table [7 x 4]#
Groups: id#
#
  id date value lead_lag(value, 1)#
1  1 1992   4.1                4.5#
2  1 1989   4.5                4.5#
3  1 1991   3.3                4.5#
4  1 1990   5.3                4.5#
5  1 1994   3.0                4.5#
6  2 1992   3.2                5.2#
7  2 1991   5.2                5.2#
R>
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }#
#
DT <- data.table(#
   id = c(1, 1, 1, 1, 1, 2, 2),#
   date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
   value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
#
DT#
   id date value#
1:  1 1992   4.1#
2:  1 1989   4.5#
3:  1 1991   3.3#
4:  1 1990   5.3#
5:  1 1994   3.0#
6:  2 1992   3.2#
7:  2 1991   5.2#
DT %>% group_by(id) %>% mutate( lead_lag(value,1) )#
Source: local data table [7 x 4]#
Groups: id#
#
  id date value lead_lag(value, 1)#
1  1 1992   4.1                4.5#
2  1 1989   4.5                4.5#
3  1 1991   3.3                4.5#
4  1 1990   5.3                4.5#
5  1 1994   3.0                4.5#
6  2 1992   3.2                5.2#
7  2 1991   5.2                5.2#
R>
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }#
#
DT <- data.table(#
   id = c(1, 1, 1, 1, 1, 2, 2),#
   date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
   value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)
R> DT %>% group_by(id) %>% mutate( lead_lag(value,1) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1,order_by(date)) )
debug(lead_lag)
DT %>% group_by(id) %>% mutate( lead_lag(value,1,order_by(date)) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1)) )
DT %>% group_by(id) %>% mutate( lead_lag(value,1))
s
n
s
debug(lead_lag)
lead_lag(DT$value,1)
s
f
lead_lag(value,1)
s
f
undebug(lead_lag)
lead_lag <- function(x, k=0){ ifelse( k<0, lag(x, -k), lead(x, k) ) }
lead_lag(c(1,2),k=1)
lag(c(1,2),n=1)
sign(k){if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}
sign(k){if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}}
lead_lag(k) <- function{if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}}
lead_lag(k) <- function(k){if (k>0){function(x){lag(x,k)}else{function(x){lead(x,k)}}
lead_lag(k) <- function(k){if (k>0){function(x){lag(x,k)}}else{function(x){lead(x,k)}}
}
lead_lag <- function(k){if (k>0){function(x){lag(x,k)}}else{function(x){lead(x,k)}}}
lea_lag(3)(c(1,2)
_
lea_lag(3)(c(1,2))
lead_lag(3)(c(1,2))
lead_lag(1)(c(1,2))
?ifelse
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100,max=100), 4), N, TRUE)#
  )#
#
# colorder (= Stata order)#
DT  %>% colorder(starts_with("v"))#
DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))
library(statar)
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100,max=100), 4), N, TRUE)#
  )#
#
# colorder (= Stata order)#
DT  %>% colorder(starts_with("v"))#
DT  %>% colorder(starts_with("v"), inplace = TRUE)#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
suppressMessages(library("data.table"))#
suppressMessages(library("biglm"))#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT[, condition := id>100]#
system.time(DT[ id >100, coefficients(biglm(v3 ~ v2 + v1, .SD)), .SDcols = c("v1","v2","v3")])#
system.time(DT[, coefficients(biglm(v3 ~ v2 + v1, .SD)), by = "condition", .SDcols = c("v1","v2","v3")])#
system.time(coefficients(biglm(v3 ~ v2 + v1, DT[id>100, c("v1","v2","v3"), with = FALSE])
)
suppressMessages(library("data.table"))#
suppressMessages(library("biglm"))#
N=1e7; K=100#
set.seed(1)#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
DT[, condition := id>100]
system.time(DT[, coefficients(biglm(v3 ~ v2 + v1, .SD)), by = condition, .SDcols = c("v1", "v2", "v3")])
library(Matrix)
?expand
isS4(expand)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
?expand
DT <- data.table(#
    id = c(1, 1, 1, 1, 1, 2, 2),#
    date = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
    value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% expand(date)
library(dpryr)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
?lag
lag
devtools::install_github("smbache/magrittr")
library(magrittr)
rnorm(100) %T>%#
  plot(type = "l", col = "firebrick") %>%#
  abs %>%#
  sum
tmp :=#
  subset(Species == "setosa") %>%#
  set_names(LETTERS[1:5])
install.packages("colorout")
download.file("http://www.lepem.ufc.br/jaa/colorout_1.0-3.tar.gz", destfile = "colorout_1.0-3.tar.gz")#
install.packages("colorout_1.0-3.tar.gz", type = "source", repos = NULL)
savehistory
savehistory(ok)
savehistory("ok")
savehistory("~/.R.app.history")
savehistory()
fefe
savehistory()
library(pryr)
N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )
DT
DF
DT <- setDF(DF)
library(data.table)
DT <- setDF(DF)
DT
DT1 <- copy(DT)
object_size(DT,DT1)
object_size(DT)
object_size(DT,DT1)
object_size(DT,DT1, merge(DT,DT1)
)
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2)]#
	object_size(DF, DF1)#
	17.4 kB#
	object_size(DF, DF3)#
	25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	17.4 kB#
	object_size(DF, DF3)#
	25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
}
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	17.4 kB#
	object_size(DF, DF3)#
	25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	#> 17.4 kB#
	object_size(DF, DF3)#
	#> 25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
q
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	#> 17.4 kB#
	object_size(DF, DF3)#
	#> 25.9 kB#
	object_size(DF,DF3, merge(DF,DF3)
)
library(pryr)#
	N <- 1e3#
	DF <- data.frame(#
	  id = sample(c("id01","id02","id03"), N, TRUE),     #
	  v1 = sample(5, N, TRUE),                          #
	  v2 =  sample(round(runif(100, max = 100),4), N, TRUE) #
	  )#
	DF1 <- DF$v1#
	DF2 <- DF[1:(5e2),]#
	object_size(DF, DF1)#
	#> 17.4 kB#
	object_size(DF, DF2)#
	#> 25.9 kB#
	object_size(DF,DF2, merge(DF,DF2)
)
library(tidyr)
?gather
DTx <- data.table (#
  gvkey = c("2222","2222"), #
  permno = c("20990", "20980"), #
  year_min = c(1991,2000), #
  year_max = c(1999, 2001)#
)
debugdebug(mutate)
debug(mutate)
library(dplyr)
DT <- data.table ( id = 1:10)
mutate(DT, mean(id))
debug(mutate)
DT <- data.table ( id = 1:10)
mutate(DT, mean(id))
s
n
?forder
DT
DT[1, id:= NA]
DT
forder(DT,id)
DT[order(id)]
setorder(DT,id)
DT
?setorder
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
suppressMessages(library("biglm"))#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))#
assignInNamespace("cedta.override",#
                  c(data.table:::cedta.override,"IRkernel"),#
                  "data.table")
N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
result1 <- felm( v4 ~ v2 + v1, DT )#
result2 <- felm( v3 ~ v2 + v1, DT )#
result3 <- felm( v4 ~ v3 + v1 |0| (v3 ~ v2) |0, DT )
ivreg
library(aer)
library(AER)
ivreg(v3~v1,DT)
?ivreg
ivreg(v3~v2 | v1,DT)
ivreg(v3 ~ v2 | v1,D T)
ivreg(v3 ~ v2 | v1, DT)
?ivreg
ivreg(v3 ~ v2 | v1, DT)
ivreg(v3 ~ v2 | v1, date = DT)
ivreg(v3 ~ v2 | v1, data = DT)
library("lfe")#
N <- 1e6#
df <- data.frame(#
   v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
)#
felm(v1~v2|0|(v2~v3)|0, df)
library("lfe")#
N <- 1e6#
df <- data.frame(#
   v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
felm(v1~v2|0|(v2~v3)|0, df)
library("lfe")#
N <- 1e6#
df <- data.frame(#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100, max = 100), 4), N, TRUE) # numeric e.g. 23.5749#
)#
felm(v1 ~ v2 | 0 | (v2 ~ v3) |0, df)
felm(v1 ~ v2 | 0 | (v2 ~ v3) |, df)
felm(v1 ~ v2 |  | (v2 ~ v3) |, df)
felm(v1 ~ v2 |  | (v2 ~ v3) |0, df)
felm(v1 ~ v2 |  | (v2 ~ v3), df)
felm(v1 ~ v2 |0| (v2 ~ v3), df)
setwd("/Users/Matthieu/Dropbox/Symlink")#
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
suppressMessages(library("biglm"))#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))#
assignInNamespace("cedta.override",#
                  c(data.table:::cedta.override,"IRkernel"),#
                  "data.table")
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param DTm The master data.table#
#' @param DTu The using data.table#
#' @param type The type of join among "outer", "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifies 1 at the rhs or lhs checks that indeed variables uniquely identify observations.#
#' @return A data.table that joins rows in master and using datases. Matching is done on common names. Keys are set onmaster and using  data.tables.#
#' @examples#
#'  join(DTm, DTu, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(DTm, DTu, type , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(DTm)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(DTu)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
#
  vars <- intersect(names(DTm), names(DTu))#
  message(paste0("Join based on : ", paste(vars, collapse = " ")))#
  setkeyv(DTm, vars)#
  setkeyv(DTu, vars)#
  message(paste0("Master and using datasets are now keyed by : ", paste(vars, collapse = " ")))#
#
  if (check[1] == "1"){#
     if (anyDuplicated(DTm)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(DTu)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(DTm)){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(DTu)){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(DTm),names(DTu),gen))#
      DTm[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(DTm),names(DTu),gen,idm))#
      DTu[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(DTm, DTu, all.x= all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (!gen == FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      DTm[, c(idm) := NULL]#
      DTu[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(DTm[DTu, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- DTm[w]#
  } else if (type == "anti"){#
    DT_output <- DTm[!DTu, allow.cartesian = TRUE]#
  } #
  DT_output#
}
?merge
(dt1 <- data.table(A = letters[1:10], X = 1:10, key = "A"))#
    (dt2 <- data.table(A = letters[5:14], Y = 1:10, key = "A"))
join(dt1,dt2)
join(dt1,dt2, type = "outer")
#' Join two data.tables together #
#' #
#' @param DTm The master data.table#
#' @param DTu The using data.table#
#' @param type The type of join among "outer", "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifies 1 at the rhs or lhs checks that indeed variables uniquely identify observations.#
#' @return A data.table that joins rows in master and using datases. Matching is done on common names. Keys are set onmaster and using  data.tables.#
#' @examples#
#'  join(DTm, DTu, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(DTm, DTu, type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(DTm)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(DTu)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
#
  vars <- intersect(names(DTm), names(DTu))#
  message(paste0("Join based on : ", paste(vars, collapse = " ")))#
  setkeyv(DTm, vars)#
  setkeyv(DTu, vars)#
  message(paste0("Master and using datasets are now keyed by : ", paste(vars, collapse = " ")))#
#
  if (check[1] == "1"){#
     if (anyDuplicated(DTm)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(DTu)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(DTm)){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(DTu)){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(DTm),names(DTu),gen))#
      DTm[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(DTm),names(DTu),gen,idm))#
      DTu[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(DTm, DTu, all.x= all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (!gen == FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      DTm[, c(idm) := NULL]#
      DTu[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(DTm[DTu, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- DTm[w]#
  } else if (type == "anti"){#
    DT_output <- DTm[!DTu, allow.cartesian = TRUE]#
  } #
  DT_output#
}
join(dt1,dt2, type = "outer")
join(dt1,dt2)
join(dt1,dt2, type = "innter")
join(dt1,dt2, type = "inner")
join(dt1,dt2, type = "left")
join(dt1,dt2, type = "anti")
join(dt1,dt2, type = "semi")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
names(c(1))
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param DTm The master data.table#
#' @param DTu The using data.table#
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. Matching is done on common names. Keys are set onmaster and using  data.tables.#
#' @examples#
#'  join(DTm, DTu, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(DTm, DTu, on = intersect(names(DTm),names(DTu)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(DTm)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(DTu)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
#
  if is.null(names(on)){#
    names(on) <- on#
  }#
  vars <- names(on)#
  message(paste0("Join based on : ", paste(vars, collapse = " ")))#
  names_DTm <- names(DTm)#
  names_DTu <- names(DTu)#
  x <- intersect(vars, setdiff(names_DTu, on)){#
  setnames(DTu, x, paste0(x,".y"))#
  setnames(DTu, on , names(on))#
#
  x <- setdiff(intersect(names_DTm, names_DTu), vars)#
  setnames(DTm, x, paste0(x, ".x"))#
  setnames(DTm, x, paste0(x, ".y")) #
  setkeyv(DTm, vars)#
  setkeyv(DTu, vars)#
  message(paste0("Master is now keyed by : ", paste(vars, collapse = " ")))#
  message(paste0("Using is now keyed by : ", paste(on, collapse = " ")))#
#
  if (check[1] == "1"){#
     if (anyDuplicated(DTm)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(DTu)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names_DTm){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names_DTu){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(DTm),names(DTu),gen))#
      DTm[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(DTm),names(DTu),gen,idm))#
      DTu[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(DTm, DTu, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (!gen == FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      DTm[, c(idm) := NULL]#
      DTu[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(DTm[DTu, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- DTm[w]#
  } else if (type == "anti"){#
    DT_output <- DTm[!DTu, allow.cartesian = TRUE]#
  } #
  setnames(DTu, names_DTu)#
  setnames(DTm, names_DTm)#
  DT_output#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param DTm The master data.table#
#' @param DTu The using data.table#
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. Matching is done on common names. Keys are set onmaster and using  data.tables.#
#' @examples#
#'  join(DTm, DTu, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(DTm, DTu, on = intersect(names(DTm),names(DTu)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(DTm)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(DTu)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
#
  if (is.null(names(on)){#
    names(on) <- on#
  }#
  vars <- names(on)#
  message(paste0("Join based on : ", paste(vars, collapse = " ")))#
  names_DTm <- names(DTm)#
  names_DTu <- names(DTu)#
  x <- intersect(vars, setdiff(names_DTu, on)){#
  setnames(DTu, x, paste0(x,".y"))#
  setnames(DTu, on , names(on))#
#
  x <- setdiff(intersect(names_DTm, names_DTu), vars)#
  setnames(DTm, x, paste0(x, ".x"))#
  setnames(DTm, x, paste0(x, ".y")) #
  setkeyv(DTm, vars)#
  setkeyv(DTu, vars)#
  message(paste0("Master is now keyed by : ", paste(vars, collapse = " ")))#
  message(paste0("Using is now keyed by : ", paste(on, collapse = " ")))#
#
  if (check[1] == "1"){#
     if (anyDuplicated(DTm)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(DTu)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names_DTm){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names_DTu){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(DTm),names(DTu),gen))#
      DTm[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(DTm),names(DTu),gen,idm))#
      DTu[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(DTm, DTu, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (!gen == FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      DTm[, c(idm) := NULL]#
      DTu[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(DTm[DTu, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- DTm[w]#
  } else if (type == "anti"){#
    DT_output <- DTm[!DTu, allow.cartesian = TRUE]#
  } #
  setnames(DTu, names_DTu)#
  setnames(DTm, names_DTm)#
  DT_output#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param DTm The master data.table#
#' @param DTu The using data.table#
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. Matching is done on common names. Keys are set onmaster and using  data.tables.#
#' @examples#
#'  join(DTm, DTu, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(DTm, DTu, on = intersect(names(DTm),names(DTu)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(DTm)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(DTu)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
#
  if (is.null(names(on))){#
    names(on) <- on#
  }#
  vars <- names(on)#
  message(paste0("Join based on : ", paste(vars, collapse = " ")))#
  names_DTm <- names(DTm)#
  names_DTu <- names(DTu)#
  x <- intersect(vars, setdiff(names_DTu, on)){#
  setnames(DTu, x, paste0(x,".y"))#
  setnames(DTu, on , names(on))#
#
  x <- setdiff(intersect(names_DTm, names_DTu), vars)#
  setnames(DTm, x, paste0(x, ".x"))#
  setnames(DTm, x, paste0(x, ".y")) #
  setkeyv(DTm, vars)#
  setkeyv(DTu, vars)#
  message(paste0("Master is now keyed by : ", paste(vars, collapse = " ")))#
  message(paste0("Using is now keyed by : ", paste(on, collapse = " ")))#
#
  if (check[1] == "1"){#
     if (anyDuplicated(DTm)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(DTu)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names_DTm){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names_DTu){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(DTm),names(DTu),gen))#
      DTm[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(DTm),names(DTu),gen,idm))#
      DTu[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(DTm, DTu, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (!gen == FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      DTm[, c(idm) := NULL]#
      DTu[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(DTm[DTu, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- DTm[w]#
  } else if (type == "anti"){#
    DT_output <- DTm[!DTu, allow.cartesian = TRUE]#
  } #
  setnames(DTu, names_DTu)#
  setnames(DTm, names_DTm)#
  DT_output#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param DTm The master data.table#
#' @param DTu The using data.table#
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. Matching is done on common names. Keys are set onmaster and using  data.tables.#
#' @examples#
#'  join(DTm, DTu, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(DTm, DTu, on = intersect(names(DTm),names(DTu)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(DTm)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(DTu)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
#
  if (is.null(names(on))){#
    names(on) <- on#
  }#
  vars <- names(on)#
  message(paste0("Join based on : ", paste(vars, collapse = " ")))#
  names_DTm <- names(DTm)#
  names_DTu <- names(DTu)#
  x <- intersect(vars, setdiff(names_DTu, on))#
  setnames(DTu, x, paste0(x,".y"))#
  setnames(DTu, on , names(on))#
#
  x <- setdiff(intersect(names_DTm, names_DTu), vars)#
  setnames(DTm, x, paste0(x, ".x"))#
  setnames(DTm, x, paste0(x, ".y")) #
  setkeyv(DTm, vars)#
  setkeyv(DTu, vars)#
  message(paste0("Master is now keyed by : ", paste(vars, collapse = " ")))#
  message(paste0("Using is now keyed by : ", paste(on, collapse = " ")))#
#
  if (check[1] == "1"){#
     if (anyDuplicated(DTm)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(DTu)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names_DTm){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names_DTu){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(DTm),names(DTu),gen))#
      DTm[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(DTm),names(DTu),gen,idm))#
      DTu[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(DTm, DTu, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (!gen == FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      DTm[, c(idm) := NULL]#
      DTu[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(DTm[DTu, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- DTm[w]#
  } else if (type == "anti"){#
    DT_output <- DTm[!DTu, allow.cartesian = TRUE]#
  } #
  setnames(DTu, names_DTu)#
  setnames(DTm, names_DTm)#
  DT_output#
}
?inner_join
DT
battling_dt
N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
setkey(DT,id)
setnames(DT,"id","id1")
key(DT)
join_dt <- function(op) {#
  template <- substitute(function(x, y, by = NULL, copy = FALSE, setkey = FALSE, ...) {#
    by <- common_by(by, x, y)#
    y <- auto_copy(x, y, copy = copy)#
    if (!identical(data.table::key(x),by$x)){#
      if (!setkey) x <- copy(x)#
      data.table::setkeyv(x, by$x)#
    }#
    if (!identical(data:table::key(y),by$y)){#
      if (!setkey) y <- copy(y)#
      data.table::setkeyv(y, by$y)#
    }#
    # Accept different names#
    # In future versions, the command copy below may be replaced by shallow copies.#
    # first rename variables in y-by$y with the same name than variables in by$x #
    # This behavior is different from dplyr behavior for data.frame. #
    # Needed because merge.data.table does not accept names duplicates in master/using data.tables#
    names_byx_y <- intersect(by$x, setdiff(names(y), by$y))#
    if (length(names_byx_y)>0){#
      y <- copy(y)#
      data.table::setnames(y, names_byx_y, paste0(names_byx_y,".y"))#
      data.table::setnames(y, by$y , by$x)#
    }#
    # then rename duplicates in non joined variables#
    common_names <- setdiff(intersect(names(x), names(y)), by$x)#
    if (length(common_names)>0){#
      x <- copy(x)#
      y <- copy(y)#
      data.table::setnames(x, common_names, paste0(common_names, ".x"))#
      data.table::setnames(y, common_names, paste0(common_names, ".y")) #
    }#
    out <- op#
    grouped_dt(out, groups(x))#
  })#
#
  f <- eval(template, parent.frame())#
  attr(f, "srcref") <- NULL # fix so prints correctly#
  f#
}
names_x <- names(x)
DT
names_DT <- names(DT)
setnames(DT, "v1","v11")
names_DT
?copy
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors for variables to match on. Default to common names. To join by different variables on x and y use a named vector. For example, by = c("a" = "b") will match x.a to y.b. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names in x or in y are nenamed with suffix .x and .y. Keys are set on master and using  data.tables.#
#' @examples#
#'  join(x, y, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  # join names#
  if (is.null(names(on))){#
    names(on) <- on#
  }#
  by$x <- names(on)#
  by$y <- on#
  message(paste0("Join based on : ", paste(by$x, collapse = " ")))#
#
  # check gen#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  # set keys#
  setkeyv(x, by$x)#
  setkeyv(y, by$y)#
  message(paste0("Master is now keyed by : ", paste(by$x, collapse = " ")))#
  message(paste0("Using is now keyed by : ", paste(by$y, collapse = " ")))#
  # check duplicates#
  if (check[1] == "1"){#
     if (anyDuplicated(x)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(y)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  # avoid duplicate names#
  names_x <- copy(names(x))#
  names_y <- copy(names(y))#
  common <- intersect(by$x, setdiff(names_y, on))#
  setnames(y, common, paste0(common,".y"))#
  setnames(y, by$y , by$x)#
#
  common <- setdiff(intersect(names_x, names(y)), by$x)#
  setnames(x, common, paste0(common, ".x"))#
  setnames(y, common, paste0(common, ".y")) #
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(x){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(y){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(x),names(y),gen))#
      x[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
      y[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (!gen == FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      x[, c(idm) := NULL]#
      y[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- x[w]#
  } else if (type == "anti"){#
    DT_output <- x[!y, allow.cartesian = TRUE]#
  } #
  setnames(y, names_y)#
  setnames(x, names_x)#
  DT_output#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors for variables to match on. Default to common names. To join by different variables on x and y use a named vector. For example, by = c("a" = "b") will match x.a to y.b. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names in x or in y are nenamed with suffix .x and .y. Keys are set on master and using  data.tables.#
#' @examples#
#'  join(x, y, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  # join names#
  if (is.null(names(on))){#
    names(on) <- on#
  }#
  by$x <- names(on)#
  by$y <- on#
  message(paste0("Join based on : ", paste(by$x, collapse = " ")))#
#
  # check gen#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  # set keys#
  setkeyv(x, by$x)#
  setkeyv(y, by$y)#
  message(paste0("Master is now keyed by : ", paste(by$x, collapse = " ")))#
  message(paste0("Using is now keyed by : ", paste(by$y, collapse = " ")))#
  # check duplicates#
  if (check[1] == "1"){#
     if (anyDuplicated(x)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(y)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  # avoid duplicate names#
  names_x <- copy(names(x))#
  names_y <- copy(names(y))#
  common <- intersect(by$x, setdiff(names_y, on))#
  setnames(y, common, paste0(common,".y"))#
  setnames(y, by$y , by$x)#
#
  common <- setdiff(intersect(names_x, names(y)), by$x)#
  setnames(x, common, paste0(common, ".x"))#
  setnames(y, common, paste0(common, ".y")) #
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(x)){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(y)){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(x),names(y),gen))#
      x[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
      y[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (gen != FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      x[, c(idm) := NULL]#
      y[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- x[w]#
  } else if (type == "anti"){#
    DT_output <- x[!y, allow.cartesian = TRUE]#
  } #
  setnames(y, names_y)#
  setnames(x, names_x)#
  DT_output#
}
?dt1
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors for variables to match on. Default to common names. To join by different variables on x and y use a named vector. For example, by = c("a" = "b") will match x.a to y.b. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names in x or in y are nenamed with suffix .x and .y. Keys are set on master and using  data.tables.#
#' @examples#
#'  join(x, y, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  # join names#
  if (is.null(names(on))){#
    names(on) <- on#
  }#
  by$x <- names(on)#
  by$y <- on#
  message(paste0("Join based on : ", paste(by$x, collapse = " ")))#
#
  # check gen#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  # set keys#
  setkeyv(x, by$x)#
  setkeyv(y, by$y)#
  message(paste0("Master is now keyed by : ", paste(by$x, collapse = " ")))#
  message(paste0("Using is now keyed by : ", paste(by$y, collapse = " ")))#
  # check duplicates#
  if (check[1] == "1"){#
     if (anyDuplicated(x)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(y)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  # avoid duplicate names#
  names_x <- copy(names(x))#
  names_y <- copy(names(y))#
  common <- intersect(by$x, setdiff(names_y, on))#
  setnames(y, common, paste0(common,".y"))#
  setnames(y, by$y , by$x)#
#
  common <- setdiff(intersect(names_x, names(y)), by$x)#
  setnames(x, common, paste0(common, ".x"))#
  setnames(y, common, paste0(common, ".y")) #
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(x)){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(y)){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(x),names(y),gen))#
      x[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
      y[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (gen != FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      x[, c(idm) := NULL]#
      y[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- x[w]#
  } else if (type == "anti"){#
    DT_output <- x[!y, allow.cartesian = TRUE]#
  } #
  setnames(y, names_y)#
  setnames(x, names_x)#
  DT_output#
}
?merge
(dt1 <- data.table(A = letters[1:10], X = 1:10, key = "A"))#
    (dt2 <- data.table(A = letters[5:14], Y = 1:10, key = "A"))#
    merge(dt1, dt2)#
    merge(dt1, dt2, all = TRUE)
join(dt1,dt2)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors for variables to match on. Default to common names. To join by different variables on x and y use a named vector. For example, by = c("a" = "b") will match x.a to y.b. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names in x or in y are nenamed with suffix .x and .y. Keys are set on master and using  data.tables.#
#' @examples#
#'  join(x, y, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  # join names#
  if (is.null(names(on))){#
    names(on) <- on#
  }#
  by <- list(x = names(on), y = on)#
  message(paste0("Join based on : ", paste(by$x, collapse = " ")))#
#
  # check gen#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  # set keys#
  setkeyv(x, by$x)#
  setkeyv(y, by$y)#
  message(paste0("Master is now keyed by : ", paste(by$x, collapse = " ")))#
  message(paste0("Using is now keyed by : ", paste(by$y, collapse = " ")))#
  # check duplicates#
  if (check[1] == "1"){#
     if (anyDuplicated(x)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(y)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  # avoid duplicate names#
  names_x <- copy(names(x))#
  names_y <- copy(names(y))#
  common <- intersect(by$x, setdiff(names_y, on))#
  setnames(y, common, paste0(common,".y"))#
  setnames(y, by$y , by$x)#
#
  common <- setdiff(intersect(names_x, names(y)), by$x)#
  setnames(x, common, paste0(common, ".x"))#
  setnames(y, common, paste0(common, ".y")) #
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(x)){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(y)){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(x),names(y),gen))#
      x[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
      y[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (gen != FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      x[, c(idm) := NULL]#
      y[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- x[w]#
  } else if (type == "anti"){#
    DT_output <- x[!y, allow.cartesian = TRUE]#
  } #
  setnames(y, names_y)#
  setnames(x, names_x)#
  DT_output#
}
join(dt1,dt2)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors for variables to match on. Default to common names. To join by different variables on x and y use a named vector. For example, by = c("a" = "b") will match x.a to y.b. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names in x or in y are nenamed with suffix .x and .y. Keys are set on master and using  data.tables.#
#' @examples#
#'  join(x, y, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  # join names#
  if (is.null(names(on))){#
    names(on) <- on#
  }#
  by <- list(x = names(on), y = on)#
  message(paste0("Join based on : ", paste(by$x, collapse = " ")))#
#
  # check gen#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  # set keys#
  setkeyv(x, by$x)#
  setkeyv(y, by$y)#
  message(paste0("Master is now keyed by : ", paste(by$x, collapse = " ")))#
  message(paste0("Using is now keyed by : ", paste(by$y, collapse = " ")))#
  # check duplicates#
  if (check[1] == "1"){#
     if (anyDuplicated(x)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(y)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  # avoid duplicate names#
  names_x <- copy(names(x))#
  names_y <- copy(names(y))#
  common <- intersect(by$x, setdiff(names_y, on))#
  if (length(common)>0){#
    setnames(y, common, paste0(common,".y"))#
    setnames(y, by$y , by$x)#
  }#
#
  common <- setdiff(intersect(names_x, names(y)), by$x)#
  if (length(common)>0){#
    setnames(x, common, paste0(common, ".x"))#
    setnames(y, common, paste0(common, ".y")) #
  }#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(x)){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(y)){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(x),names(y),gen))#
      x[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
      y[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (gen != FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      x[, c(idm) := NULL]#
      y[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- x[w]#
  } else if (type == "anti"){#
    DT_output <- x[!y, allow.cartesian = TRUE]#
  } #
  setnames(y, names_y)#
  setnames(x, names_x)#
  DT_output#
}
join(dt1,dt2)
join(dt1,dt2)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors for variables to match on. Default to common names. To join by different variables on x and y use a named vector. For example, by = c("a" = "b") will match x.a to y.b. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names in x or in y are nenamed with suffix .x and .y. Keys are set on master and using  data.tables in-place, which avoids the copy of x and y.#
#' @examples#
#'  join(x, y, type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  # join names#
  if (is.null(names(on))){#
    names(on) <- on#
  }#
  by <- list(x = names(on), y = on)#
  message(paste0("Join based on : ", paste(by$x, collapse = " ")))#
#
  # check gen#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  # set keys#
  setkeyv(x, by$x)#
  setkeyv(y, by$y)#
#
  # check duplicates#
  if (check[1] == "1"){#
     if (anyDuplicated(x)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(y)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  # avoid duplicate names#
  names_x <- copy(names(x))#
  names_y <- copy(names(y))#
  common <- intersect(by$x, setdiff(names_y, on))#
  if (length(common)>0){#
    setnames(y, common, paste0(common,".y"))#
    setnames(y, by$y , by$x)#
  }#
#
  common <- setdiff(intersect(names_x, names(y)), by$x)#
  if (length(common)>0){#
    setnames(x, common, paste0(common, ".x"))#
    setnames(y, common, paste0(common, ".y")) #
  }#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(x)){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(y)){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(x),names(y),gen))#
      x[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
      y[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (gen != FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      x[, c(idm) := NULL]#
      y[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- x[w]#
  } else if (type == "anti"){#
    DT_output <- x[!y, allow.cartesian = TRUE]#
  } #
  setnames(y, names_y)#
  setnames(x, names_x)#
  DT_output#
}
join(dt1,dt2)
join_dt <- function(op) {#
  template <- substitute(function(x, y, by = NULL, copy = FALSE, setkey = FALSE, ...) {#
    by <- common_by(by, x, y)#
    y <- auto_copy(x, y, copy = copy)#
    if (!identical(data.table::key(x),by$x)){#
      if (!setkey) x <- copy(x)#
      data.table::setkeyv(x, by$x)#
    }#
    if (!identical(data:table::key(y),by$y)){#
      if (!setkey) y <- copy(y)#
      data.table::setkeyv(y, by$y)#
    }#
    # Accept different names#
    # In future versions, the command copy below may be replaced by shallow copies.#
    # first output error if there are variables in y-by$y with the same name than variables in by$x #
    # This behavior is different from dplyr behavior for data.frame that does not output error#
    # Needed because merge.data.table does not accept names duplicates in master/using data.tables#
    names_byx_y <- intersect(by$x, setdiff(names(y), by$y))#
    if (length(names_byx_y) >0) stop(paste0(names_byx_y,"is a variable to be matched in x and not in y. Please rename",names_byx_y, "in x or y")#
    if !identical(by.x,by.y){#
      y <- copy(y)#
      data.table::setnames(y, by$y, by$x)#
    }#
    # Rename duplicates in non joined variables#
    common_names <- setdiff(intersect(names(x), names(y)), by$x)#
    if (length(common_names)>0){#
      x <- copy(x)#
      y <- copy(y)#
      data.table::setnames(x, common_names, paste0(common_names, ".x"))#
      data.table::setnames(y, common_names, paste0(common_names, ".y")) #
    }#
    out <- op#
    grouped_dt(out, groups(x))#
  })#
#
  f <- eval(template, parent.frame())#
  attr(f, "srcref") <- NULL # fix so prints correctly#
  f#
}
join_dt <- function(op) {#
  template <- substitute(function(x, y, by = NULL, copy = FALSE, setkey = FALSE, ...) {#
    by <- common_by(by, x, y)#
    y <- auto_copy(x, y, copy = copy)#
    if (!identical(data.table::key(x),by$x)){#
      if (!setkey) x <- copy(x)#
      data.table::setkeyv(x, by$x)#
    }#
    if (!identical(data:table::key(y),by$y)){#
      if (!setkey) y <- copy(y)#
      data.table::setkeyv(y, by$y)#
    }#
    # Accept different names#
    # In future versions, the command copy below may be replaced by shallow copies.#
    # first output error if there are variables in y-by$y with the same name than variables in by$x #
    # This behavior is different from dplyr behavior for data.frame that does not output error#
    # Needed because merge.data.table does not accept names duplicates in master/using data.tables#
    names_byx_y <- intersect(by$x, setdiff(names(y), by$y))#
    if (length(names_byx_y) >0) stop(paste(names_byx_y,"is a variable to be matched in x and not in y. Please rename",names_byx_y, "in x or y"))#
    if (!identical(by$x,by$y)){#
      y <- copy(y)#
      data.table::setnames(y, by$y, by$x)#
    }#
    # Rename duplicates in non joined variables#
    common_names <- setdiff(intersect(names(x), names(y)), by$x)#
    if (length(common_names)>0){#
      x <- copy(x)#
      y <- copy(y)#
      data.table::setnames(x, common_names, paste0(common_names, ".x"))#
      data.table::setnames(y, common_names, paste0(common_names, ".y")) #
    }#
    out <- op#
    grouped_dt(out, groups(x))#
  })#
#
  f <- eval(template, parent.frame())#
  attr(f, "srcref") <- NULL # fix so prints correctly#
  f#
}
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors for variables to match on. Default to common names. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with a .x and .y suffixes. Keys are set on master and using  data.tables in-place, which avoids the copy of x and y.#
#' @examples#
#'  join(x, y, on = intersect(names(x),names(y)), type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  # check gen#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  # join names#
  vars <- on#
  message(paste0("Join based on : ", paste(vars, collapse = " ")))#
#
  # set keys#
  setkeyv(x, vars)#
  setkeyv(y, vars)#
#
  # check duplicates#
  if (check[1] == "1"){#
     if (anyDuplicated(x)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(y)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  common_names <- setdiff(intersect(names(x),names(y)), vars)#
  if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"))#
    if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"))#
#
  if (length(common)>0){#
    x <- copy(x)#
    y <- copy(x)#
    setnames(x, common_names, paste0(common_names, ".x"))#
    setnames(x, common_names, paste0(common_names, ".y"))#
  }#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(x)){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(y)){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(x),names(y),gen))#
      x[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
      y[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (gen != FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      x[, c(idm) := NULL]#
      y[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- x[w]#
  } else if (type == "anti"){#
    DT_output <- x[!y, allow.cartesian = TRUE]#
  } #
  DT_output#
}
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Join two data.tables together #
#' #
#' @param x The master data.table#
#' @param y The using data.table#
#' @param on Character vectors for variables to match on. Default to common names between x and y. #
#' @param type The type of (SQL) join among "outer" (default), "left", "right", "inner", "semi" and "anti"#
#' @param gen Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The generated variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.#
#' @param check A character that checks for the presence of duplicates. "m:m" many to many (all pairwise combinations), "1:1" one to one merge, "m:1" many to one merge, "1:m" one to many. Specifying 1 at the rhs or lhs checks that joined variables uniquely identify observations in the master or using dataset.#
#' @return A data.table that joins rows in master and using datases. In order to avoid duplicates, identical variable names not joined are renamed with a .x and .y suffixes. Keys are set on master and using data.tables, which avoids the copy of x and y, at the cost of transforming the input data.tables.#
#' @examples#
#'  join(x, y, on = intersect(names(x),names(y)), type = "outer", gen = FALSE, check = "m:m")#
#' @export#
join =  function(x, y, on = intersect(names(x),names(y)), type = "outer" , gen = FALSE, check =  c("m:m", "m:1", "1:m", "1:1")){#
#
  #type#
  type <- match.arg(type, c("outer", "left", "right", "inner", "cross", "semi", "anti"))#
  if (type == "cross"){#
    stop("cross join is not implemented yet")#
  }#
#
  if (!is.data.table(x)){#
    stop(paste0("Master is not a data.table. Convert it first using setDT()"))#
  }#
  if (!is.data.table(y)){#
    stop(paste0("Using is not a data.table. Convert it first using setDT()"))#
  }#
  # check gen#
  if (gen != FALSE & !(type %in% c("left", "right", "outer"))){#
    stop(" The option gen is only available for left, right and outer joins")#
  }#
#
  # join names#
  vars <- on#
  message(paste0("Join based on : ", paste(vars, collapse = " ")))#
#
  # set keys#
  setkeyv(x, vars)#
  setkeyv(y, vars)#
#
  # check duplicates#
  if (check[1] == "1"){#
     if (anyDuplicated(x)){ #
       stop("Variables don't uniquely identify observations in the master dataset")#
     }#
   }#
#
  if (check[3] == "1"){#
   if (anyDuplicated(y)){ #
     stop("Variables don't uniquely identify observations in the using dataset")#
   }#
  }#
#
  common_names <- setdiff(intersect(names(x),names(y)), vars)#
  if (length(intersect(paste0(common_names, ".x"), setdiff(names(x),common_names)))>0) stop(paste("Adding the suffix .x in", common_names,"would create duplicates names in x"))#
  if (length(intersect(paste0(common_names, ".y"), setdiff(names(y),common_names)))>0) stop(paste("Adding the suffix .y in", common_names,"would create duplicates names in y"))#
#
  if (length(common)>0){#
    x <- copy(x)#
    y <- copy(y)#
    setnames(x, common_names, paste0(common_names, ".x"))#
    setnames(x, common_names, paste0(common_names, ".y"))#
  }#
  if (type %in% c("left", "right", "outer", "inner")){#
    all.x <- FALSE#
    all.y <- FALSE#
    if (type == "left"| type == "outer"){#
      all.x = TRUE#
    }#
    if (type == "right" | type == "outer"){#
      all.y = TRUE#
    }#
    if (!gen == FALSE){#
      if (gen %chin% names(x)){#
        stop(paste0(gen," alreay exists in master"))#
      }#
      if (gen %chin% names(y)){#
        stop(paste0(gen," alreay exists in using"))#
      }#
      idm <- tempname_list("temp", c(names(x),names(y),gen))#
      x[, c(idm) := 1L]#
      idu <- tempname_list("temp", c(names(x),names(y),gen,idm))#
      y[, c(idu) := 1L]#
    }#
#
    DT_output <- merge(x, y, all.x = all.x, all.y= all.y, allow.cartesian= TRUE)#
    if (gen != FALSE){#
      DT_output[, c(gen) := 3L]#
      eval(substitute(DT_output[is.na(v), c(gen) := 1L], list(v = as.name(idu))))#
      eval(substitute(DT_output[is.na(v), c(gen) := 2L], list(v = as.name(idm))))#
      DT_output[, c(idm) := NULL]#
      DT_output[, c(idu) := NULL]#
      x[, c(idm) := NULL]#
      y[, c(idu) := NULL]#
    }#
  } else if (type == "semi"){#
    w <- unique(x[y, which = TRUE, allow.cartesian = TRUE])#
    w <- w[!is.na(w)]#
    DT_output <- x[w]#
  } else if (type == "anti"){#
    DT_output <- x[!y, allow.cartesian = TRUE]#
  } #
  DT_output#
}
