names(summary(result))
result <- felm(v2~v1,DT)
library(lfe)
result <- felm(v2~v1,DT)
names(result)
names(result)$se
result$se
result$coefficients
result$robustvcv
summary(result)
names(summary(result))
?summary
object_size(summary(result))
library(pryr)
object_size(summary(result))
object_size(result)
result <- lm(y ~ x)
result <- lm(y ~ x)N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
result <- lm(v3 ~ v2, DT)
pryr::object_size(results)
pryr::object_size(result)
pryr::object_size(summary(results))
pryr::object_size(summary(result))
names(result)
result$coefficients
result <- lm(y ~ x)N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
result <- felm(v3 ~ v2, DT)
vcov(result)
result
result <- lm(y ~ x)N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
result <- felm(v3 ~ v2|||v1, DT)
result <- lm(y ~ x)N=2e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)#
#
result <- felm(v3 ~ v2|0|0|v1, DT)
names(result)
vcov(result)
result$vcv
result$robustvcv
object_size(results)
object_size(result)
result <- felm(v3~v2|0|0|v1, DT)
stargazer(result, type = "text")
library(stargazer)
stargazer(result, type = "text")
devtools::install_github("matthieugomez/statar")
lazy(date)
library(lazyeval)
lazy(date0
)
lazy(date)
lazy_eval(lazy(date))
lazy_eval(lazy(date1))
select_vars(names(df),lazy(ok))
library(dplyr)
select_vars(names(df),lazy(ok))
select_vars(names(df), args = lazy(ok))
lazydots
lazy_dots
lazykeep = function(df,x){#
  keep_(df, lazy(x))#
}#
keep_ = function(df,x){#
  df[, lazy_eval(x,df)]#
}(date)
df
df <- data.frame(#
  id    = c(1, 1, 1, 1, 1, 2, 2),#
  date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
  value = c(NA, NA, 3, 5.3, 3.0, 3.2, 5.2)#
 )
keep(df,id)
keep = function(df,x){#
  keep_(df, lazy(x))#
}#
keep_ = function(df,x){#
  df[, lazy_eval(x,df)]#
}
keep(df,id)
lazy(date)
lazy(date1)
devtools::load_all("/Users/Matthieu/Dropbox/Symlink/Downloads/data.table-master")
dt <- data.table(id = c(1,2), date = c(1999, 2000))#
setcolorder(dt, "date", 1)#
setcolorder(dt, 2, 1)#
setcolorder(dt, "id", 2)#
setcolorder(dt, 1, 2)
devtools::load_all("/Users/Matthieu/Dropbox/Symlink/Downloads/data.table-master")
library(lfe)
suppressMessages(library("data.table"))
N <- 1e3#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
felm(v3 ~ v2, DT)
felm(v3 ~ 1|0|(v2~v1), DT)
debug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
n
f
felm(v3 ~ 1|0|(v2~v1), DT)
pform
parseformula(formula,data)
knownargs
sc
sc <- names(sys.call())[-1]
sc
named <- knownargs[pmatch(sc, knownargs)]
formula
f
felm::parseformula(v3 ~ 1 | 0 | v2 ~ v1, DT)
lfe:::parseformula(v3 ~ 1 | 0 | v2 ~ v1, DT)
felm = function (formula, data, iv = NULL, clustervar = NULL, exactDOF = FALSE, #
    subset, na.action, contrasts = NULL, ...) #
{#
    knownargs <- c("iv", "clustervar", "cmethod")#
    sc <- names(sys.call())[-1]#
    named <- knownargs[pmatch(sc, knownargs)]#
    for (arg in c("iv", "clustervar")) {#
        if (!is.null(eval(as.name(arg))) && !(arg %in% named)) {#
            warning("Please specify the '", arg, "' argument by name, or use a multi part formula. Its position in the argument list will change in a later version")#
        }#
    }#
    mf <- match.call(expand.dots = FALSE)#
    cmethod <- "cgm"#
    args <- list(...)#
    ka <- knownargs[pmatch(names(args), knownargs, duplicates.ok = FALSE)]#
    names(args)[!is.na(ka)] <- ka[!is.na(ka)]#
    env <- environment()#
    lapply(intersect(knownargs, ka), function(arg) assign(arg, #
        args[[arg]], pos = env))#
    if (!(cmethod %in% c("cgm", "gaure"))) #
        stop("Unknown cmethod: ", cmethod)#
    unk <- setdiff(names(args), knownargs)#
    if (length(unk) > 0) #
        stop("unknown arguments ", paste(unk, collapse = " "))#
    if (missing(data)) #
        data <- environment(formula)#
    pf <- parent.frame()#
    pform <- parseformula(formula, data)#
    print(formula)#
    print(pform)#
}
felm(v3 ~ 1|0|v2~v1, DT)
parseformula <- function (form, data) #
{#
    f <- as.Formula(form)#
    len <- length(f)[[2]]#
    if (len == 1) #
        return(oldparseformula(form, data))#
    opart <- formula(f, lhs = 1, rhs = 1)#
    if (len == 1) #
        return(list(formula = opart, gpart = ~0, ivpart = ~0, #
            cpart = ~0))#
    gpart <- formula(f, lhs = 0, rhs = 2)#
    if (!nopart(gpart)) {#
        tm <- terms(gpart, keep.order = TRUE)#
        parts <- attr(tm, "term.labels")#
        parts <- parts[parts != "0"]#
        nm <- parts#
        glist <- lapply(paste(".G(", parts, ")", sep = ""), function(e) parse(text = e))#
        Gfunc <- function(f) if (is.null(attr(f, "xnam"))) #
            factor(f)#
        else f#
        Ginfunc <- function(x, f) {#
            if (is.factor(x)) {#
                structure(interaction(factor(f), factor(x), drop = TRUE), #
                  xnam = deparse(substitute(x)), fnam = deparse(substitute(f)))#
            }#
            else {#
                structure(factor(f), x = x, xnam = deparse(substitute(x)), #
                  fnam = deparse(substitute(f)))#
            }#
        }#
        if (is.environment(data)) {#
            fl <- lapply(glist, eval, list(.G = Gfunc, `:` = Ginfunc), #
                data)#
        }#
        else {#
            fl <- lapply(glist, eval, data, as.environment(list(.G = Gfunc, #
                `:` = Ginfunc)))#
        }#
        names(fl) <- nm#
    }#
    else {#
        fl <- NULL#
    }#
    if (len == 2) #
        return(list(formula = opart, fl = fl, gpart = gpart, #
            ivpart = ~0, cpart = ~0))#
    ivparts <- formula(f, lhs = 0, rhs = 3, drop = TRUE)#
    if (!nopart(ivparts) && length(ivparts[[2]]) > 1 && ivparts[[2]][[1]] == #
        "(") {#
        ivspec <- as.Formula(ivparts[[2]][[2]])#
        lhs <- formula(ivspec, rhs = 0)#
        ivpart <- lapply(seq_along(all.vars(lhs)), function(i) formula(ivspec, #
            lhs = i))#
    }#
    else {#
        ivpart <- NULL#
    }#
    if (len == 3 && !is.null(ivpart)) #
        return(list(formula = opart, fl = fl, iv = ivpart, gpart = gpart, #
            ivpart = ivparts, cpart = ~0))#
    if (len == 3 && is.null(ivpart)) {#
        cpart <- ivparts#
        ivparts <- NULL#
    }#
    else {#
        cpart <- formula(f, lhs = 0, rhs = 4, drop = TRUE)#
    }#
    if (!nopart(cpart)) {#
        tm <- terms(cpart, keep.order = TRUE)#
        nm <- parts <- attr(tm, "term.labels")#
        clist <- lapply(paste("factor(", parts, ")", sep = ""), #
            function(e) parse(text = e))#
        cluster <- lapply(clist, eval, data)#
        names(cluster) <- nm#
    }#
    else {#
        cluster <- NULL#
    }#
    list(formula = opart, fl = fl, iv = ivpart, cluster = cluster, #
        gpart = gpart, ivpart = ivparts, cpart = cpart)#
}
felm(v3 ~ 1|0|v2~v1, DT)
library(Formula)
felm(v3 ~ 1|0|v2~v1, DT)
oldparseformula = function (formula, data) #
{#
    trm <- terms(formula, specials = c("G"))#
    feidx <- attr(trm, "specials")$G + 1#
    va <- attr(trm, "variables")#
    festr <- paste(sapply(feidx, function(i) deparse(va[[i]])), #
        collapse = "+")#
    if (festr != "") {#
        formula <- update(formula, paste(". ~ . -(", festr, ") - 1"))#
        felist <- parse(text = paste("list(", gsub("+", ",", #
            festr, fixed = TRUE), ")", sep = ""))#
        nm <- eval(felist, list(G = function(arg) deparse(substitute(arg))))#
        Gfunc <- function(f) if (is.null(attr(f, "xnam"))) #
            factor(f)#
        else f#
        Ginfunc <- function(x, f) {#
            if (is.factor(x)) {#
                structure(interaction(factor(f), factor(x), drop = TRUE), #
                  xnam = deparse(substitute(x)), fnam = deparse(substitute(f)))#
            }#
            else {#
                structure(factor(f), x = x, xnam = deparse(substitute(x)), #
                  fnam = deparse(substitute(f)))#
            }#
        }#
        if (is.environment(data)) {#
            fl <- eval(felist, list(G = Gfunc, `:` = Ginfunc), #
                data)#
        }#
        else {#
            fl <- local({#
                eval(felist, data)#
            }, list(G = Gfunc, `:` = Ginfunc))#
        }#
        names(fl) <- nm#
        gpart <- eval(parse(text = paste("~", paste(nm, collapse = "+"))))#
        if (is.null(names(fl))) #
            names(fl) <- paste("fe", 1:length(fl), sep = "")#
    }#
    else {#
        fl <- NULL#
        gpart <- ~0#
    }#
    return(list(formula = formula, fl = fl, gpart = gpart, ivpart = ~0, #
        cpart = ~0))#
}
felm(v3 ~ 1|0|v2~v1, DT)
library(lfe)
suppressMessages(library("data.table"))
N <- 1e3#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
felm(v3 ~ 1|0|v2~v1, DT)
DT
felm(v3 ~ 1|0|v2~v1, DT)
DT
felm(v3 ~ 1|0|(v2~v1), DT)
debug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
formula
pform
f <- as.Formula(formula)
f
felm(v3 ~ 1|0|(v2~v1), DT)
s
n
formula
data
p <- as.Formula(formula)
p
length(f)[[2]]
length(p)[[2]]
length(p)[[1]]
names(length(p))
length(p)
p
length(formula)
length(formula)[[2]]
gpart <-  formula(p, lhs = 0, rhs = 2)
nopart(gpart)
ivparts <- formula(p, lhs = 0, rhs = 3, drop = TRUE)
ivparts
f
as.list(body(felm))
trace(felm, print(mf), at = 40)
trace(felm, quote(print(mf)), at = 40)
felm(v3 ~ 1|0|(v2~v1), DT)
library(lfe)#
#
suppressMessages(library("tidyr"))#
suppressMessages(library("dplyr"))#
suppressMessages(library("data.table"))#
suppressMessages(library("Formula"))#
suppressMessages(library(lazyeval))#
suppressMessages(library("dplyr"))#
suppressMessages(library("reshape2"))#
suppressMessages(library("ggplot2"))#
suppressMessages(library("stringr"))#
suppressMessages(library("lubridate"))#
suppressMessages(library("pryr"))#
suppressMessages(library("lfe"))#
suppressMessages(library("biglm"))#
suppressMessages(library("foreign"))#
suppressMessages(library("stargazer"))#
suppressMessages(library("parallel"))#
suppressMessages(library("statar"))#
assignInNamespace("cedta.override",#
                  c(data.table:::cedta.override,"IRkernel"),#
                  "data.table")#
library(Formula)
N <- 1e3#
DT <- data.table(#
  id = 1:N,#
  v1 =  sample(5, N, TRUE),                          # int in range [1,5]#
  v2 =  sample(1e6, N, TRUE),                        # int in range [1,1e6]#
  v3 =  sample(round(runif(100,max=100),4), N, TRUE), # numeric e.g. 23.5749#
  v4 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749#
)
trace(felm, quote(print(mf)), at = 40)
felm(v3 ~ 1|0|(v2~v1), DT)
untrace(felm)
debug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
mf
print(mf)
f
trace(felm, quote(print(mf)), at = 41)
felm(v3 ~ 1|0|(v2~v1), DT)
as.list(body(felm))
trace(felm, quote(print(formula)), at = 39)
undebug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
trace(felm, quote(print(formula,mf)), at = 39)
felm(v3 ~ 1|0|(v2~v1), DT)
trace(felm, quote(print(formula); print(mf)), at = 39)
trace(felm, quote(print(formula) print(mf)), at = 39)
trace(felm, quote(print(formula),print(mf)), at = 39)
trace(felm, quote(print(formula) \n print(mf)), at = 39)
trace(felm, quote(print(mf)), at = 40)
felm(v3 ~ 1|0|(v2~v1), DT)
trace(felm, quote(print(mf)), at = 39)
felm(v3 ~ 1|0|(v2~v1), DT)
debug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
mf
ivform[["formula"]]
mf
ivform
f
trace(felm, quote(print(ivform), at = 39)
)
trace(felm, quote(print(ivform)), at = 39)
felm(v3 ~ 1|0|(v2~v1), DT)
debug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
mf
ivform
mf
f
as.list(body(felm))
as.list(body(felm))[[34]]
as.list(as.list(body(felm))[[34]])
as.list(body(felm))[[34]]
?trace
debug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
mf
fl
data
contrasts
clustervar
pf
mf
s
n
mf
`v2(fit)`
f
lfe::project
lfe:::project
g=function(formula,env){eval(formula,env)}
f=function(x){assign("t1",1:10,envir = parent.frame()); g(y~t1, parent.frame())}
f(1:10)
assign("v2(fit)",ok)
assign("v2(fit)","ok")
v2fit
`v2(fit)`
debug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
s
n
mf
`v2(fit)`
mf
eval(mf,pf)
mf
f
g=function(formula,DT,pf){eval(quote(stats::model.frame(formula,DT)),pf)}#
f=function(){pf <-parent.frame(); assign("v2(fit)",1:1e3,envir = pf); g(v1~`v2(fit)`,DT, pf)}#
f()
g=function(formula,DT,pf){eval(quote(stats::model.frame(formula,DT)))}#
f=function(){pf <-parent.frame(); assign("v2(fit)",1:1e3,envir = pf); g(v1~`v2(fit)`,DT, pf)}#
f()
project
lfe::project
lfe:::project
as.list(body(lfe::project))
as.list(body(lfe:::project))
pf
felm(v3 ~ 1|0|(v2~v1), DT)
f
debug(lfe:::project)
undebug(lfe)
undebug(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
s
n
m
mf
formula
mfnull
mf
print(mf)
f
trace(lfe:::project, quote(print(mf)), at=5)#
felm(v3 ~ 1|0|(v2~v1), DT)
untrace(felm)
trace(lfe:::project, quote(print(mf)), at=5)#
felm(v3 ~ 1|0|(v2~v1), DT)
f
undebug(lfe:::project)
trace(lfe:::project, quote(print(mf)), at=5)#
felm(v3 ~ 1|0|(v2~v1), DT)
f
undebug(lfe:::project)
undebug(felm)
trace(lfe:::project, quote(print(mf)), at=5)#
felm(v3 ~ 1|0|(v2~v1), DT)
trace(lfe:::project, quote(print(mf)), at=6)#
felm(v3 ~ 1|0|(v2~v1), DT)
trace(lfe:::project, quote(print(mf)), at=6)#
trace(lfe:::project, quote(eval(lm(v1~`v2(fit)`,data=DT),pf)), at=6)#
felm(v3 ~ 1|0|(v2~v1), DT)
`v2(fit)`
trace(lfe:::project, quote(print(mf)), at=6)#
trace(lfe:::project, quote(eval(lm(v1~`v2(fit)`,data=DT),pf)), at=6)#
felm(v3 ~ 1|0|(v2~v1), DT)
untrace(lfe)
trace(lfe:::project, quote(print(mf)), at=6)#
trace(lfe:::project, quote(eval(lm(v1~`v2(fit)`,data=DT),pf)), at=6)#
felm(v3 ~ 1|0|(v2~v1), DT)
untrace(lfe)
felm(v3 ~ 1|0|(v2~v1), DT)
untrace(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
untrace(project)
untrace(lfe::project)
untrace(lfe:::project)
felm(v3 ~ 1|0|(v2~v1), DT)
f
undebug(lfe::project)
undebug(lfe:::project)
felm(v3 ~ 1|0|(v2~v1), DT)
trace(lfe:::project, quote(eval(lm(v1~`v2(fit)`,data=DT),pf)), at=6)#
felm(v3 ~ 1|0|(v2~v1), DT)
`v2(fit)`
felm
trace(lfe:::project, quote(eval(lm(v1~`v2(fit)`,data=DT),pf)), at=6)#
felm(v3 ~ 1|0|(v2~v1), DT)
v2(fit)
`v2(fit)`
untrace(lfe::project)
untrace(lfe:::project)
felm(v3 ~ 1|0|(v2~v1), DT)
`v2(fit)`
trace(lfe:::project, quote(eval(lm(v1~`v2(fit)`,data=DT),pf)), at=6)#
felm(v3 ~ 1|0|(v2~v1), DT)
trace(f, quote(eval(lm(v1~`v2(fit)`,data=DT),pf)), at=6)
function(x){quote(eval(lm(v1~`v2(fit)`,data=DT)}
function(x){eval(quote(eval(lm(v1~`v2(fit)`,data=DT)}
function(x){eval(quote(eval(lm(v1~`v2(fit)`,data=DT)))}
function(x){eval(quote(eval(lm(v1~`v2(fit)`,data=DT))}
function(x){eval(quote(lm(v1~`v2(fit)`,data=DT))}
function(x){eval(quote(lm(v1~`v2(fit)`,data=DT)))}
f <- function(x){eval(quote(lm(v1~`v2(fit)`,data=DT)))}
assign("v2(fit)", DT[,v1])
f()
trace(f,quote(eval(quote(lm(v1~`v2(fit)`,data=DT)))))
f()
f
trace(f,quote(eval(quote(lm(v3~`v2(fit)`,data=DT)))))
trace(f,quote(eval(quote(lm(v1~`v2(fit)`,data=DT)))))
trace(f,quote(eval(quote(lm(v3~`v2(fit)`,data=DT)))))
f()
trace(f,quote(eval(quote(lm(v3~`v2(fit)`,data=DT)))))
mf=as.expression(felm(v1~`v2(fit)`))
mf=as.expression(quote(felm(v1~`v2(fit)`)))
mf
mf=as.formula(felm(v1~`v2(fit)`))
f =function(x){mf <- match.call; mf[[1]] <- stats::model.frame; eval(mf)}
f(1)
f =function(x){mf <- match.call; mf[[1]] <- quote(stats::model.frame); eval(mf)}
f(1)
f =function(x){mf <- match.call(); mf[[1]] <- quote(stats::model.frame); eval(mf)}
f(1)
f =function(v2~v1,data = DT){mf <- match.call(); mf[[1]] <- quote(stats::model.frame); eval(mf)}
f=function(x, data = y){mf <- match.call(); mf[[1]] <- quote(stats::model.frame); eval(mf)}
f(v2~v1, data = DT)
debug(f)
f(v2~v1, data = DT)
n
mf
f=function(formula = x, data = y){mf <- match.call(); mf[[1]] <- quote(stats::model.frame); eval(mf)}
f(v2~v1, data = DT)
debug(f)
f(v2~v1, data = DT)
mf
stats::model.frame(formula = v2 ~ v1, data = DT)
model.frame
?model.frame
debug(lfe:::project)
felm(v3 ~ 1|0|(v2~v1), DT)
n
mf
`v2(fit)`
stats::model.frame(formula = v3 ~ `v2(fit)`)
stats::model.frame(formula = v3 ~ `v2(fit)`, data = DT)
f
trace(felm,exit = quote(eval(stats::model.frame(formula = v3 ~ `v2(fit)`, data = DT), pf)))
felm(v3~1|0|(v2~v1), data = DT)
f
undebug(felm)
trace(felm,exit = quote(eval(stats::model.frame(formula = v3 ~ `v2(fit)`, data = DT), pf)))
felm(v3~1|0|(v2~v1), data = DT)
f
undebug(felm)
undebug(lfe:::project)
felm(v3~1|0|(v2~v1), data = DT)
untrace(lfe:::project)
felm(v3~1|0|(v2~v1), data = DT)
untrace(felm)
felm(v3~1|0|(v2~v1), data = DT)
trace(felm,exit = quote(eval(stats::model.frame(formula = v3 ~ v1, data = DT), pf)))
felm(v3~1|0|(v2~v1), data = DT)
trace(felm,exit = quote(eval(stats::model.frame(formula = v3 ~ `v2(fit)`, data = DT), pf)))
felm(v3~1|0|(v2~v1), data = DT)
exists(a)
exists("a")
trace(lfe:::project,quote(print(exists("`v2(fit)`"))))
felm(v3 ~ 1|0|(v2~v1), DT)
trace(lfe:::project,quote(print(exists("v2(fit)"))))
untrace(felm)
felm(v3 ~ 1|0|(v2~v1), DT)
rm("v2(fit)")#
trace(lfe:::project,quote(print(exists("v2(fit)"))))#
felm(v3 ~ 1|0|(v2~v1), DT)
f=function(){v1}#
g=function(){eval(v1 <-4, parent.frame()); f()}#
g()
f=function(){v1}#
g=function(){assign("v1", 4, parent.frame()); f()}#
g()
eval
?eval
devtools::install_github("matthieugomez/statar")
g()
f
devtools::install_github("hadley/tidyr")
?expand
devtools::install_github("matthieugomez/statar")
?expand
??expand
?fill_na
library(statar)
?fill_na
?expand
?mutate
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(statar)
?expand
library(statar)
?expand
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(statar)
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100, max = 100), 4), N, TRUE)#
  )#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))#
#
# fill_gap (= Stata tsfill)#
DT <- data.table(#
    id    = c(1, 1, 1, 1, 1, 2, 2),#
    date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
    value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% fill_gap(along_with = date)#
DT %>% group_by(id) %>% fill_gap(value, along_with = date)#
DT %>% group_by(id) %>% fill_gap(value, along_with = date, type = "across")#
#
# fill_na  (in a new dataset)#
DT <- data.table(#
 id    = c(1, 1, 1, 1, 1, 2, 2),#
 date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
 value = c(NA, NA, 3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% group_by(id) %>% fill_na(value, along_with  = date) #
DT %>% group_by(id) %>% fill_na(value, along_with  = date, roll = "nearest")
library(data.table)
library(dplyr)
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100, max = 100), 4), N, TRUE)#
  )#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))#
#
# fill_gap (= Stata tsfill)#
DT <- data.table(#
    id    = c(1, 1, 1, 1, 1, 2, 2),#
    date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
    value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% fill_gap(along_with = date)#
DT %>% group_by(id) %>% fill_gap(value, along_with = date)#
DT %>% group_by(id) %>% fill_gap(value, along_with = date, type = "across")#
#
# fill_na  (in a new dataset)#
DT <- data.table(#
 id    = c(1, 1, 1, 1, 1, 2, 2),#
 date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
 value = c(NA, NA, 3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% group_by(id) %>% fill_na(value, along_with  = date) #
DT %>% group_by(id) %>% fill_na(value, along_with  = date, roll = "nearest")
?fill_gap
library(statar)
?fill_gap
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(statar)
?fill_na
?slice
?filter
?mutate
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100, max = 100), 4), N, TRUE)#
  )#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))#
#
# fill_gap (= Stata tsfill)#
DT <- data.table(#
    id    = c(1, 1, 1, 1, 1, 2, 2),#
    date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
    value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% fill_gap(along_with = date)#
DT %>% group_by(id) %>% fill_gap(value, along_with = date)#
DT %>% group_by(id) %>% fill_gap(value, along_with = date, type = "across")#
#
# fill_na  (in a new dataset)#
DT <- data.table(#
 id    = c(1, 1, 1, 1, 1, 2, 2),#
 date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
 value = c(NA, NA, 3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% group_by(id) %>% fill_na(value, along_with  = date) #
DT %>% group_by(id) %>% fill_na(value, along_with  = date, roll = "nearest")
library(dplyr)#
library(data.table)#
library(statar)
N=1e6; K=100#
DT <- data.table(#
  id = 1:N,#
  v1 = sample(5, N, TRUE),#
  v2 = sample(1e6, N, TRUE),#
  v3 = sample(round(runif(100, max = 100), 4), N, TRUE)#
  )#
#
# sum_up (= Stata summarize)#
DT  %>% sum_up#
DT  %>% sum_up(v3, d=T)#
DT  %>% filter(v1==1) %>% sum_up(starts_with("v"))#
#
# fill_gap (= Stata tsfill)#
DT <- data.table(#
    id    = c(1, 1, 1, 1, 1, 2, 2),#
    date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991),#
    value = c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% fill_gap(along_with = date)#
DT %>% group_by(id) %>% fill_gap(value, along_with = date)#
DT %>% group_by(id) %>% fill_gap(value, along_with = date, type = "across")#
#
# fill_na  (in a new dataset)#
DT <- data.table(#
 id    = c(1, 1, 1, 1, 1, 2, 2),#
 date  = c(1992, 1989, 1991, 1990, 1994, 1992, 1991), #
 value = c(NA, NA, 3, 5.3, 3.0, 3.2, 5.2)#
)#
DT %>% group_by(id) %>% fill_na(value, along_with  = date) #
DT %>% group_by(id) %>% fill_na(value, along_with  = date, roll = "nearest")
?unique
tag <- function(x, fromLast = FALSE){#
  out <- rep(0, length(x))#
  if (!fromLast){#
    out <- c(1, rep(0, length(x)-1))#
  } else{#
    out <- c(rep(0, length(x)-1),1)#
}
}
v <- c(1, 4, 6, 99)
tag(v)
tag(v)
tag(x)
tag(v)
#' Tag a numeric vector (=Stata tag)#
#' #
#' @param x A vector of values#
#' @return A vector with only 1#
#' @examples                        #
#' v <- c(1, 4, 6, 99)                      #
#' tag(v)#
#' tag(v, fromLast = TRUE)#
tag <- function(x, fromLast = FALSE){#
  out <- rep(0, length(x))#
  if (!fromLast){#
    return(c(1, rep(0, length(x)-1)))#
  } else{#
    return(c(rep(0, length(x)-1),1))#
  }#
}
tag(v)
tag(v, fromLast = TRUE)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
?smode
smode <- function(x) {#
  ux <- unique(x)#
  ux[which.max(tabulate(match(x, ux)))]#
}
mode_stat v <- c(1, 1, 2, 2,2)
v <- c(1, 1, 2, 2,2)
mode_stat(v)
mode_stat <- function(x) {#
  ux <- unique(x)#
  ux[which.max(tabulate(match(x, ux)))]#
}
mode_stat(v)
v <- c(1, 1, 2, 2)
mode_stat(v)
which.max
?which.max
mode_stat(c(NA,NA,1))
mode_stat <- function(x, na.rm = FALSE) {#
  if na.rm{#
  	x <- x[!is.na(x)]#
  }#
  ux <- unique(x)#
  ux[which.max(tabulate(match(x, ux)))]#
}
#' statistical mode#
#' #
#' @param x A vector of values#
#' @return The mode of a vector#
#' @examples                        #
#' v <- c(1, 1, 2, 2,2)                      #
#' mode_stat(v)#
#' v <- c(1, 1, 2, 2)                      #
#' mode_stat(v)#
#' tag(v, fromLast = TRUE)#
#
mode_stat <- function(x, na.rm = FALSE) {#
  if (na.rm) x <- x[!is.na(x)]#
  ux <- unique(x)#
  ux[which.max(tabulate(match(x, ux)))]#
}
mode_stat(c(NA,NA,1))
mode_stat(c(NA,NA,1), na.rm = TRUE)
#' statistical mode#
#' #
#' @param x A vector of values#
#' @return The mode of a vector#
#' @examples                        #
#' sample_mode(c(1, 2, 2))#
#' sample_mode(c(1, 2,))#
#' sample_mode(c(NA,NA,1))#
#' sample_mode(c(NA,NA,1), na.rm = TRUE)#
sample_mode <- function(x, na.rm = FALSE) {#
  if (na.rm) x <- x[!is.na(x)]#
  ux <- unique(x)#
  ux[which.max(tabulate(match(x, ux)))]#
}
?n_distinct
n_distinct
library(dplyr)#
library(data.table)#
library(statar)#
# lag/lead create lag/lead variables (corresponds to Stata L. F.)#
## lag in unbalanced panel#
year <- c(1992, 1989, 1991, 1990, 1994, 1992, 1991)#
value <- c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
lag(value, 1, order_by = year) # returns value in previous year, like  dplyr::lag#
lag(value, 1, along_with = year) #  returns value in year - 1#
## lag by time periods#
library(lubridate)#
DT <- data.table(     #
   id    = c("id1", "id1", "id1", "id1"),#
   date  = mdy(c("03/01/1992", "04/03/1992", "07/15/1992", "08/21/1992")),#
   value = c(4.1, 4.5, 3.3, 5.3)#
)#
DT[, datem := floor_date(date, "month")]#
DT[, datem_l := lag(value, months(1), along_with = datem), by = id] #
#
# tag (corresponds to Stata tag)#
tag(c(1,2))#
tag(c(1,2), fromLast = TRUE)#
#
# sample_mode (corresponds to Stata mode)#
sample_mode(c(1, 2, 2))#
sample_mode(c(1, 2,))#
sample_mode(c(NA,NA,1))#
sample_mode(c(NA,NA,1), na.rm = TRUE)#
#
# partition creates quantile categories (corresponds to Stata xtile)#
v <- sample(1e6, 1e6, TRUE)                   #
v_categorized <- partition(v, nq = 3) # 3 groups based on terciles#
v_categorized <- partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#
# winsorize (default based on 5 x interquartile range)#
v <- sample(1e6, 1e6, TRUE)                   #
winsorize(v)#
winsorize(v, replace = NA)#
winsorize(v, cutpoints = quantile(v, c(0.01, 0.99), na.rm = TRUE))
v <- sample(100, c(1:10,99), TRUE)
v
v
v
?sample
v <- sample(c(1:10,99), 100, TRUE)
v
winsorize(v)
winsorize(v, replace = NA)
winsorize(v, cutpoints = quantile(v, c(0.01, 0.99), na.rm = TRUE))
v <- sample(10, 10, TRUE)                   #
v_categorized <- partition(v, nq = 3) # 3 groups based on terciles#
v_categorized <- partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints
v
tag(c(1,2))#
tag(c(1,2), fromLast = TRUE)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::install_github("matthieugomez/statar")
library(dplyr)#
library(data.table)#
library(statar)#
#
# lag/lead create lag/lead variables (corresponds to Stata L. F.)#
## lag in unbalanced panel#
year <- c(1992, 1989, 1991, 1990, 1994, 1992, 1991)#
value <- c(4.1, 4.5, 3.3, 5.3, 3.0, 3.2, 5.2)#
lag(value, 1, order_by = year) # returns value in previous year, like  dplyr::lag#
lag(value, 1, along_with = year) #  returns value in year - 1#
## lag by time periods#
library(lubridate)#
DT <- data.table(     #
   id    = c("id1", "id1", "id1", "id1"),#
   date  = mdy(c("03/01/1992", "04/03/1992", "07/15/1992", "08/21/1992")),#
   value = c(4.1, 4.5, 3.3, 5.3)#
)#
DT[, datem := floor_date(date, "month")]#
DT[, datem_l := lag(value, months(1), along_with = datem), by = id] #
#
# tag (corresponds to Stata tag)#
tag(c(1,2))#
tag(c(1,2), fromLast = TRUE)#
#
# sample_mode (corresponds to Stata mode)#
sample_mode(c(1, 2, 2))#
sample_mode(c(1, 2,))#
sample_mode(c(NA,NA,1))#
sample_mode(c(NA,NA,1), na.rm = TRUE)#
#
# partition creates quantile categories (corresponds to Stata xtile)#
v <- sample(10, 10, TRUE)                   #
partition(v, nq = 3) # 3 groups based on terciles#
partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#
# winsorize (default based on 5 x interquartile range)#
v <- sample(c(1:10,99), 100, TRUE)                   #
winsorize(v)#
winsorize(v, replace = NA)#
winsorize(v, cutpoints = quantile(v, c(0.01, 0.99), na.rm = TRUE))
partition(c(NA,1:3),3)
#' Create quantile categories (corresponds to Stata command xtile)#
#'#
#' @param x A vector#
#' @param nq Number of quantiles. Quantiles are computed as the inverse of the empirical distribution function#
#' @param cutpoints Cutpoints to use when \code{nq} is not specified.  For instance \code{cutpoints = 0.4} creates two groups, one for observations equal or below 0.4, one for observations superior to 0.4#
#' @examples #
#' v <- sample(10, 10, TRUE)                   #
#' partition(v, nq = 3) # 3 groups based on terciles#
#' partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#' @export#
partition <- function(x, nq = NULL, cutpoints = NULL){#
  if (!is.null(nq)){#
  if (!is.null(cutpoints)) stop("Only one option out of nq and cutpoints can be used")#
      breaks <- tail(head(quantile(x, seq(0, 1, length = nq + 1), type = 1, na.rm = TRUE), -1),-1)#
      return(partition(x, cutpoints = breaks))#
  } #
  length=length(cutpoints)+1#
  cut(x, breaks = c(min(x), cutpoints ,max(x)) , labels = seq_len(length), include.lowest=TRUE)#
}
partition(c(NA,1:3),3)
?quantile
cut(c(NA,1:3))
cut(c(NA,1:3), breaks = 3)
cut(c(NA,1:3), breaks = 2)
length(cut(c(NA,1:3), breaks = 2))
cut(c(NA,1:3), breaks = 2)
names(cut(c(NA,1:3), breaks = 2))
cut(c(NA,1:3), breaks = 2)
v <- cut(c(NA,1:3), breaks = 2)
str(v)
partition(1:3, nq = 3)
debug(partition)
partition(1:3, nq = 3)
s
n
c(min(x), cutpoints, max(x))
cutpoints
f
#' Create quantile categories (corresponds to Stata command xtile)#
#'#
#' @param x A vector#
#' @param nq Number of quantiles. Quantiles are computed as the inverse of the empirical distribution function#
#' @param cutpoints Cutpoints to use when \code{nq} is not specified.  For instance \code{cutpoints = 0.4} creates two groups, one for observations equal or below 0.4, one for observations superior to 0.4#
#' @returns A numerical vector#
#' @examples #
#' v <- sample(10, 10, TRUE)                   #
#' partition(v, nq = 3) # 3 groups based on terciles#
#' partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#' @export#
partition <- function(x, nq = NULL, cutpoints = NULL){#
  if (!is.null(nq)){#
  if (!is.null(cutpoints)) stop("Only one option out of nq and cutpoints can be used")#
      breaks <- tail(head(quantile(x, seq(0, 1, length = nq + 1), type = 1, na.rm = TRUE), -1),-1)#
      return(partition(x, cutpoints = breaks))#
  } #
  length=length(cutpoints)+1#
  cut(x, breaks = c(min(x)-1, cutpoints ,max(x)+1) , labels = seq_len(length), include.lowest=TRUE)#
}
partition(1:3, nq = 3)
#' Create quantile categories (corresponds to Stata command xtile)#
#'#
#' @param x A vector#
#' @param nq Number of quantiles. Quantiles are computed as the inverse of the empirical distribution function#
#' @param cutpoints Cutpoints to use when \code{nq} is not specified.  For instance \code{cutpoints = 0.4} creates two groups, one for observations equal or below 0.4, one for observations superior to 0.4#
#' @returns A numerical vector#
#' @examples #
#' v <- sample(10, 10, TRUE)                   #
#' partition(v, nq = 3) # 3 groups based on terciles#
#' partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#' @export#
partition <- function(x, nq = NULL, cutpoints = NULL){#
  if (!is.null(nq)){#
  if (!is.null(cutpoints)) stop("Only one option out of nq and cutpoints can be used")#
      breaks <- tail(head(quantile(x, seq(0, 1, length = nq + 1), type = 1, na.rm = TRUE), -1),-1)#
      return(partition(x, cutpoints = breaks))#
  } #
  length=length(cutpoints)+1#
  as.numeric(as.character(cut(x, breaks = c(min(x)-1, cutpoints ,max(x)+1) , labels = seq_len(length), include.lowest=TRUE)))#
}
partition(1:3, nq = 3)
?cut
#' Create quantile categories (corresponds to Stata command xtile)#
#'#
#' @param x A vector#
#' @param nq Number of quantiles. Quantiles are computed as the inverse of the empirical distribution function#
#' @param cutpoints Cutpoints to use when \code{nq} is not specified.  For instance \code{cutpoints = 0.4} creates two groups, one for observations equal or below 0.4, one for observations superior to 0.4#
#' @returns A numerical vector#
#' @examples #
#' v <- sample(10, 10, TRUE)                   #
#' partition(v, nq = 3) # 3 groups based on terciles#
#' partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#' @export#
partition <- function(x, nq = NULL, cutpoints = NULL){#
  if (!is.null(nq)){#
  if (!is.null(cutpoints)) stop("Only one option out of nq and cutpoints can be used")#
      breaks <- tail(head(quantile(x, seq(0, 1, length = nq + 1), type = 1, na.rm = TRUE), -1),-1)#
      return(partition(x, cutpoints = breaks))#
  } #
  length=length(cutpoints)+1#
  cut(x, breaks = c(min(x)-1, cutpoints ,max(x)+1) , labels = FALSE, include.lowest=TRUE))#
}
#' Create quantile categories (corresponds to Stata command xtile)#
#'#
#' @param x A vector#
#' @param nq Number of quantiles. Quantiles are computed as the inverse of the empirical distribution function#
#' @param cutpoints Cutpoints to use when \code{nq} is not specified.  For instance \code{cutpoints = 0.4} creates two groups, one for observations equal or below 0.4, one for observations superior to 0.4#
#' @returns A numerical vector#
#' @examples #
#' v <- sample(10, 10, TRUE)                   #
#' partition(v, nq = 3) # 3 groups based on terciles#
#' partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#' @export#
partition <- function(x, nq = NULL, cutpoints = NULL){#
  if (!is.null(nq)){#
  if (!is.null(cutpoints)) stop("Only one option out of nq and cutpoints can be used")#
      breaks <- tail(head(quantile(x, seq(0, 1, length = nq + 1), type = 1, na.rm = TRUE), -1),-1)#
      return(partition(x, cutpoints = breaks))#
  } #
  length=length(cutpoints)+1#
  cut(x, breaks = c(min(x)-1, cutpoints ,max(x)+1) , labels = FALSE, include.lowest=TRUE)#
}
partition(1:3, nq = 3)
#' Create quantile categories (corresponds to Stata command xtile)#
#'#
#' @param x A vector#
#' @param nq Number of quantiles. Quantiles are computed as the inverse of the empirical distribution function#
#' @param cutpoints Cutpoints to use when \code{nq} is not specified.  For instance \code{cutpoints = 0.4} creates two groups, one for observations equal or below 0.4, one for observations superior to 0.4#
#' @returns An integer ector#
#' @examples #
#' v <- sample(10, 10, TRUE)                   #
#' partition(v, nq = 3) # 3 groups based on terciles#
#' partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#' @export#
partition <- function(x, nq = NULL, cutpoints = NULL){#
  if (!is.null(nq)){#
  if (!is.null(cutpoints)) stop("Only one option out of nq and cutpoints can be used")#
      breaks <- tail(head(quantile(x, seq(0, 1, length = nq + 1), type = 1, na.rm = TRUE), -1),-1)#
      return(partition(x, cutpoints = breaks))#
  } #
  length=length(cutpoints)+1#
  cut(x, breaks = c(min(x)-1, cutpoints , max(x)+1) , labels = FALSE, include.lowest=TRUE)#
}
cut(c(NA,1), breaks = 3)
cut(c(NA,1), breaks = 1)
cut(c(NA,1,3), breaks = 1)
cut(c(NA,1,3), breaks = 2)
?cut
partition(c(NA,1,3), cutpoints = 1)
cut(c(NA,1,3), breaks = 2, labels = FALSE)
debug(partition)
cut(c(NA,1,3), breaks = 2, labels = FALSE)
partition(c(NA,1,3), cutpoints = 1)
n
partition(c(NA,1,3), cutpoints = 1)
min(x)
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Create quantile categories (corresponds to Stata command xtile)#
#'#
#' @param x A vector#
#' @param nq Number of quantiles. Quantiles are computed as the inverse of the empirical distribution function#
#' @param cutpoints Cutpoints to use when \code{nq} is not specified.  For instance \code{cutpoints = 0.4} creates two groups, one for observations equal or below 0.4, one for observations superior to 0.4#
#' @returns An integer ector#
#' @examples #
#' v <- sample(10, 10, TRUE)                   #
#' partition(v, nq = 3) # 3 groups based on terciles#
#' partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#' @export#
partition <- function(x, nq = NULL, cutpoints = NULL){#
  if (!is.null(nq)){#
  if (!is.null(cutpoints)) stop("Only one option out of nq and cutpoints can be used")#
      breaks <- tail(head(quantile(x, seq(0, 1, length = nq + 1), type = 1, na.rm = TRUE), -1),-1)#
      return(partition(x, cutpoints = breaks))#
  } #
  length=length(cutpoints)+1#
  cut(x, breaks = c(min(x, na.rm = TRUE)-1, cutpoints , max(x, na.rm = TRUE)+1) , labels = FALSE, include.lowest=TRUE)#
}
f
setwd("/Users/Matthieu/Dropbox/Github/statar-package/R")#
#' Create quantile categories (corresponds to Stata command xtile)#
#'#
#' @param x A vector#
#' @param nq Number of quantiles. Quantiles are computed as the inverse of the empirical distribution function#
#' @param cutpoints Cutpoints to use when \code{nq} is not specified.  For instance \code{cutpoints = 0.4} creates two groups, one for observations equal or below 0.4, one for observations superior to 0.4#
#' @returns An integer ector#
#' @examples #
#' v <- sample(10, 10, TRUE)                   #
#' partition(v, nq = 3) # 3 groups based on terciles#
#' partition(v, cutpoints = c(1e5, 5e5)) # 3 groups based on two cutpoints#
#' @export#
partition <- function(x, nq = NULL, cutpoints = NULL){#
  if (!is.null(nq)){#
  if (!is.null(cutpoints)) stop("Only one option out of nq and cutpoints can be used")#
      breaks <- tail(head(quantile(x, seq(0, 1, length = nq + 1), type = 1, na.rm = TRUE), -1),-1)#
      return(partition(x, cutpoints = breaks))#
  } #
  length=length(cutpoints)+1#
  cut(x, breaks = c(min(x, na.rm = TRUE)-1, cutpoints , max(x, na.rm = TRUE)+1) , labels = FALSE, include.lowest=TRUE)#
}
partition(c(NA,1,3), cutpoints = 1)
v <- sample(10, 10, TRUE)
v
partition(v, nq = 3)
v <- sample(c(NA,1:10, 10, TRUE)
)
v
partition(v, nq = 3
)
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
devtools::document("/Users/Matthieu/Dropbox/Github/statar-package")
