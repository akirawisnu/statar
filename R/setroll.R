#' Version of mutate_each that applies rollling functions
#' 
#' @param x a data.table
#' @param funs List of function calls, generated by funs, or a character vector of function names.
#' @param ... Variables on which the functions should be applied. Defaults to all non-grouping variables. See the \link[dplyr]{select} documentation.
#' @param n an integer. Window is all the observations in \code{[along_with - n, along_with]}
#' @param along_with Numeric variable specifying dates. See the \link[dplyr]{select} documentation.
#' @param by Variables by which to group. Default to keys (or to keys minus last if along_with is unspecified). ee the \link[dplyr]{select} documentation.
#' @examples
#' DT <- data.table(
#'  date =  c(1,2,4,7),
#'  value =  c(1,1,1,1)
#' )
#' DT1 <- copy(DT)
#' setroll(DT, funs(count = sum), value, n = 2,  along_with = date)
#' setroll(DT1, funs(count = sum), value, n = -2,  along_with = date)

#' @export
setroll <- function(x, funs, ..., n, along_with, by = NULL, i = NULL){
    setroll_(x, funs, vars = lazy_dots(...), n = n, along_with = substitute(along_with), by = substitute(by), i = substitute(i))
}

#' @export
#' @rdname setroll
setroll_<- function(x, funs, vars, n, along_with, i = NULL, by = NULL){
    stopifnot(is.data.table(x))
    if (anyDuplicated(names(funs))){
      stop("Multiple functions are specified with the same name", call. = FALSE)
    }
   along_with  <- names(select_vars_(names(x), along_with ))
   byvars <- names(select_vars_(names(x), by, exclude = along_with))
    if (!length(by)){
        byvars <- NULL
    }
    vars <- lazyeval::all_dots(vars)
    vars_expr <- colwise_(x, funs_(funs), vars, byvars = byvars, replace = FALSE)
    varsname <- names(select_vars_(names(x), vars, exclude = c(along_with, byvars)))

    # set key and check no duplicate along id and along_with
    setkeyv(x, c(byvars, along_with))
    if (anyDuplicated(x)) stop("variables", byvars, along_with, "don't uniquely identify observations")
    DTx <- shallow_(x, c(byvars, along_with)) 
    DTy <- shallow_(x, c(byvars, along_with, varsname)) 
	if (!is.null(i)){
		DTy <- filter_(x, .dots = i) 
	}
    along_withq <- as.name(along_with)
    if (n > 0){
    	date_begin <- tempname(x)
    	date_end <- along_with
    	date_endq <- as.name(date_end)
    	evalm(DTx[, `$date_begin` := `$date_endq` - 1])
		evalm(DTy[, `$date_begin` := `$date_endq` - `$n`- 1])
	 } else{
    	date_begin <- along_with
  		date_beginq <- as.name(date_begin)
    	date_end <- tempname(x)
    	evalm(DTx[, `$date_end` := `$date_beginq` + 1])
		evalm(DTy[, `$date_end` := `$date_beginq` - `$n`+ 1])
	 }
    setkeyv(DTy, c(byvars, date_begin, date_end))
    setkeyv(DTx, c(byvars,  date_begin, date_end))
    ans <- foverlaps(DTx, DTy, nomatch = 0, type = "within") 
	setkeep_(ans, c(byvars, varsname, along_with))
    env <- dt_env(ans, common_env(vars_expr), c(byvars, along_with))
    list_call <- lazyeval::make_call(quote(list), vars_expr)
    call <- substitute(dt[, list_call, keyby = byvars], list(list_call = list_call$expr))
    out <- eval(call, env)
    suppressMessages(join(x, out, kind = "left", on = c(byvars, along_with),  check = 1~1, inplace = TRUE))
}


#setroll2_<- function(x, funs, vars, n, order_by = NULL, along_with, i = NULL, by = NULL){
#    stopifnot(is.data.table(x))
#    if (anyDuplicated(names(funs))){
#      stop("Multiple functions are specified with the same name", call. = FALSE)
#    }
#   along_with  <- names(select_vars_(names(x), along_with ))
#   byvars <- names(select_vars_(names(x), by, exclude = along_with))
#    if (!length(by)){
#        byvars <- NULL
#    }
#    vars <- lazyeval::all_dots(vars)
#    vars_expr <- colwise_(x, funs_(funs), vars, byvars = byvars, replace = FALSE)
#    varsname <- names(select_vars_(names(x), vars, exclude = c(along_with, byvars)))
#    setkeyv(x, c(byvars, along_with))
#    if (anyDuplicated(x)) stop("variables", byvars, along_with, "don't uniquely identify observations"#)
#    DTy <- select_(x, .dots = c(byvars, along_with, varsname)) 
#	if (!is.null(i)){
#		DTy <- filter_(x, .dots = i) 
#	}
#    tempname <- tempname(x)
#    along_withq <- as.name(along_with)
#    DTy[, c(tempname) := eval(along_withq) - n]
#    setkeyv(DTy, c(byvars, tempname, along_with))
#    DTx <- copy(DTy)
#    DTx[, c(tempname) := eval(along_withq) - 1]
#    setkeyv(DTx, c(byvars,  tempname, along_with))
#    ans <- foverlaps(DTx, DTy, nomatch = 0, type = "within", which = TRUE) 
#
#    ans <- ans[, list(xid = list(xid)), by = yid]
#    ans2 <- DTx[ans[["yid"]]]
#    ans2[, xid := ans[["xid"]]]
#
#fo
#
#
#
#
#    env <- dt_env(ans, common_env(vars_expr), c(byvars, along_with))
#    list_call <- lazyeval::make_call(quote(list), vars_expr)
#    call <- substitute(dt[, list_call, keyby = byvars], list(list_call = list_call$expr))
#    print(call)
#    out <- eval(call, env)
#    setkeep_(ans, c(vars, byvars, paste0("i.", c(along_with))))
#    setnames(ans, paste0("i.", c(along_with)), along_with)
#    join(x, out, kind = "left", on = c(byvars, along_with),  check = 1~1, inplace = TRUE)
#}




